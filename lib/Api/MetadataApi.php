<?php
/**
 * MetadataApi
 * PHP version 7.4
 *
 * @category Class
 * @package  Sendbird
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Sendbird Platform SDK
 *
 * Sendbird Platform API SDK  [https://sendbird.com/docs/chat/v3/platform-api/getting-started/prepare-to-use-api](https://sendbird.com/docs/chat/v3/platform-api/getting-started/prepare-to-use-api)  Contact Support:   Name: Sendbird   Email: [support@sendbird.com](https://mailto:support@sendbird.com)
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@sendbird.com
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 6.0.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Sendbird\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Sendbird\ApiException;
use Sendbird\Configuration;
use Sendbird\HeaderSelector;
use Sendbird\ObjectSerializer;

/**
 * MetadataApi Class Doc Comment
 *
 * @category Class
 * @package  Sendbird
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class MetadataApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation createAChannelMetadata
     *
     * Create a channel metadata
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_type (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token api_token (optional)
     * @param  \Sendbird\Model\CreateAChannelMetadataRequest $create_a_channel_metadata_request create_a_channel_metadata_request (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sendbird\Model\CreateAChannelMetadataResponse
     */
    public function createAChannelMetadata($associative_array)
    {
        list($response) = $this->createAChannelMetadataWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation createAChannelMetadataWithHttpInfo
     *
     * Create a channel metadata
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_type (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\CreateAChannelMetadataRequest $create_a_channel_metadata_request (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sendbird\Model\CreateAChannelMetadataResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createAChannelMetadataWithHttpInfo($associative_array)
    {
        $request = $this->createAChannelMetadataRequest($associative_array);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Sendbird\Model\CreateAChannelMetadataResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sendbird\Model\CreateAChannelMetadataResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sendbird\Model\CreateAChannelMetadataResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sendbird\Model\CreateAChannelMetadataResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sendbird\Model\CreateAChannelMetadataResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createAChannelMetadataAsync
     *
     * Create a channel metadata
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_type (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\CreateAChannelMetadataRequest $create_a_channel_metadata_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAChannelMetadataAsync($associative_array)
    {
        return $this->createAChannelMetadataAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createAChannelMetadataAsyncWithHttpInfo
     *
     * Create a channel metadata
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_type (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\CreateAChannelMetadataRequest $create_a_channel_metadata_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAChannelMetadataAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\Sendbird\Model\CreateAChannelMetadataResponse';
        $request = $this->createAChannelMetadataRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createAChannelMetadata'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_type (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\CreateAChannelMetadataRequest $create_a_channel_metadata_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createAChannelMetadataRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $channel_type = array_key_exists('channel_type', $associative_array) ? $associative_array['channel_type'] : null;
        $channel_url = array_key_exists('channel_url', $associative_array) ? $associative_array['channel_url'] : null;
        $api_token = array_key_exists('api_token', $associative_array) ? $associative_array['api_token'] : null;
        $create_a_channel_metadata_request = array_key_exists('create_a_channel_metadata_request', $associative_array) ? $associative_array['create_a_channel_metadata_request'] : null;

        // verify the required parameter 'channel_type' is set
        if ($channel_type === null || (is_array($channel_type) && count($channel_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel_type when calling createAChannelMetadata'
            );
        }
        // verify the required parameter 'channel_url' is set
        if ($channel_url === null || (is_array($channel_url) && count($channel_url) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel_url when calling createAChannelMetadata'
            );
        }

        $resourcePath = '/v3/{channel_type}/{channel_url}/metadata';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($api_token !== null) {
            $headerParams['api-token'] = ObjectSerializer::toHeaderValue($api_token);
        }

        // path params
        if ($channel_type !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_type' . '}',
                ObjectSerializer::toPathValue($channel_type),
                $resourcePath
            );
        }
        // path params
        if ($channel_url !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_url' . '}',
                ObjectSerializer::toPathValue($channel_url),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($create_a_channel_metadata_request)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($create_a_channel_metadata_request));
            } else {
                $httpBody = $create_a_channel_metadata_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteAChannelMetadataWhenDeletingAllItemsOfAChannelMetadata
     *
     * Delete a channel metadata - When deleting all items of a channel metadata
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_type (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  string $key key (optional)
     * @param  string $api_token api_token (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function deleteAChannelMetadataWhenDeletingAllItemsOfAChannelMetadata($associative_array)
    {
        list($response) = $this->deleteAChannelMetadataWhenDeletingAllItemsOfAChannelMetadataWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation deleteAChannelMetadataWhenDeletingAllItemsOfAChannelMetadataWithHttpInfo
     *
     * Delete a channel metadata - When deleting all items of a channel metadata
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_type (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  string $key (optional)
     * @param  string $api_token (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteAChannelMetadataWhenDeletingAllItemsOfAChannelMetadataWithHttpInfo($associative_array)
    {
        $request = $this->deleteAChannelMetadataWhenDeletingAllItemsOfAChannelMetadataRequest($associative_array);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteAChannelMetadataWhenDeletingAllItemsOfAChannelMetadataAsync
     *
     * Delete a channel metadata - When deleting all items of a channel metadata
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_type (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  string $key (optional)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAChannelMetadataWhenDeletingAllItemsOfAChannelMetadataAsync($associative_array)
    {
        return $this->deleteAChannelMetadataWhenDeletingAllItemsOfAChannelMetadataAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteAChannelMetadataWhenDeletingAllItemsOfAChannelMetadataAsyncWithHttpInfo
     *
     * Delete a channel metadata - When deleting all items of a channel metadata
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_type (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  string $key (optional)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAChannelMetadataWhenDeletingAllItemsOfAChannelMetadataAsyncWithHttpInfo($associative_array)
    {
        $returnType = 'object';
        $request = $this->deleteAChannelMetadataWhenDeletingAllItemsOfAChannelMetadataRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteAChannelMetadataWhenDeletingAllItemsOfAChannelMetadata'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_type (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  string $key (optional)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteAChannelMetadataWhenDeletingAllItemsOfAChannelMetadataRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $channel_type = array_key_exists('channel_type', $associative_array) ? $associative_array['channel_type'] : null;
        $channel_url = array_key_exists('channel_url', $associative_array) ? $associative_array['channel_url'] : null;
        $key = array_key_exists('key', $associative_array) ? $associative_array['key'] : null;
        $api_token = array_key_exists('api_token', $associative_array) ? $associative_array['api_token'] : null;

        // verify the required parameter 'channel_type' is set
        if ($channel_type === null || (is_array($channel_type) && count($channel_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel_type when calling deleteAChannelMetadataWhenDeletingAllItemsOfAChannelMetadata'
            );
        }
        // verify the required parameter 'channel_url' is set
        if ($channel_url === null || (is_array($channel_url) && count($channel_url) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel_url when calling deleteAChannelMetadataWhenDeletingAllItemsOfAChannelMetadata'
            );
        }

        $resourcePath = '/v3/{channel_type}/{channel_url}/metadata';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($api_token !== null) {
            $headerParams['api-token'] = ObjectSerializer::toHeaderValue($api_token);
        }

        // path params
        if ($channel_type !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_type' . '}',
                ObjectSerializer::toPathValue($channel_type),
                $resourcePath
            );
        }
        // path params
        if ($channel_url !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_url' . '}',
                ObjectSerializer::toPathValue($channel_url),
                $resourcePath
            );
        }
        // path params
        if ($key !== null) {
            $resourcePath = str_replace(
                '{' . 'key' . '}',
                ObjectSerializer::toPathValue($key),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateAChannelMetadata
     *
     * Update a channel metadata - When updating existing items of a channel metadata by their keys or adding new items to the metadata
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_type (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token api_token (optional)
     * @param  \Sendbird\Model\UpdateAChannelMetadataRequest $update_a_channel_metadata_request update_a_channel_metadata_request (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function updateAChannelMetadata($associative_array)
    {
        list($response) = $this->updateAChannelMetadataWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation updateAChannelMetadataWithHttpInfo
     *
     * Update a channel metadata - When updating existing items of a channel metadata by their keys or adding new items to the metadata
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_type (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\UpdateAChannelMetadataRequest $update_a_channel_metadata_request (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateAChannelMetadataWithHttpInfo($associative_array)
    {
        $request = $this->updateAChannelMetadataRequest($associative_array);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateAChannelMetadataAsync
     *
     * Update a channel metadata - When updating existing items of a channel metadata by their keys or adding new items to the metadata
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_type (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\UpdateAChannelMetadataRequest $update_a_channel_metadata_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateAChannelMetadataAsync($associative_array)
    {
        return $this->updateAChannelMetadataAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateAChannelMetadataAsyncWithHttpInfo
     *
     * Update a channel metadata - When updating existing items of a channel metadata by their keys or adding new items to the metadata
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_type (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\UpdateAChannelMetadataRequest $update_a_channel_metadata_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateAChannelMetadataAsyncWithHttpInfo($associative_array)
    {
        $returnType = 'object';
        $request = $this->updateAChannelMetadataRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateAChannelMetadata'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_type (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\UpdateAChannelMetadataRequest $update_a_channel_metadata_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateAChannelMetadataRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $channel_type = array_key_exists('channel_type', $associative_array) ? $associative_array['channel_type'] : null;
        $channel_url = array_key_exists('channel_url', $associative_array) ? $associative_array['channel_url'] : null;
        $api_token = array_key_exists('api_token', $associative_array) ? $associative_array['api_token'] : null;
        $update_a_channel_metadata_request = array_key_exists('update_a_channel_metadata_request', $associative_array) ? $associative_array['update_a_channel_metadata_request'] : null;

        // verify the required parameter 'channel_type' is set
        if ($channel_type === null || (is_array($channel_type) && count($channel_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel_type when calling updateAChannelMetadata'
            );
        }
        // verify the required parameter 'channel_url' is set
        if ($channel_url === null || (is_array($channel_url) && count($channel_url) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel_url when calling updateAChannelMetadata'
            );
        }

        $resourcePath = '/v3/{channel_type}/{channel_url}/metadata';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($api_token !== null) {
            $headerParams['api-token'] = ObjectSerializer::toHeaderValue($api_token);
        }

        // path params
        if ($channel_type !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_type' . '}',
                ObjectSerializer::toPathValue($channel_type),
                $resourcePath
            );
        }
        // path params
        if ($channel_url !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_url' . '}',
                ObjectSerializer::toPathValue($channel_url),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($update_a_channel_metadata_request)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($update_a_channel_metadata_request));
            } else {
                $httpBody = $update_a_channel_metadata_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation viewAChannelMetadataWhenRetrievingAllItemsOfAChannelMetadata
     *
     * View a channel metadata - When retrieving all items of a channel metadata
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_type (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  string $key key (optional)
     * @param  string $keys In a query string, specifies an array of one or more keys of the metadata items. If not specified, all items of the metadata are returned. If specified, only the items that match the parameter values are returned. URL encoding each key is recommended. (optional)
     * @param  string $api_token api_token (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function viewAChannelMetadataWhenRetrievingAllItemsOfAChannelMetadata($associative_array)
    {
        list($response) = $this->viewAChannelMetadataWhenRetrievingAllItemsOfAChannelMetadataWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation viewAChannelMetadataWhenRetrievingAllItemsOfAChannelMetadataWithHttpInfo
     *
     * View a channel metadata - When retrieving all items of a channel metadata
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_type (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  string $key (optional)
     * @param  string $keys In a query string, specifies an array of one or more keys of the metadata items. If not specified, all items of the metadata are returned. If specified, only the items that match the parameter values are returned. URL encoding each key is recommended. (optional)
     * @param  string $api_token (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function viewAChannelMetadataWhenRetrievingAllItemsOfAChannelMetadataWithHttpInfo($associative_array)
    {
        $request = $this->viewAChannelMetadataWhenRetrievingAllItemsOfAChannelMetadataRequest($associative_array);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation viewAChannelMetadataWhenRetrievingAllItemsOfAChannelMetadataAsync
     *
     * View a channel metadata - When retrieving all items of a channel metadata
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_type (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  string $key (optional)
     * @param  string $keys In a query string, specifies an array of one or more keys of the metadata items. If not specified, all items of the metadata are returned. If specified, only the items that match the parameter values are returned. URL encoding each key is recommended. (optional)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function viewAChannelMetadataWhenRetrievingAllItemsOfAChannelMetadataAsync($associative_array)
    {
        return $this->viewAChannelMetadataWhenRetrievingAllItemsOfAChannelMetadataAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation viewAChannelMetadataWhenRetrievingAllItemsOfAChannelMetadataAsyncWithHttpInfo
     *
     * View a channel metadata - When retrieving all items of a channel metadata
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_type (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  string $key (optional)
     * @param  string $keys In a query string, specifies an array of one or more keys of the metadata items. If not specified, all items of the metadata are returned. If specified, only the items that match the parameter values are returned. URL encoding each key is recommended. (optional)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function viewAChannelMetadataWhenRetrievingAllItemsOfAChannelMetadataAsyncWithHttpInfo($associative_array)
    {
        $returnType = 'object';
        $request = $this->viewAChannelMetadataWhenRetrievingAllItemsOfAChannelMetadataRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'viewAChannelMetadataWhenRetrievingAllItemsOfAChannelMetadata'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_type (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  string $key (optional)
     * @param  string $keys In a query string, specifies an array of one or more keys of the metadata items. If not specified, all items of the metadata are returned. If specified, only the items that match the parameter values are returned. URL encoding each key is recommended. (optional)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function viewAChannelMetadataWhenRetrievingAllItemsOfAChannelMetadataRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $channel_type = array_key_exists('channel_type', $associative_array) ? $associative_array['channel_type'] : null;
        $channel_url = array_key_exists('channel_url', $associative_array) ? $associative_array['channel_url'] : null;
        $key = array_key_exists('key', $associative_array) ? $associative_array['key'] : null;
        $keys = array_key_exists('keys', $associative_array) ? $associative_array['keys'] : null;
        $api_token = array_key_exists('api_token', $associative_array) ? $associative_array['api_token'] : null;

        // verify the required parameter 'channel_type' is set
        if ($channel_type === null || (is_array($channel_type) && count($channel_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel_type when calling viewAChannelMetadataWhenRetrievingAllItemsOfAChannelMetadata'
            );
        }
        // verify the required parameter 'channel_url' is set
        if ($channel_url === null || (is_array($channel_url) && count($channel_url) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel_url when calling viewAChannelMetadataWhenRetrievingAllItemsOfAChannelMetadata'
            );
        }

        $resourcePath = '/v3/{channel_type}/{channel_url}/metadata';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $key,
            'key', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $keys,
            'keys', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($api_token !== null) {
            $headerParams['api-token'] = ObjectSerializer::toHeaderValue($api_token);
        }

        // path params
        if ($channel_type !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_type' . '}',
                ObjectSerializer::toPathValue($channel_type),
                $resourcePath
            );
        }
        // path params
        if ($channel_url !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_url' . '}',
                ObjectSerializer::toPathValue($channel_url),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
