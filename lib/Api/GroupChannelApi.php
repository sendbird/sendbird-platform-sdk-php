<?php
/**
 * GroupChannelApi
 * PHP version 7.4
 *
 * @category Class
 * @package  Sendbird
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Sendbird Platform SDK
 *
 * Sendbird Platform API SDK  [https://sendbird.com/docs/chat/v3/platform-api/getting-started/prepare-to-use-api](https://sendbird.com/docs/chat/v3/platform-api/getting-started/prepare-to-use-api)  Contact Support:   Name: Sendbird   Email: [support@sendbird.com](https://mailto:support@sendbird.com)
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@sendbird.com
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 6.0.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Sendbird\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Sendbird\ApiException;
use Sendbird\Configuration;
use Sendbird\HeaderSelector;
use Sendbird\ObjectSerializer;

/**
 * GroupChannelApi Class Doc Comment
 *
 * @category Class
 * @package  Sendbird
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class GroupChannelApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation acceptAnInvitation
     *
     * Accept an invitation
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token api_token (optional)
     * @param  \Sendbird\Model\AcceptAnInvitationRequest $accept_an_invitation_request accept_an_invitation_request (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sendbird\Model\SendbirdGroupChannelDetail
     */
    public function acceptAnInvitation($associative_array)
    {
        list($response) = $this->acceptAnInvitationWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation acceptAnInvitationWithHttpInfo
     *
     * Accept an invitation
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\AcceptAnInvitationRequest $accept_an_invitation_request (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sendbird\Model\SendbirdGroupChannelDetail, HTTP status code, HTTP response headers (array of strings)
     */
    public function acceptAnInvitationWithHttpInfo($associative_array)
    {
        $request = $this->acceptAnInvitationRequest($associative_array);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Sendbird\Model\SendbirdGroupChannelDetail' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sendbird\Model\SendbirdGroupChannelDetail' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sendbird\Model\SendbirdGroupChannelDetail', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sendbird\Model\SendbirdGroupChannelDetail';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sendbird\Model\SendbirdGroupChannelDetail',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation acceptAnInvitationAsync
     *
     * Accept an invitation
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\AcceptAnInvitationRequest $accept_an_invitation_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function acceptAnInvitationAsync($associative_array)
    {
        return $this->acceptAnInvitationAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation acceptAnInvitationAsyncWithHttpInfo
     *
     * Accept an invitation
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\AcceptAnInvitationRequest $accept_an_invitation_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function acceptAnInvitationAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\Sendbird\Model\SendbirdGroupChannelDetail';
        $request = $this->acceptAnInvitationRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'acceptAnInvitation'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\AcceptAnInvitationRequest $accept_an_invitation_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function acceptAnInvitationRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $channel_url = array_key_exists('channel_url', $associative_array) ? $associative_array['channel_url'] : null;
        $api_token = array_key_exists('api_token', $associative_array) ? $associative_array['api_token'] : null;
        $accept_an_invitation_request = array_key_exists('accept_an_invitation_request', $associative_array) ? $associative_array['accept_an_invitation_request'] : null;

        // verify the required parameter 'channel_url' is set
        if ($channel_url === null || (is_array($channel_url) && count($channel_url) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel_url when calling acceptAnInvitation'
            );
        }

        $resourcePath = '/v3/group_channels/{channel_url}/accept';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($api_token !== null) {
            $headerParams['api-token'] = ObjectSerializer::toHeaderValue($api_token);
        }

        // path params
        if ($channel_url !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_url' . '}',
                ObjectSerializer::toPathValue($channel_url),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($accept_an_invitation_request)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($accept_an_invitation_request));
            } else {
                $httpBody = $accept_an_invitation_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cancelTheRegistrationOfOperators
     *
     * Cancel the registration of operators
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (Required) (required)
     * @param  string $operator_ids Specifies an array of one or more operator IDs to unregister from the channel. The operators in this array remain as participants of the channel after losing their operational roles. Urlencoding each operator ID is recommended. An example of a Urlencoded array would be ?operator_ids&#x3D;urlencoded_id_1,urlencoded_id_2. (required)
     * @param  bool $delete_all delete_all (optional)
     * @param  string $api_token api_token (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function cancelTheRegistrationOfOperators($associative_array)
    {
        list($response) = $this->cancelTheRegistrationOfOperatorsWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation cancelTheRegistrationOfOperatorsWithHttpInfo
     *
     * Cancel the registration of operators
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (Required) (required)
     * @param  string $operator_ids Specifies an array of one or more operator IDs to unregister from the channel. The operators in this array remain as participants of the channel after losing their operational roles. Urlencoding each operator ID is recommended. An example of a Urlencoded array would be ?operator_ids&#x3D;urlencoded_id_1,urlencoded_id_2. (required)
     * @param  bool $delete_all (optional)
     * @param  string $api_token (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function cancelTheRegistrationOfOperatorsWithHttpInfo($associative_array)
    {
        $request = $this->cancelTheRegistrationOfOperatorsRequest($associative_array);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cancelTheRegistrationOfOperatorsAsync
     *
     * Cancel the registration of operators
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (Required) (required)
     * @param  string $operator_ids Specifies an array of one or more operator IDs to unregister from the channel. The operators in this array remain as participants of the channel after losing their operational roles. Urlencoding each operator ID is recommended. An example of a Urlencoded array would be ?operator_ids&#x3D;urlencoded_id_1,urlencoded_id_2. (required)
     * @param  bool $delete_all (optional)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cancelTheRegistrationOfOperatorsAsync($associative_array)
    {
        return $this->cancelTheRegistrationOfOperatorsAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cancelTheRegistrationOfOperatorsAsyncWithHttpInfo
     *
     * Cancel the registration of operators
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (Required) (required)
     * @param  string $operator_ids Specifies an array of one or more operator IDs to unregister from the channel. The operators in this array remain as participants of the channel after losing their operational roles. Urlencoding each operator ID is recommended. An example of a Urlencoded array would be ?operator_ids&#x3D;urlencoded_id_1,urlencoded_id_2. (required)
     * @param  bool $delete_all (optional)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cancelTheRegistrationOfOperatorsAsyncWithHttpInfo($associative_array)
    {
        $returnType = 'object';
        $request = $this->cancelTheRegistrationOfOperatorsRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cancelTheRegistrationOfOperators'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (Required) (required)
     * @param  string $operator_ids Specifies an array of one or more operator IDs to unregister from the channel. The operators in this array remain as participants of the channel after losing their operational roles. Urlencoding each operator ID is recommended. An example of a Urlencoded array would be ?operator_ids&#x3D;urlencoded_id_1,urlencoded_id_2. (required)
     * @param  bool $delete_all (optional)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cancelTheRegistrationOfOperatorsRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $channel_url = array_key_exists('channel_url', $associative_array) ? $associative_array['channel_url'] : null;
        $operator_ids = array_key_exists('operator_ids', $associative_array) ? $associative_array['operator_ids'] : null;
        $delete_all = array_key_exists('delete_all', $associative_array) ? $associative_array['delete_all'] : null;
        $api_token = array_key_exists('api_token', $associative_array) ? $associative_array['api_token'] : null;

        // verify the required parameter 'channel_url' is set
        if ($channel_url === null || (is_array($channel_url) && count($channel_url) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel_url when calling cancelTheRegistrationOfOperators'
            );
        }
        // verify the required parameter 'operator_ids' is set
        if ($operator_ids === null || (is_array($operator_ids) && count($operator_ids) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $operator_ids when calling cancelTheRegistrationOfOperators'
            );
        }

        $resourcePath = '/v3/group_channels/{channel_url}/operators';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $operator_ids,
            'operator_ids', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $delete_all,
            'delete_all', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($api_token !== null) {
            $headerParams['api-token'] = ObjectSerializer::toHeaderValue($api_token);
        }

        // path params
        if ($channel_url !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_url' . '}',
                ObjectSerializer::toPathValue($channel_url),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation checkIfMember
     *
     * Check if member
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (Required) (required)
     * @param  string $user_id (Required) (required)
     * @param  string $api_token api_token (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sendbird\Model\CheckIfMemberResponse
     */
    public function checkIfMember($associative_array)
    {
        list($response) = $this->checkIfMemberWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation checkIfMemberWithHttpInfo
     *
     * Check if member
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (Required) (required)
     * @param  string $user_id (Required) (required)
     * @param  string $api_token (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sendbird\Model\CheckIfMemberResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function checkIfMemberWithHttpInfo($associative_array)
    {
        $request = $this->checkIfMemberRequest($associative_array);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Sendbird\Model\CheckIfMemberResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sendbird\Model\CheckIfMemberResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sendbird\Model\CheckIfMemberResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sendbird\Model\CheckIfMemberResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sendbird\Model\CheckIfMemberResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation checkIfMemberAsync
     *
     * Check if member
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (Required) (required)
     * @param  string $user_id (Required) (required)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function checkIfMemberAsync($associative_array)
    {
        return $this->checkIfMemberAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation checkIfMemberAsyncWithHttpInfo
     *
     * Check if member
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (Required) (required)
     * @param  string $user_id (Required) (required)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function checkIfMemberAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\Sendbird\Model\CheckIfMemberResponse';
        $request = $this->checkIfMemberRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'checkIfMember'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (Required) (required)
     * @param  string $user_id (Required) (required)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function checkIfMemberRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $channel_url = array_key_exists('channel_url', $associative_array) ? $associative_array['channel_url'] : null;
        $user_id = array_key_exists('user_id', $associative_array) ? $associative_array['user_id'] : null;
        $api_token = array_key_exists('api_token', $associative_array) ? $associative_array['api_token'] : null;

        // verify the required parameter 'channel_url' is set
        if ($channel_url === null || (is_array($channel_url) && count($channel_url) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel_url when calling checkIfMember'
            );
        }
        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_id when calling checkIfMember'
            );
        }

        $resourcePath = '/v3/group_channels/{channel_url}/members/{user_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($api_token !== null) {
            $headerParams['api-token'] = ObjectSerializer::toHeaderValue($api_token);
        }

        // path params
        if ($channel_url !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_url' . '}',
                ObjectSerializer::toPathValue($channel_url),
                $resourcePath
            );
        }
        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'user_id' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createAGroupChannel
     *
     * Create a group channel
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $api_token api_token (optional)
     * @param  \Sendbird\Model\CreateAGroupChannelRequest $create_a_group_channel_request create_a_group_channel_request (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sendbird\Model\SendbirdGroupChannelDetail
     */
    public function createAGroupChannel($associative_array)
    {
        list($response) = $this->createAGroupChannelWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation createAGroupChannelWithHttpInfo
     *
     * Create a group channel
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\CreateAGroupChannelRequest $create_a_group_channel_request (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sendbird\Model\SendbirdGroupChannelDetail, HTTP status code, HTTP response headers (array of strings)
     */
    public function createAGroupChannelWithHttpInfo($associative_array)
    {
        $request = $this->createAGroupChannelRequest($associative_array);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Sendbird\Model\SendbirdGroupChannelDetail' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sendbird\Model\SendbirdGroupChannelDetail' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sendbird\Model\SendbirdGroupChannelDetail', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sendbird\Model\SendbirdGroupChannelDetail';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sendbird\Model\SendbirdGroupChannelDetail',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createAGroupChannelAsync
     *
     * Create a group channel
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\CreateAGroupChannelRequest $create_a_group_channel_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAGroupChannelAsync($associative_array)
    {
        return $this->createAGroupChannelAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createAGroupChannelAsyncWithHttpInfo
     *
     * Create a group channel
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\CreateAGroupChannelRequest $create_a_group_channel_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAGroupChannelAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\Sendbird\Model\SendbirdGroupChannelDetail';
        $request = $this->createAGroupChannelRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createAGroupChannel'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\CreateAGroupChannelRequest $create_a_group_channel_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createAGroupChannelRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $api_token = array_key_exists('api_token', $associative_array) ? $associative_array['api_token'] : null;
        $create_a_group_channel_request = array_key_exists('create_a_group_channel_request', $associative_array) ? $associative_array['create_a_group_channel_request'] : null;


        $resourcePath = '/v3/group_channels';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($api_token !== null) {
            $headerParams['api-token'] = ObjectSerializer::toHeaderValue($api_token);
        }



        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($create_a_group_channel_request)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($create_a_group_channel_request));
            } else {
                $httpBody = $create_a_group_channel_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteAGroupChannel
     *
     * Delete a group channel
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url channel_url (required)
     * @param  string $api_token api_token (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function deleteAGroupChannel($associative_array)
    {
        list($response) = $this->deleteAGroupChannelWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation deleteAGroupChannelWithHttpInfo
     *
     * Delete a group channel
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (required)
     * @param  string $api_token (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteAGroupChannelWithHttpInfo($associative_array)
    {
        $request = $this->deleteAGroupChannelRequest($associative_array);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteAGroupChannelAsync
     *
     * Delete a group channel
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (required)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAGroupChannelAsync($associative_array)
    {
        return $this->deleteAGroupChannelAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteAGroupChannelAsyncWithHttpInfo
     *
     * Delete a group channel
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (required)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAGroupChannelAsyncWithHttpInfo($associative_array)
    {
        $returnType = 'object';
        $request = $this->deleteAGroupChannelRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteAGroupChannel'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (required)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteAGroupChannelRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $channel_url = array_key_exists('channel_url', $associative_array) ? $associative_array['channel_url'] : null;
        $api_token = array_key_exists('api_token', $associative_array) ? $associative_array['api_token'] : null;

        // verify the required parameter 'channel_url' is set
        if ($channel_url === null || (is_array($channel_url) && count($channel_url) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel_url when calling deleteAGroupChannel'
            );
        }

        $resourcePath = '/v3/group_channels/{channel_url}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($api_token !== null) {
            $headerParams['api-token'] = ObjectSerializer::toHeaderValue($api_token);
        }

        // path params
        if ($channel_url !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_url' . '}',
                ObjectSerializer::toPathValue($channel_url),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAGroupChannel
     *
     * Get a group channel
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url channel_url (required)
     * @param  bool $show_delivery_receipt show_delivery_receipt (optional)
     * @param  bool $show_read_receipt show_read_receipt (optional)
     * @param  bool $show_member show_member (optional)
     * @param  string $member_active_mode Restricts the member list to members who are activated or deactivated in the channel. This parameter is only effective if the parameter show_member is true. Acceptable values are all, activated, and deactivated. (default: all) (optional)
     * @param  string $user_id user_id (optional)
     * @param  string $api_token api_token (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sendbird\Model\GetAGroupChannelResponse
     */
    public function getAGroupChannel($associative_array)
    {
        list($response) = $this->getAGroupChannelWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation getAGroupChannelWithHttpInfo
     *
     * Get a group channel
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (required)
     * @param  bool $show_delivery_receipt (optional)
     * @param  bool $show_read_receipt (optional)
     * @param  bool $show_member (optional)
     * @param  string $member_active_mode Restricts the member list to members who are activated or deactivated in the channel. This parameter is only effective if the parameter show_member is true. Acceptable values are all, activated, and deactivated. (default: all) (optional)
     * @param  string $user_id (optional)
     * @param  string $api_token (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sendbird\Model\GetAGroupChannelResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAGroupChannelWithHttpInfo($associative_array)
    {
        $request = $this->getAGroupChannelRequest($associative_array);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Sendbird\Model\GetAGroupChannelResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sendbird\Model\GetAGroupChannelResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sendbird\Model\GetAGroupChannelResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sendbird\Model\GetAGroupChannelResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sendbird\Model\GetAGroupChannelResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAGroupChannelAsync
     *
     * Get a group channel
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (required)
     * @param  bool $show_delivery_receipt (optional)
     * @param  bool $show_read_receipt (optional)
     * @param  bool $show_member (optional)
     * @param  string $member_active_mode Restricts the member list to members who are activated or deactivated in the channel. This parameter is only effective if the parameter show_member is true. Acceptable values are all, activated, and deactivated. (default: all) (optional)
     * @param  string $user_id (optional)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAGroupChannelAsync($associative_array)
    {
        return $this->getAGroupChannelAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAGroupChannelAsyncWithHttpInfo
     *
     * Get a group channel
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (required)
     * @param  bool $show_delivery_receipt (optional)
     * @param  bool $show_read_receipt (optional)
     * @param  bool $show_member (optional)
     * @param  string $member_active_mode Restricts the member list to members who are activated or deactivated in the channel. This parameter is only effective if the parameter show_member is true. Acceptable values are all, activated, and deactivated. (default: all) (optional)
     * @param  string $user_id (optional)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAGroupChannelAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\Sendbird\Model\GetAGroupChannelResponse';
        $request = $this->getAGroupChannelRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAGroupChannel'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (required)
     * @param  bool $show_delivery_receipt (optional)
     * @param  bool $show_read_receipt (optional)
     * @param  bool $show_member (optional)
     * @param  string $member_active_mode Restricts the member list to members who are activated or deactivated in the channel. This parameter is only effective if the parameter show_member is true. Acceptable values are all, activated, and deactivated. (default: all) (optional)
     * @param  string $user_id (optional)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAGroupChannelRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $channel_url = array_key_exists('channel_url', $associative_array) ? $associative_array['channel_url'] : null;
        $show_delivery_receipt = array_key_exists('show_delivery_receipt', $associative_array) ? $associative_array['show_delivery_receipt'] : null;
        $show_read_receipt = array_key_exists('show_read_receipt', $associative_array) ? $associative_array['show_read_receipt'] : null;
        $show_member = array_key_exists('show_member', $associative_array) ? $associative_array['show_member'] : null;
        $member_active_mode = array_key_exists('member_active_mode', $associative_array) ? $associative_array['member_active_mode'] : null;
        $user_id = array_key_exists('user_id', $associative_array) ? $associative_array['user_id'] : null;
        $api_token = array_key_exists('api_token', $associative_array) ? $associative_array['api_token'] : null;

        // verify the required parameter 'channel_url' is set
        if ($channel_url === null || (is_array($channel_url) && count($channel_url) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel_url when calling getAGroupChannel'
            );
        }

        $resourcePath = '/v3/group_channels/{channel_url}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $show_delivery_receipt,
            'show_delivery_receipt', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $show_read_receipt,
            'show_read_receipt', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $show_member,
            'show_member', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $member_active_mode,
            'member_active_mode', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user_id,
            'user_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($api_token !== null) {
            $headerParams['api-token'] = ObjectSerializer::toHeaderValue($api_token);
        }

        // path params
        if ($channel_url !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_url' . '}',
                ObjectSerializer::toPathValue($channel_url),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation hideAChannel
     *
     * Hide a channel
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token api_token (optional)
     * @param  \Sendbird\Model\HideAChannelRequest $hide_a_channel_request hide_a_channel_request (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function hideAChannel($associative_array)
    {
        list($response) = $this->hideAChannelWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation hideAChannelWithHttpInfo
     *
     * Hide a channel
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\HideAChannelRequest $hide_a_channel_request (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function hideAChannelWithHttpInfo($associative_array)
    {
        $request = $this->hideAChannelRequest($associative_array);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation hideAChannelAsync
     *
     * Hide a channel
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\HideAChannelRequest $hide_a_channel_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function hideAChannelAsync($associative_array)
    {
        return $this->hideAChannelAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation hideAChannelAsyncWithHttpInfo
     *
     * Hide a channel
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\HideAChannelRequest $hide_a_channel_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function hideAChannelAsyncWithHttpInfo($associative_array)
    {
        $returnType = 'object';
        $request = $this->hideAChannelRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'hideAChannel'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\HideAChannelRequest $hide_a_channel_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function hideAChannelRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $channel_url = array_key_exists('channel_url', $associative_array) ? $associative_array['channel_url'] : null;
        $api_token = array_key_exists('api_token', $associative_array) ? $associative_array['api_token'] : null;
        $hide_a_channel_request = array_key_exists('hide_a_channel_request', $associative_array) ? $associative_array['hide_a_channel_request'] : null;

        // verify the required parameter 'channel_url' is set
        if ($channel_url === null || (is_array($channel_url) && count($channel_url) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel_url when calling hideAChannel'
            );
        }

        $resourcePath = '/v3/group_channels/{channel_url}/hide';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($api_token !== null) {
            $headerParams['api-token'] = ObjectSerializer::toHeaderValue($api_token);
        }

        // path params
        if ($channel_url !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_url' . '}',
                ObjectSerializer::toPathValue($channel_url),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($hide_a_channel_request)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($hide_a_channel_request));
            } else {
                $httpBody = $hide_a_channel_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inviteAsMembers
     *
     * Invite as members
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token api_token (optional)
     * @param  \Sendbird\Model\InviteAsMembersRequest $invite_as_members_request invite_as_members_request (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sendbird\Model\InviteAsMembersResponse
     */
    public function inviteAsMembers($associative_array)
    {
        list($response) = $this->inviteAsMembersWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation inviteAsMembersWithHttpInfo
     *
     * Invite as members
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\InviteAsMembersRequest $invite_as_members_request (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sendbird\Model\InviteAsMembersResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function inviteAsMembersWithHttpInfo($associative_array)
    {
        $request = $this->inviteAsMembersRequest($associative_array);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Sendbird\Model\InviteAsMembersResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sendbird\Model\InviteAsMembersResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sendbird\Model\InviteAsMembersResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sendbird\Model\InviteAsMembersResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sendbird\Model\InviteAsMembersResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inviteAsMembersAsync
     *
     * Invite as members
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\InviteAsMembersRequest $invite_as_members_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inviteAsMembersAsync($associative_array)
    {
        return $this->inviteAsMembersAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inviteAsMembersAsyncWithHttpInfo
     *
     * Invite as members
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\InviteAsMembersRequest $invite_as_members_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inviteAsMembersAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\Sendbird\Model\InviteAsMembersResponse';
        $request = $this->inviteAsMembersRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inviteAsMembers'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\InviteAsMembersRequest $invite_as_members_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function inviteAsMembersRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $channel_url = array_key_exists('channel_url', $associative_array) ? $associative_array['channel_url'] : null;
        $api_token = array_key_exists('api_token', $associative_array) ? $associative_array['api_token'] : null;
        $invite_as_members_request = array_key_exists('invite_as_members_request', $associative_array) ? $associative_array['invite_as_members_request'] : null;

        // verify the required parameter 'channel_url' is set
        if ($channel_url === null || (is_array($channel_url) && count($channel_url) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel_url when calling inviteAsMembers'
            );
        }

        $resourcePath = '/v3/group_channels/{channel_url}/invite';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($api_token !== null) {
            $headerParams['api-token'] = ObjectSerializer::toHeaderValue($api_token);
        }

        // path params
        if ($channel_url !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_url' . '}',
                ObjectSerializer::toPathValue($channel_url),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($invite_as_members_request)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($invite_as_members_request));
            } else {
                $httpBody = $invite_as_members_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation joinAChannel
     *
     * Join a channel
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token api_token (optional)
     * @param  \Sendbird\Model\JoinAChannelRequest $join_a_channel_request join_a_channel_request (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sendbird\Model\SendbirdGroupChannelDetail
     */
    public function joinAChannel($associative_array)
    {
        list($response) = $this->joinAChannelWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation joinAChannelWithHttpInfo
     *
     * Join a channel
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\JoinAChannelRequest $join_a_channel_request (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sendbird\Model\SendbirdGroupChannelDetail, HTTP status code, HTTP response headers (array of strings)
     */
    public function joinAChannelWithHttpInfo($associative_array)
    {
        $request = $this->joinAChannelRequest($associative_array);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Sendbird\Model\SendbirdGroupChannelDetail' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sendbird\Model\SendbirdGroupChannelDetail' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sendbird\Model\SendbirdGroupChannelDetail', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sendbird\Model\SendbirdGroupChannelDetail';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sendbird\Model\SendbirdGroupChannelDetail',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation joinAChannelAsync
     *
     * Join a channel
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\JoinAChannelRequest $join_a_channel_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function joinAChannelAsync($associative_array)
    {
        return $this->joinAChannelAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation joinAChannelAsyncWithHttpInfo
     *
     * Join a channel
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\JoinAChannelRequest $join_a_channel_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function joinAChannelAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\Sendbird\Model\SendbirdGroupChannelDetail';
        $request = $this->joinAChannelRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'joinAChannel'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\JoinAChannelRequest $join_a_channel_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function joinAChannelRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $channel_url = array_key_exists('channel_url', $associative_array) ? $associative_array['channel_url'] : null;
        $api_token = array_key_exists('api_token', $associative_array) ? $associative_array['api_token'] : null;
        $join_a_channel_request = array_key_exists('join_a_channel_request', $associative_array) ? $associative_array['join_a_channel_request'] : null;

        // verify the required parameter 'channel_url' is set
        if ($channel_url === null || (is_array($channel_url) && count($channel_url) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel_url when calling joinAChannel'
            );
        }

        $resourcePath = '/v3/group_channels/{channel_url}/join';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($api_token !== null) {
            $headerParams['api-token'] = ObjectSerializer::toHeaderValue($api_token);
        }

        // path params
        if ($channel_url !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_url' . '}',
                ObjectSerializer::toPathValue($channel_url),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($join_a_channel_request)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($join_a_channel_request));
            } else {
                $httpBody = $join_a_channel_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation leaveAChannel
     *
     * Leave a channel
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url channel_url (required)
     * @param  string $api_token api_token (optional)
     * @param  \Sendbird\Model\LeaveAChannelRequest $leave_a_channel_request leave_a_channel_request (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function leaveAChannel($associative_array)
    {
        list($response) = $this->leaveAChannelWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation leaveAChannelWithHttpInfo
     *
     * Leave a channel
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\LeaveAChannelRequest $leave_a_channel_request (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function leaveAChannelWithHttpInfo($associative_array)
    {
        $request = $this->leaveAChannelRequest($associative_array);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation leaveAChannelAsync
     *
     * Leave a channel
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\LeaveAChannelRequest $leave_a_channel_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function leaveAChannelAsync($associative_array)
    {
        return $this->leaveAChannelAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation leaveAChannelAsyncWithHttpInfo
     *
     * Leave a channel
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\LeaveAChannelRequest $leave_a_channel_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function leaveAChannelAsyncWithHttpInfo($associative_array)
    {
        $returnType = 'object';
        $request = $this->leaveAChannelRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'leaveAChannel'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\LeaveAChannelRequest $leave_a_channel_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function leaveAChannelRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $channel_url = array_key_exists('channel_url', $associative_array) ? $associative_array['channel_url'] : null;
        $api_token = array_key_exists('api_token', $associative_array) ? $associative_array['api_token'] : null;
        $leave_a_channel_request = array_key_exists('leave_a_channel_request', $associative_array) ? $associative_array['leave_a_channel_request'] : null;

        // verify the required parameter 'channel_url' is set
        if ($channel_url === null || (is_array($channel_url) && count($channel_url) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel_url when calling leaveAChannel'
            );
        }

        $resourcePath = '/v3/group_channels/{channel_url}/leave';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($api_token !== null) {
            $headerParams['Api-Token'] = ObjectSerializer::toHeaderValue($api_token);
        }

        // path params
        if ($channel_url !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_url' . '}',
                ObjectSerializer::toPathValue($channel_url),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($leave_a_channel_request)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($leave_a_channel_request));
            } else {
                $httpBody = $leave_a_channel_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listChannels
     *
     * List channels
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $api_token api_token (required)
     * @param  string $token Specifies a page token that indicates the starting index of a chunk of results. If not specified, the index is set as 0. (optional)
     * @param  int $limit Specifies the number of results to return per page. Acceptable values are 1 to 100, inclusive. (Default: 10) (optional)
     * @param  string $distinct_mode distinct_mode (optional)
     * @param  string $public_mode public_mode (optional)
     * @param  string $super_mode super_mode (optional)
     * @param  int $created_after Restricts the search scope to only retrieve group channels which have been created after the specified time, in Unix milliseconds format. (optional)
     * @param  int $created_before Restricts the search scope to only retrieve group channels which have been created before the specified time, in Unix milliseconds format. (optional)
     * @param  bool $show_empty show_empty (optional)
     * @param  bool $show_member show_member (optional)
     * @param  bool $show_delivery_receipt show_delivery_receipt (optional)
     * @param  bool $show_read_receipt show_read_receipt (optional)
     * @param  bool $show_metadata show_metadata (optional)
     * @param  bool $show_frozen show_frozen (optional)
     * @param  string $order order (optional)
     * @param  string $metadata_order_key Specifies the key of an item in metadata. When a value of the order parameter is set to metadata_value_alphabetical, the results are alphabetically sorted by the value of the item specified by the key. (optional)
     * @param  string $custom_types Specifies a comma-separated string of one or more custom types to filter group channels. URL encoding each type is recommended. If not specified, all channels are returned, regardless of their custom type. (optional)
     * @param  string $custom_type_startswith Searches for group channels with the custom type which starts with the specified value. URL encoding the value is recommended. (optional)
     * @param  string $channel_urls Specifies a comma-separated string of one or more group channel URLs to restrict the search scope. URL encoding each channel URL is recommended. (optional)
     * @param  string $name Specifies one or more group channel names. (optional)
     * @param  string $name_contains Searches for group channels whose names contain the specified value. Note that this parameter is case-insensitive. URL encoding the value is recommended. (optional)
     * @param  string $name_startswith Searches for group channels whose names start with the specified value. Note that this parameter is case-insensitive. URL encoding the value is recommended. (optional)
     * @param  string $members_exactly_in Searches for group channels with all the specified users as members. The parameter value should consist of user IDs separated by commas.  Only user IDs that match those of existing users are used for channel search. URL encoding each ID is recommended. (optional)
     * @param  string $members_include_in Searches for group channels that include one or more users as members among the specified users. The value should consist of user IDs separated by commas or %2C. You can specify up to 60 user IDs.  Only user IDs that match those of existing users are used for channel search. URL encoding each ID is recommended. (optional)
     * @param  string $query_type Specifies a logical condition applied to the members_include_in parameter. Acceptable values are either AND or OR. For example, if you specify three members, A, B, and C, in members_include_in, the value of AND returns all channels that include every one of {A. B, C} as members. The value of OR returns channels that include {A}, plus those that include {B}, plus those that include {C}. (Default: AND) (optional)
     * @param  string $members_nickname Searches for group channels with members whose nicknames match the specified value. URL encoding the value is recommended. (optional)
     * @param  string $members_nickname_contains Searches for group channels with members whose nicknames contain the specified value. Note that this parameter is case-insensitive. URL encoding the value is recommended.  * We recommend using at least three characters for the parameter value for better search efficiency when you design and implement related features. If you would like to allow one or two characters for searching, use members_nickname instead to prevent performance issues. (optional)
     * @param  string $metadata_key Searches for group channels with metadata containing an item with the specified value as its key. To use this parameter, either the metadata_values parameter or the metadata_value_startswith parameter should be specified. (optional)
     * @param  string $metadata_values Searches for group channels with metadata containing an item with the key specified by the metadata_key parameter, and the value of that item matches one or more values specified by this parameter. The string should be specified with multiple values separated by commas. URL encoding each value is recommended. To use this parameter, the metadata_key parameter should be specified. (optional)
     * @param  string $metadata_value_startswith Searches for group channels with metadata containing an item with the key specified by the metadata_key parameter, and the values of that item that start with the specified value of this parameter. URL encoding the value is recommended. To use this parameter, the metadata_key parameter should be specified. (optional)
     * @param  string $metacounter_key Searches for group channels with metacounter containing an item with the specified value as its key. To use this parameter, either the metacounter_values parameter or one of the metacounter_value_gt, metacounter_value_gte, metacounter_value_lt, and metacounter_value_lte parameters should be specified. (optional)
     * @param  string $metacounter_values Searches for group channels with metacounter containing an item with the key specified by the metadata_key parameter, where the value of that item is equal to one or more values specified by this parameter. The string should be specified with multiple values separated by commas. To use this parameter, the metacounter_key parameter should be specified. (optional)
     * @param  string $metacounter_value_gt Searches for group channels with metacounter containing an item with the key specified by the metadata_key parameter, where the value of that item is greater than the value specified by this parameter. To use this parameter, the metacounter_key parameter should be specified. (optional)
     * @param  string $metacounter_value_gte Searches for group channels with metacounter containing an item with the key specified by the metadata_key parameter, where the value of that item is greater than or equal to the value specified by this parameter. To use this parameter, the metacounter_key parameter should be specified. (optional)
     * @param  string $metacounter_value_lt Searches for group channels with metacounter containing an item with the key specified by the metadata_key parameter, where the value of that item is lower than the value specified by this parameter. To use this parameter, the metacounter_key parameter should be specified. (optional)
     * @param  string $metacounter_value_lte Searches for group channels with metacounter containing an item with the key specified by the metadata_key parameter, where the value of that item is lower than or equal to the value specified by this parameter. To use this parameter, the metacounter_key parameter should be specified. (optional)
     * @param  bool $include_sorted_metaarray_in_last_message Determines whether to include the sorted_metaarray as one of the last_messages properties in the response. (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sendbird\Model\GroupChatListChannelsResponse
     */
    public function listChannels($associative_array)
    {
        list($response) = $this->listChannelsWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation listChannelsWithHttpInfo
     *
     * List channels
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $api_token (required)
     * @param  string $token Specifies a page token that indicates the starting index of a chunk of results. If not specified, the index is set as 0. (optional)
     * @param  int $limit Specifies the number of results to return per page. Acceptable values are 1 to 100, inclusive. (Default: 10) (optional)
     * @param  string $distinct_mode (optional)
     * @param  string $public_mode (optional)
     * @param  string $super_mode (optional)
     * @param  int $created_after Restricts the search scope to only retrieve group channels which have been created after the specified time, in Unix milliseconds format. (optional)
     * @param  int $created_before Restricts the search scope to only retrieve group channels which have been created before the specified time, in Unix milliseconds format. (optional)
     * @param  bool $show_empty (optional)
     * @param  bool $show_member (optional)
     * @param  bool $show_delivery_receipt (optional)
     * @param  bool $show_read_receipt (optional)
     * @param  bool $show_metadata (optional)
     * @param  bool $show_frozen (optional)
     * @param  string $order (optional)
     * @param  string $metadata_order_key Specifies the key of an item in metadata. When a value of the order parameter is set to metadata_value_alphabetical, the results are alphabetically sorted by the value of the item specified by the key. (optional)
     * @param  string $custom_types Specifies a comma-separated string of one or more custom types to filter group channels. URL encoding each type is recommended. If not specified, all channels are returned, regardless of their custom type. (optional)
     * @param  string $custom_type_startswith Searches for group channels with the custom type which starts with the specified value. URL encoding the value is recommended. (optional)
     * @param  string $channel_urls Specifies a comma-separated string of one or more group channel URLs to restrict the search scope. URL encoding each channel URL is recommended. (optional)
     * @param  string $name Specifies one or more group channel names. (optional)
     * @param  string $name_contains Searches for group channels whose names contain the specified value. Note that this parameter is case-insensitive. URL encoding the value is recommended. (optional)
     * @param  string $name_startswith Searches for group channels whose names start with the specified value. Note that this parameter is case-insensitive. URL encoding the value is recommended. (optional)
     * @param  string $members_exactly_in Searches for group channels with all the specified users as members. The parameter value should consist of user IDs separated by commas.  Only user IDs that match those of existing users are used for channel search. URL encoding each ID is recommended. (optional)
     * @param  string $members_include_in Searches for group channels that include one or more users as members among the specified users. The value should consist of user IDs separated by commas or %2C. You can specify up to 60 user IDs.  Only user IDs that match those of existing users are used for channel search. URL encoding each ID is recommended. (optional)
     * @param  string $query_type Specifies a logical condition applied to the members_include_in parameter. Acceptable values are either AND or OR. For example, if you specify three members, A, B, and C, in members_include_in, the value of AND returns all channels that include every one of {A. B, C} as members. The value of OR returns channels that include {A}, plus those that include {B}, plus those that include {C}. (Default: AND) (optional)
     * @param  string $members_nickname Searches for group channels with members whose nicknames match the specified value. URL encoding the value is recommended. (optional)
     * @param  string $members_nickname_contains Searches for group channels with members whose nicknames contain the specified value. Note that this parameter is case-insensitive. URL encoding the value is recommended.  * We recommend using at least three characters for the parameter value for better search efficiency when you design and implement related features. If you would like to allow one or two characters for searching, use members_nickname instead to prevent performance issues. (optional)
     * @param  string $metadata_key Searches for group channels with metadata containing an item with the specified value as its key. To use this parameter, either the metadata_values parameter or the metadata_value_startswith parameter should be specified. (optional)
     * @param  string $metadata_values Searches for group channels with metadata containing an item with the key specified by the metadata_key parameter, and the value of that item matches one or more values specified by this parameter. The string should be specified with multiple values separated by commas. URL encoding each value is recommended. To use this parameter, the metadata_key parameter should be specified. (optional)
     * @param  string $metadata_value_startswith Searches for group channels with metadata containing an item with the key specified by the metadata_key parameter, and the values of that item that start with the specified value of this parameter. URL encoding the value is recommended. To use this parameter, the metadata_key parameter should be specified. (optional)
     * @param  string $metacounter_key Searches for group channels with metacounter containing an item with the specified value as its key. To use this parameter, either the metacounter_values parameter or one of the metacounter_value_gt, metacounter_value_gte, metacounter_value_lt, and metacounter_value_lte parameters should be specified. (optional)
     * @param  string $metacounter_values Searches for group channels with metacounter containing an item with the key specified by the metadata_key parameter, where the value of that item is equal to one or more values specified by this parameter. The string should be specified with multiple values separated by commas. To use this parameter, the metacounter_key parameter should be specified. (optional)
     * @param  string $metacounter_value_gt Searches for group channels with metacounter containing an item with the key specified by the metadata_key parameter, where the value of that item is greater than the value specified by this parameter. To use this parameter, the metacounter_key parameter should be specified. (optional)
     * @param  string $metacounter_value_gte Searches for group channels with metacounter containing an item with the key specified by the metadata_key parameter, where the value of that item is greater than or equal to the value specified by this parameter. To use this parameter, the metacounter_key parameter should be specified. (optional)
     * @param  string $metacounter_value_lt Searches for group channels with metacounter containing an item with the key specified by the metadata_key parameter, where the value of that item is lower than the value specified by this parameter. To use this parameter, the metacounter_key parameter should be specified. (optional)
     * @param  string $metacounter_value_lte Searches for group channels with metacounter containing an item with the key specified by the metadata_key parameter, where the value of that item is lower than or equal to the value specified by this parameter. To use this parameter, the metacounter_key parameter should be specified. (optional)
     * @param  bool $include_sorted_metaarray_in_last_message Determines whether to include the sorted_metaarray as one of the last_messages properties in the response. (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sendbird\Model\GroupChatListChannelsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listChannelsWithHttpInfo($associative_array)
    {
        $request = $this->listChannelsRequest($associative_array);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Sendbird\Model\GroupChatListChannelsResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sendbird\Model\GroupChatListChannelsResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sendbird\Model\GroupChatListChannelsResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sendbird\Model\GroupChatListChannelsResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sendbird\Model\GroupChatListChannelsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listChannelsAsync
     *
     * List channels
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $api_token (required)
     * @param  string $token Specifies a page token that indicates the starting index of a chunk of results. If not specified, the index is set as 0. (optional)
     * @param  int $limit Specifies the number of results to return per page. Acceptable values are 1 to 100, inclusive. (Default: 10) (optional)
     * @param  string $distinct_mode (optional)
     * @param  string $public_mode (optional)
     * @param  string $super_mode (optional)
     * @param  int $created_after Restricts the search scope to only retrieve group channels which have been created after the specified time, in Unix milliseconds format. (optional)
     * @param  int $created_before Restricts the search scope to only retrieve group channels which have been created before the specified time, in Unix milliseconds format. (optional)
     * @param  bool $show_empty (optional)
     * @param  bool $show_member (optional)
     * @param  bool $show_delivery_receipt (optional)
     * @param  bool $show_read_receipt (optional)
     * @param  bool $show_metadata (optional)
     * @param  bool $show_frozen (optional)
     * @param  string $order (optional)
     * @param  string $metadata_order_key Specifies the key of an item in metadata. When a value of the order parameter is set to metadata_value_alphabetical, the results are alphabetically sorted by the value of the item specified by the key. (optional)
     * @param  string $custom_types Specifies a comma-separated string of one or more custom types to filter group channels. URL encoding each type is recommended. If not specified, all channels are returned, regardless of their custom type. (optional)
     * @param  string $custom_type_startswith Searches for group channels with the custom type which starts with the specified value. URL encoding the value is recommended. (optional)
     * @param  string $channel_urls Specifies a comma-separated string of one or more group channel URLs to restrict the search scope. URL encoding each channel URL is recommended. (optional)
     * @param  string $name Specifies one or more group channel names. (optional)
     * @param  string $name_contains Searches for group channels whose names contain the specified value. Note that this parameter is case-insensitive. URL encoding the value is recommended. (optional)
     * @param  string $name_startswith Searches for group channels whose names start with the specified value. Note that this parameter is case-insensitive. URL encoding the value is recommended. (optional)
     * @param  string $members_exactly_in Searches for group channels with all the specified users as members. The parameter value should consist of user IDs separated by commas.  Only user IDs that match those of existing users are used for channel search. URL encoding each ID is recommended. (optional)
     * @param  string $members_include_in Searches for group channels that include one or more users as members among the specified users. The value should consist of user IDs separated by commas or %2C. You can specify up to 60 user IDs.  Only user IDs that match those of existing users are used for channel search. URL encoding each ID is recommended. (optional)
     * @param  string $query_type Specifies a logical condition applied to the members_include_in parameter. Acceptable values are either AND or OR. For example, if you specify three members, A, B, and C, in members_include_in, the value of AND returns all channels that include every one of {A. B, C} as members. The value of OR returns channels that include {A}, plus those that include {B}, plus those that include {C}. (Default: AND) (optional)
     * @param  string $members_nickname Searches for group channels with members whose nicknames match the specified value. URL encoding the value is recommended. (optional)
     * @param  string $members_nickname_contains Searches for group channels with members whose nicknames contain the specified value. Note that this parameter is case-insensitive. URL encoding the value is recommended.  * We recommend using at least three characters for the parameter value for better search efficiency when you design and implement related features. If you would like to allow one or two characters for searching, use members_nickname instead to prevent performance issues. (optional)
     * @param  string $metadata_key Searches for group channels with metadata containing an item with the specified value as its key. To use this parameter, either the metadata_values parameter or the metadata_value_startswith parameter should be specified. (optional)
     * @param  string $metadata_values Searches for group channels with metadata containing an item with the key specified by the metadata_key parameter, and the value of that item matches one or more values specified by this parameter. The string should be specified with multiple values separated by commas. URL encoding each value is recommended. To use this parameter, the metadata_key parameter should be specified. (optional)
     * @param  string $metadata_value_startswith Searches for group channels with metadata containing an item with the key specified by the metadata_key parameter, and the values of that item that start with the specified value of this parameter. URL encoding the value is recommended. To use this parameter, the metadata_key parameter should be specified. (optional)
     * @param  string $metacounter_key Searches for group channels with metacounter containing an item with the specified value as its key. To use this parameter, either the metacounter_values parameter or one of the metacounter_value_gt, metacounter_value_gte, metacounter_value_lt, and metacounter_value_lte parameters should be specified. (optional)
     * @param  string $metacounter_values Searches for group channels with metacounter containing an item with the key specified by the metadata_key parameter, where the value of that item is equal to one or more values specified by this parameter. The string should be specified with multiple values separated by commas. To use this parameter, the metacounter_key parameter should be specified. (optional)
     * @param  string $metacounter_value_gt Searches for group channels with metacounter containing an item with the key specified by the metadata_key parameter, where the value of that item is greater than the value specified by this parameter. To use this parameter, the metacounter_key parameter should be specified. (optional)
     * @param  string $metacounter_value_gte Searches for group channels with metacounter containing an item with the key specified by the metadata_key parameter, where the value of that item is greater than or equal to the value specified by this parameter. To use this parameter, the metacounter_key parameter should be specified. (optional)
     * @param  string $metacounter_value_lt Searches for group channels with metacounter containing an item with the key specified by the metadata_key parameter, where the value of that item is lower than the value specified by this parameter. To use this parameter, the metacounter_key parameter should be specified. (optional)
     * @param  string $metacounter_value_lte Searches for group channels with metacounter containing an item with the key specified by the metadata_key parameter, where the value of that item is lower than or equal to the value specified by this parameter. To use this parameter, the metacounter_key parameter should be specified. (optional)
     * @param  bool $include_sorted_metaarray_in_last_message Determines whether to include the sorted_metaarray as one of the last_messages properties in the response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listChannelsAsync($associative_array)
    {
        return $this->listChannelsAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listChannelsAsyncWithHttpInfo
     *
     * List channels
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $api_token (required)
     * @param  string $token Specifies a page token that indicates the starting index of a chunk of results. If not specified, the index is set as 0. (optional)
     * @param  int $limit Specifies the number of results to return per page. Acceptable values are 1 to 100, inclusive. (Default: 10) (optional)
     * @param  string $distinct_mode (optional)
     * @param  string $public_mode (optional)
     * @param  string $super_mode (optional)
     * @param  int $created_after Restricts the search scope to only retrieve group channels which have been created after the specified time, in Unix milliseconds format. (optional)
     * @param  int $created_before Restricts the search scope to only retrieve group channels which have been created before the specified time, in Unix milliseconds format. (optional)
     * @param  bool $show_empty (optional)
     * @param  bool $show_member (optional)
     * @param  bool $show_delivery_receipt (optional)
     * @param  bool $show_read_receipt (optional)
     * @param  bool $show_metadata (optional)
     * @param  bool $show_frozen (optional)
     * @param  string $order (optional)
     * @param  string $metadata_order_key Specifies the key of an item in metadata. When a value of the order parameter is set to metadata_value_alphabetical, the results are alphabetically sorted by the value of the item specified by the key. (optional)
     * @param  string $custom_types Specifies a comma-separated string of one or more custom types to filter group channels. URL encoding each type is recommended. If not specified, all channels are returned, regardless of their custom type. (optional)
     * @param  string $custom_type_startswith Searches for group channels with the custom type which starts with the specified value. URL encoding the value is recommended. (optional)
     * @param  string $channel_urls Specifies a comma-separated string of one or more group channel URLs to restrict the search scope. URL encoding each channel URL is recommended. (optional)
     * @param  string $name Specifies one or more group channel names. (optional)
     * @param  string $name_contains Searches for group channels whose names contain the specified value. Note that this parameter is case-insensitive. URL encoding the value is recommended. (optional)
     * @param  string $name_startswith Searches for group channels whose names start with the specified value. Note that this parameter is case-insensitive. URL encoding the value is recommended. (optional)
     * @param  string $members_exactly_in Searches for group channels with all the specified users as members. The parameter value should consist of user IDs separated by commas.  Only user IDs that match those of existing users are used for channel search. URL encoding each ID is recommended. (optional)
     * @param  string $members_include_in Searches for group channels that include one or more users as members among the specified users. The value should consist of user IDs separated by commas or %2C. You can specify up to 60 user IDs.  Only user IDs that match those of existing users are used for channel search. URL encoding each ID is recommended. (optional)
     * @param  string $query_type Specifies a logical condition applied to the members_include_in parameter. Acceptable values are either AND or OR. For example, if you specify three members, A, B, and C, in members_include_in, the value of AND returns all channels that include every one of {A. B, C} as members. The value of OR returns channels that include {A}, plus those that include {B}, plus those that include {C}. (Default: AND) (optional)
     * @param  string $members_nickname Searches for group channels with members whose nicknames match the specified value. URL encoding the value is recommended. (optional)
     * @param  string $members_nickname_contains Searches for group channels with members whose nicknames contain the specified value. Note that this parameter is case-insensitive. URL encoding the value is recommended.  * We recommend using at least three characters for the parameter value for better search efficiency when you design and implement related features. If you would like to allow one or two characters for searching, use members_nickname instead to prevent performance issues. (optional)
     * @param  string $metadata_key Searches for group channels with metadata containing an item with the specified value as its key. To use this parameter, either the metadata_values parameter or the metadata_value_startswith parameter should be specified. (optional)
     * @param  string $metadata_values Searches for group channels with metadata containing an item with the key specified by the metadata_key parameter, and the value of that item matches one or more values specified by this parameter. The string should be specified with multiple values separated by commas. URL encoding each value is recommended. To use this parameter, the metadata_key parameter should be specified. (optional)
     * @param  string $metadata_value_startswith Searches for group channels with metadata containing an item with the key specified by the metadata_key parameter, and the values of that item that start with the specified value of this parameter. URL encoding the value is recommended. To use this parameter, the metadata_key parameter should be specified. (optional)
     * @param  string $metacounter_key Searches for group channels with metacounter containing an item with the specified value as its key. To use this parameter, either the metacounter_values parameter or one of the metacounter_value_gt, metacounter_value_gte, metacounter_value_lt, and metacounter_value_lte parameters should be specified. (optional)
     * @param  string $metacounter_values Searches for group channels with metacounter containing an item with the key specified by the metadata_key parameter, where the value of that item is equal to one or more values specified by this parameter. The string should be specified with multiple values separated by commas. To use this parameter, the metacounter_key parameter should be specified. (optional)
     * @param  string $metacounter_value_gt Searches for group channels with metacounter containing an item with the key specified by the metadata_key parameter, where the value of that item is greater than the value specified by this parameter. To use this parameter, the metacounter_key parameter should be specified. (optional)
     * @param  string $metacounter_value_gte Searches for group channels with metacounter containing an item with the key specified by the metadata_key parameter, where the value of that item is greater than or equal to the value specified by this parameter. To use this parameter, the metacounter_key parameter should be specified. (optional)
     * @param  string $metacounter_value_lt Searches for group channels with metacounter containing an item with the key specified by the metadata_key parameter, where the value of that item is lower than the value specified by this parameter. To use this parameter, the metacounter_key parameter should be specified. (optional)
     * @param  string $metacounter_value_lte Searches for group channels with metacounter containing an item with the key specified by the metadata_key parameter, where the value of that item is lower than or equal to the value specified by this parameter. To use this parameter, the metacounter_key parameter should be specified. (optional)
     * @param  bool $include_sorted_metaarray_in_last_message Determines whether to include the sorted_metaarray as one of the last_messages properties in the response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listChannelsAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\Sendbird\Model\GroupChatListChannelsResponse';
        $request = $this->listChannelsRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listChannels'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $api_token (required)
     * @param  string $token Specifies a page token that indicates the starting index of a chunk of results. If not specified, the index is set as 0. (optional)
     * @param  int $limit Specifies the number of results to return per page. Acceptable values are 1 to 100, inclusive. (Default: 10) (optional)
     * @param  string $distinct_mode (optional)
     * @param  string $public_mode (optional)
     * @param  string $super_mode (optional)
     * @param  int $created_after Restricts the search scope to only retrieve group channels which have been created after the specified time, in Unix milliseconds format. (optional)
     * @param  int $created_before Restricts the search scope to only retrieve group channels which have been created before the specified time, in Unix milliseconds format. (optional)
     * @param  bool $show_empty (optional)
     * @param  bool $show_member (optional)
     * @param  bool $show_delivery_receipt (optional)
     * @param  bool $show_read_receipt (optional)
     * @param  bool $show_metadata (optional)
     * @param  bool $show_frozen (optional)
     * @param  string $order (optional)
     * @param  string $metadata_order_key Specifies the key of an item in metadata. When a value of the order parameter is set to metadata_value_alphabetical, the results are alphabetically sorted by the value of the item specified by the key. (optional)
     * @param  string $custom_types Specifies a comma-separated string of one or more custom types to filter group channels. URL encoding each type is recommended. If not specified, all channels are returned, regardless of their custom type. (optional)
     * @param  string $custom_type_startswith Searches for group channels with the custom type which starts with the specified value. URL encoding the value is recommended. (optional)
     * @param  string $channel_urls Specifies a comma-separated string of one or more group channel URLs to restrict the search scope. URL encoding each channel URL is recommended. (optional)
     * @param  string $name Specifies one or more group channel names. (optional)
     * @param  string $name_contains Searches for group channels whose names contain the specified value. Note that this parameter is case-insensitive. URL encoding the value is recommended. (optional)
     * @param  string $name_startswith Searches for group channels whose names start with the specified value. Note that this parameter is case-insensitive. URL encoding the value is recommended. (optional)
     * @param  string $members_exactly_in Searches for group channels with all the specified users as members. The parameter value should consist of user IDs separated by commas.  Only user IDs that match those of existing users are used for channel search. URL encoding each ID is recommended. (optional)
     * @param  string $members_include_in Searches for group channels that include one or more users as members among the specified users. The value should consist of user IDs separated by commas or %2C. You can specify up to 60 user IDs.  Only user IDs that match those of existing users are used for channel search. URL encoding each ID is recommended. (optional)
     * @param  string $query_type Specifies a logical condition applied to the members_include_in parameter. Acceptable values are either AND or OR. For example, if you specify three members, A, B, and C, in members_include_in, the value of AND returns all channels that include every one of {A. B, C} as members. The value of OR returns channels that include {A}, plus those that include {B}, plus those that include {C}. (Default: AND) (optional)
     * @param  string $members_nickname Searches for group channels with members whose nicknames match the specified value. URL encoding the value is recommended. (optional)
     * @param  string $members_nickname_contains Searches for group channels with members whose nicknames contain the specified value. Note that this parameter is case-insensitive. URL encoding the value is recommended.  * We recommend using at least three characters for the parameter value for better search efficiency when you design and implement related features. If you would like to allow one or two characters for searching, use members_nickname instead to prevent performance issues. (optional)
     * @param  string $metadata_key Searches for group channels with metadata containing an item with the specified value as its key. To use this parameter, either the metadata_values parameter or the metadata_value_startswith parameter should be specified. (optional)
     * @param  string $metadata_values Searches for group channels with metadata containing an item with the key specified by the metadata_key parameter, and the value of that item matches one or more values specified by this parameter. The string should be specified with multiple values separated by commas. URL encoding each value is recommended. To use this parameter, the metadata_key parameter should be specified. (optional)
     * @param  string $metadata_value_startswith Searches for group channels with metadata containing an item with the key specified by the metadata_key parameter, and the values of that item that start with the specified value of this parameter. URL encoding the value is recommended. To use this parameter, the metadata_key parameter should be specified. (optional)
     * @param  string $metacounter_key Searches for group channels with metacounter containing an item with the specified value as its key. To use this parameter, either the metacounter_values parameter or one of the metacounter_value_gt, metacounter_value_gte, metacounter_value_lt, and metacounter_value_lte parameters should be specified. (optional)
     * @param  string $metacounter_values Searches for group channels with metacounter containing an item with the key specified by the metadata_key parameter, where the value of that item is equal to one or more values specified by this parameter. The string should be specified with multiple values separated by commas. To use this parameter, the metacounter_key parameter should be specified. (optional)
     * @param  string $metacounter_value_gt Searches for group channels with metacounter containing an item with the key specified by the metadata_key parameter, where the value of that item is greater than the value specified by this parameter. To use this parameter, the metacounter_key parameter should be specified. (optional)
     * @param  string $metacounter_value_gte Searches for group channels with metacounter containing an item with the key specified by the metadata_key parameter, where the value of that item is greater than or equal to the value specified by this parameter. To use this parameter, the metacounter_key parameter should be specified. (optional)
     * @param  string $metacounter_value_lt Searches for group channels with metacounter containing an item with the key specified by the metadata_key parameter, where the value of that item is lower than the value specified by this parameter. To use this parameter, the metacounter_key parameter should be specified. (optional)
     * @param  string $metacounter_value_lte Searches for group channels with metacounter containing an item with the key specified by the metadata_key parameter, where the value of that item is lower than or equal to the value specified by this parameter. To use this parameter, the metacounter_key parameter should be specified. (optional)
     * @param  bool $include_sorted_metaarray_in_last_message Determines whether to include the sorted_metaarray as one of the last_messages properties in the response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listChannelsRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $api_token = array_key_exists('api_token', $associative_array) ? $associative_array['api_token'] : null;
        $token = array_key_exists('token', $associative_array) ? $associative_array['token'] : null;
        $limit = array_key_exists('limit', $associative_array) ? $associative_array['limit'] : null;
        $distinct_mode = array_key_exists('distinct_mode', $associative_array) ? $associative_array['distinct_mode'] : null;
        $public_mode = array_key_exists('public_mode', $associative_array) ? $associative_array['public_mode'] : null;
        $super_mode = array_key_exists('super_mode', $associative_array) ? $associative_array['super_mode'] : null;
        $created_after = array_key_exists('created_after', $associative_array) ? $associative_array['created_after'] : null;
        $created_before = array_key_exists('created_before', $associative_array) ? $associative_array['created_before'] : null;
        $show_empty = array_key_exists('show_empty', $associative_array) ? $associative_array['show_empty'] : null;
        $show_member = array_key_exists('show_member', $associative_array) ? $associative_array['show_member'] : null;
        $show_delivery_receipt = array_key_exists('show_delivery_receipt', $associative_array) ? $associative_array['show_delivery_receipt'] : null;
        $show_read_receipt = array_key_exists('show_read_receipt', $associative_array) ? $associative_array['show_read_receipt'] : null;
        $show_metadata = array_key_exists('show_metadata', $associative_array) ? $associative_array['show_metadata'] : null;
        $show_frozen = array_key_exists('show_frozen', $associative_array) ? $associative_array['show_frozen'] : null;
        $order = array_key_exists('order', $associative_array) ? $associative_array['order'] : null;
        $metadata_order_key = array_key_exists('metadata_order_key', $associative_array) ? $associative_array['metadata_order_key'] : null;
        $custom_types = array_key_exists('custom_types', $associative_array) ? $associative_array['custom_types'] : null;
        $custom_type_startswith = array_key_exists('custom_type_startswith', $associative_array) ? $associative_array['custom_type_startswith'] : null;
        $channel_urls = array_key_exists('channel_urls', $associative_array) ? $associative_array['channel_urls'] : null;
        $name = array_key_exists('name', $associative_array) ? $associative_array['name'] : null;
        $name_contains = array_key_exists('name_contains', $associative_array) ? $associative_array['name_contains'] : null;
        $name_startswith = array_key_exists('name_startswith', $associative_array) ? $associative_array['name_startswith'] : null;
        $members_exactly_in = array_key_exists('members_exactly_in', $associative_array) ? $associative_array['members_exactly_in'] : null;
        $members_include_in = array_key_exists('members_include_in', $associative_array) ? $associative_array['members_include_in'] : null;
        $query_type = array_key_exists('query_type', $associative_array) ? $associative_array['query_type'] : null;
        $members_nickname = array_key_exists('members_nickname', $associative_array) ? $associative_array['members_nickname'] : null;
        $members_nickname_contains = array_key_exists('members_nickname_contains', $associative_array) ? $associative_array['members_nickname_contains'] : null;
        $metadata_key = array_key_exists('metadata_key', $associative_array) ? $associative_array['metadata_key'] : null;
        $metadata_values = array_key_exists('metadata_values', $associative_array) ? $associative_array['metadata_values'] : null;
        $metadata_value_startswith = array_key_exists('metadata_value_startswith', $associative_array) ? $associative_array['metadata_value_startswith'] : null;
        $metacounter_key = array_key_exists('metacounter_key', $associative_array) ? $associative_array['metacounter_key'] : null;
        $metacounter_values = array_key_exists('metacounter_values', $associative_array) ? $associative_array['metacounter_values'] : null;
        $metacounter_value_gt = array_key_exists('metacounter_value_gt', $associative_array) ? $associative_array['metacounter_value_gt'] : null;
        $metacounter_value_gte = array_key_exists('metacounter_value_gte', $associative_array) ? $associative_array['metacounter_value_gte'] : null;
        $metacounter_value_lt = array_key_exists('metacounter_value_lt', $associative_array) ? $associative_array['metacounter_value_lt'] : null;
        $metacounter_value_lte = array_key_exists('metacounter_value_lte', $associative_array) ? $associative_array['metacounter_value_lte'] : null;
        $include_sorted_metaarray_in_last_message = array_key_exists('include_sorted_metaarray_in_last_message', $associative_array) ? $associative_array['include_sorted_metaarray_in_last_message'] : null;

        // verify the required parameter 'api_token' is set
        if ($api_token === null || (is_array($api_token) && count($api_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $api_token when calling listChannels'
            );
        }

        $resourcePath = '/v3/group_channels';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $token,
            'token', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $distinct_mode,
            'distinct_mode', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $public_mode,
            'public_mode', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $super_mode,
            'super_mode', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_after,
            'created_after', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_before,
            'created_before', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $show_empty,
            'show_empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $show_member,
            'show_member', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $show_delivery_receipt,
            'show_delivery_receipt', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $show_read_receipt,
            'show_read_receipt', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $show_metadata,
            'show_metadata', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $show_frozen,
            'show_frozen', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $order,
            'order', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $metadata_order_key,
            'metadata_order_key', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $custom_types,
            'custom_types', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $custom_type_startswith,
            'custom_type_startswith', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $channel_urls,
            'channel_urls', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name_contains,
            'name_contains', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name_startswith,
            'name_startswith', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $members_exactly_in,
            'members_exactly_in', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $members_include_in,
            'members_include_in', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $query_type,
            'query_type', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $members_nickname,
            'members_nickname', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $members_nickname_contains,
            'members_nickname_contains', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $metadata_key,
            'metadata_key', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $metadata_values,
            'metadata_values', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $metadata_value_startswith,
            'metadata_value_startswith', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $metacounter_key,
            'metacounter_key', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $metacounter_values,
            'metacounter_values', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $metacounter_value_gt,
            'metacounter_value_gt', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $metacounter_value_gte,
            'metacounter_value_gte', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $metacounter_value_lt,
            'metacounter_value_lt', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $metacounter_value_lte,
            'metacounter_value_lte', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_sorted_metaarray_in_last_message,
            'include_sorted_metaarray_in_last_message', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($api_token !== null) {
            $headerParams['api-token'] = ObjectSerializer::toHeaderValue($api_token);
        }



        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listMembers
     *
     * List members
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (Required) (required)
     * @param  string $token token (optional)
     * @param  int $limit Specifies the number of results to return per page. Acceptable values are 1 to 100, inclusive. (Default: 10) (optional)
     * @param  string $user_id Specifies the unique ID of a user. If &#x60;user_id&#x60; is provided, the response will include two additional boolean properties about each user in the members list. - &#x60;is_blocking_me&#x60;: Indicates whether the listed user is blocking the user specified in the user_id parameter. - &#x60;is_blocked_by_me&#x60;: Indicates whether the listed user is blocked by the user specified in the user_id parameter. (optional)
     * @param  bool $show_delivery_receipt show_delivery_receipt (optional)
     * @param  bool $show_read_receipt show_read_receipt (optional)
     * @param  bool $show_member_is_muted show_member_is_muted (optional)
     * @param  string $order Specifies the method to sort a list of results. Acceptable values are the following: - &#x60;member_nickname_alphabetical&#x60; (default): sorts by the member nicknames in alphabetical order. - &#x60;operator_then_member_alphabetical&#x60;: sorts by the operational role and member nickname in alphabetical order where channel operators are listed before channel members. (optional)
     * @param  string $operator_filter Restricts the search scope to only retrieve operators or non-operator members of the channel. Acceptable values are the following: - &#x60;all&#x60; (default): no filter is applied to the list. - &#x60;operator&#x60;: only channel operators are retrieved. - &#x60;nonoperator&#x60;: all channel members, except channel operators, are retrieved. (optional)
     * @param  string $member_state_filter Restricts the search scope to retrieve members based on if they have accepted an invitation or if they were invited by a friend. Acceptable values are &#x60;invited_only&#x60;, &#x60;joined_only&#x60;, &#x60;invited_by_friend&#x60;, &#x60;invited_by_non_friend&#x60;, and &#x60;all&#x60;. (Default: &#x60;all&#x60;) (optional)
     * @param  string $muted_member_filter Restricts the search scope to retrieve members who are muted or unmuted in the channel. Acceptable values are &#x60;all&#x60;, &#x60;muted&#x60;, and &#x60;unmuted&#x60;. (Default: &#x60;all&#x60;) (optional)
     * @param  string $member_active_mode_filter Restricts the search scope to retrieve members who are activated or deactivated in the channel. Acceptable values are &#x60;all&#x60;, &#x60;activated&#x60;, and &#x60;deactivated&#x60;. (default: &#x60;activated&#x60;) (optional)
     * @param  string $nickname_startswith Searches for members whose nicknames start with the specified value. Urlencoding the value is recommended. (optional)
     * @param  bool $include_push_preference Determines whether to include information about the push preference of each member, such as &#x60;push_enabled&#x60;, &#x60;push_trigger_option&#x60;, and &#x60;do_not_disturb&#x60;. (Default: &#x60;false&#x60;) (optional)
     * @param  string $api_token api_token (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sendbird\Model\GroupChannelListMembersResponse
     */
    public function listMembers($associative_array)
    {
        list($response) = $this->listMembersWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation listMembersWithHttpInfo
     *
     * List members
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (Required) (required)
     * @param  string $token (optional)
     * @param  int $limit Specifies the number of results to return per page. Acceptable values are 1 to 100, inclusive. (Default: 10) (optional)
     * @param  string $user_id Specifies the unique ID of a user. If &#x60;user_id&#x60; is provided, the response will include two additional boolean properties about each user in the members list. - &#x60;is_blocking_me&#x60;: Indicates whether the listed user is blocking the user specified in the user_id parameter. - &#x60;is_blocked_by_me&#x60;: Indicates whether the listed user is blocked by the user specified in the user_id parameter. (optional)
     * @param  bool $show_delivery_receipt (optional)
     * @param  bool $show_read_receipt (optional)
     * @param  bool $show_member_is_muted (optional)
     * @param  string $order Specifies the method to sort a list of results. Acceptable values are the following: - &#x60;member_nickname_alphabetical&#x60; (default): sorts by the member nicknames in alphabetical order. - &#x60;operator_then_member_alphabetical&#x60;: sorts by the operational role and member nickname in alphabetical order where channel operators are listed before channel members. (optional)
     * @param  string $operator_filter Restricts the search scope to only retrieve operators or non-operator members of the channel. Acceptable values are the following: - &#x60;all&#x60; (default): no filter is applied to the list. - &#x60;operator&#x60;: only channel operators are retrieved. - &#x60;nonoperator&#x60;: all channel members, except channel operators, are retrieved. (optional)
     * @param  string $member_state_filter Restricts the search scope to retrieve members based on if they have accepted an invitation or if they were invited by a friend. Acceptable values are &#x60;invited_only&#x60;, &#x60;joined_only&#x60;, &#x60;invited_by_friend&#x60;, &#x60;invited_by_non_friend&#x60;, and &#x60;all&#x60;. (Default: &#x60;all&#x60;) (optional)
     * @param  string $muted_member_filter Restricts the search scope to retrieve members who are muted or unmuted in the channel. Acceptable values are &#x60;all&#x60;, &#x60;muted&#x60;, and &#x60;unmuted&#x60;. (Default: &#x60;all&#x60;) (optional)
     * @param  string $member_active_mode_filter Restricts the search scope to retrieve members who are activated or deactivated in the channel. Acceptable values are &#x60;all&#x60;, &#x60;activated&#x60;, and &#x60;deactivated&#x60;. (default: &#x60;activated&#x60;) (optional)
     * @param  string $nickname_startswith Searches for members whose nicknames start with the specified value. Urlencoding the value is recommended. (optional)
     * @param  bool $include_push_preference Determines whether to include information about the push preference of each member, such as &#x60;push_enabled&#x60;, &#x60;push_trigger_option&#x60;, and &#x60;do_not_disturb&#x60;. (Default: &#x60;false&#x60;) (optional)
     * @param  string $api_token (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sendbird\Model\GroupChannelListMembersResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listMembersWithHttpInfo($associative_array)
    {
        $request = $this->listMembersRequest($associative_array);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Sendbird\Model\GroupChannelListMembersResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sendbird\Model\GroupChannelListMembersResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sendbird\Model\GroupChannelListMembersResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sendbird\Model\GroupChannelListMembersResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sendbird\Model\GroupChannelListMembersResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listMembersAsync
     *
     * List members
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (Required) (required)
     * @param  string $token (optional)
     * @param  int $limit Specifies the number of results to return per page. Acceptable values are 1 to 100, inclusive. (Default: 10) (optional)
     * @param  string $user_id Specifies the unique ID of a user. If &#x60;user_id&#x60; is provided, the response will include two additional boolean properties about each user in the members list. - &#x60;is_blocking_me&#x60;: Indicates whether the listed user is blocking the user specified in the user_id parameter. - &#x60;is_blocked_by_me&#x60;: Indicates whether the listed user is blocked by the user specified in the user_id parameter. (optional)
     * @param  bool $show_delivery_receipt (optional)
     * @param  bool $show_read_receipt (optional)
     * @param  bool $show_member_is_muted (optional)
     * @param  string $order Specifies the method to sort a list of results. Acceptable values are the following: - &#x60;member_nickname_alphabetical&#x60; (default): sorts by the member nicknames in alphabetical order. - &#x60;operator_then_member_alphabetical&#x60;: sorts by the operational role and member nickname in alphabetical order where channel operators are listed before channel members. (optional)
     * @param  string $operator_filter Restricts the search scope to only retrieve operators or non-operator members of the channel. Acceptable values are the following: - &#x60;all&#x60; (default): no filter is applied to the list. - &#x60;operator&#x60;: only channel operators are retrieved. - &#x60;nonoperator&#x60;: all channel members, except channel operators, are retrieved. (optional)
     * @param  string $member_state_filter Restricts the search scope to retrieve members based on if they have accepted an invitation or if they were invited by a friend. Acceptable values are &#x60;invited_only&#x60;, &#x60;joined_only&#x60;, &#x60;invited_by_friend&#x60;, &#x60;invited_by_non_friend&#x60;, and &#x60;all&#x60;. (Default: &#x60;all&#x60;) (optional)
     * @param  string $muted_member_filter Restricts the search scope to retrieve members who are muted or unmuted in the channel. Acceptable values are &#x60;all&#x60;, &#x60;muted&#x60;, and &#x60;unmuted&#x60;. (Default: &#x60;all&#x60;) (optional)
     * @param  string $member_active_mode_filter Restricts the search scope to retrieve members who are activated or deactivated in the channel. Acceptable values are &#x60;all&#x60;, &#x60;activated&#x60;, and &#x60;deactivated&#x60;. (default: &#x60;activated&#x60;) (optional)
     * @param  string $nickname_startswith Searches for members whose nicknames start with the specified value. Urlencoding the value is recommended. (optional)
     * @param  bool $include_push_preference Determines whether to include information about the push preference of each member, such as &#x60;push_enabled&#x60;, &#x60;push_trigger_option&#x60;, and &#x60;do_not_disturb&#x60;. (Default: &#x60;false&#x60;) (optional)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listMembersAsync($associative_array)
    {
        return $this->listMembersAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listMembersAsyncWithHttpInfo
     *
     * List members
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (Required) (required)
     * @param  string $token (optional)
     * @param  int $limit Specifies the number of results to return per page. Acceptable values are 1 to 100, inclusive. (Default: 10) (optional)
     * @param  string $user_id Specifies the unique ID of a user. If &#x60;user_id&#x60; is provided, the response will include two additional boolean properties about each user in the members list. - &#x60;is_blocking_me&#x60;: Indicates whether the listed user is blocking the user specified in the user_id parameter. - &#x60;is_blocked_by_me&#x60;: Indicates whether the listed user is blocked by the user specified in the user_id parameter. (optional)
     * @param  bool $show_delivery_receipt (optional)
     * @param  bool $show_read_receipt (optional)
     * @param  bool $show_member_is_muted (optional)
     * @param  string $order Specifies the method to sort a list of results. Acceptable values are the following: - &#x60;member_nickname_alphabetical&#x60; (default): sorts by the member nicknames in alphabetical order. - &#x60;operator_then_member_alphabetical&#x60;: sorts by the operational role and member nickname in alphabetical order where channel operators are listed before channel members. (optional)
     * @param  string $operator_filter Restricts the search scope to only retrieve operators or non-operator members of the channel. Acceptable values are the following: - &#x60;all&#x60; (default): no filter is applied to the list. - &#x60;operator&#x60;: only channel operators are retrieved. - &#x60;nonoperator&#x60;: all channel members, except channel operators, are retrieved. (optional)
     * @param  string $member_state_filter Restricts the search scope to retrieve members based on if they have accepted an invitation or if they were invited by a friend. Acceptable values are &#x60;invited_only&#x60;, &#x60;joined_only&#x60;, &#x60;invited_by_friend&#x60;, &#x60;invited_by_non_friend&#x60;, and &#x60;all&#x60;. (Default: &#x60;all&#x60;) (optional)
     * @param  string $muted_member_filter Restricts the search scope to retrieve members who are muted or unmuted in the channel. Acceptable values are &#x60;all&#x60;, &#x60;muted&#x60;, and &#x60;unmuted&#x60;. (Default: &#x60;all&#x60;) (optional)
     * @param  string $member_active_mode_filter Restricts the search scope to retrieve members who are activated or deactivated in the channel. Acceptable values are &#x60;all&#x60;, &#x60;activated&#x60;, and &#x60;deactivated&#x60;. (default: &#x60;activated&#x60;) (optional)
     * @param  string $nickname_startswith Searches for members whose nicknames start with the specified value. Urlencoding the value is recommended. (optional)
     * @param  bool $include_push_preference Determines whether to include information about the push preference of each member, such as &#x60;push_enabled&#x60;, &#x60;push_trigger_option&#x60;, and &#x60;do_not_disturb&#x60;. (Default: &#x60;false&#x60;) (optional)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listMembersAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\Sendbird\Model\GroupChannelListMembersResponse';
        $request = $this->listMembersRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listMembers'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (Required) (required)
     * @param  string $token (optional)
     * @param  int $limit Specifies the number of results to return per page. Acceptable values are 1 to 100, inclusive. (Default: 10) (optional)
     * @param  string $user_id Specifies the unique ID of a user. If &#x60;user_id&#x60; is provided, the response will include two additional boolean properties about each user in the members list. - &#x60;is_blocking_me&#x60;: Indicates whether the listed user is blocking the user specified in the user_id parameter. - &#x60;is_blocked_by_me&#x60;: Indicates whether the listed user is blocked by the user specified in the user_id parameter. (optional)
     * @param  bool $show_delivery_receipt (optional)
     * @param  bool $show_read_receipt (optional)
     * @param  bool $show_member_is_muted (optional)
     * @param  string $order Specifies the method to sort a list of results. Acceptable values are the following: - &#x60;member_nickname_alphabetical&#x60; (default): sorts by the member nicknames in alphabetical order. - &#x60;operator_then_member_alphabetical&#x60;: sorts by the operational role and member nickname in alphabetical order where channel operators are listed before channel members. (optional)
     * @param  string $operator_filter Restricts the search scope to only retrieve operators or non-operator members of the channel. Acceptable values are the following: - &#x60;all&#x60; (default): no filter is applied to the list. - &#x60;operator&#x60;: only channel operators are retrieved. - &#x60;nonoperator&#x60;: all channel members, except channel operators, are retrieved. (optional)
     * @param  string $member_state_filter Restricts the search scope to retrieve members based on if they have accepted an invitation or if they were invited by a friend. Acceptable values are &#x60;invited_only&#x60;, &#x60;joined_only&#x60;, &#x60;invited_by_friend&#x60;, &#x60;invited_by_non_friend&#x60;, and &#x60;all&#x60;. (Default: &#x60;all&#x60;) (optional)
     * @param  string $muted_member_filter Restricts the search scope to retrieve members who are muted or unmuted in the channel. Acceptable values are &#x60;all&#x60;, &#x60;muted&#x60;, and &#x60;unmuted&#x60;. (Default: &#x60;all&#x60;) (optional)
     * @param  string $member_active_mode_filter Restricts the search scope to retrieve members who are activated or deactivated in the channel. Acceptable values are &#x60;all&#x60;, &#x60;activated&#x60;, and &#x60;deactivated&#x60;. (default: &#x60;activated&#x60;) (optional)
     * @param  string $nickname_startswith Searches for members whose nicknames start with the specified value. Urlencoding the value is recommended. (optional)
     * @param  bool $include_push_preference Determines whether to include information about the push preference of each member, such as &#x60;push_enabled&#x60;, &#x60;push_trigger_option&#x60;, and &#x60;do_not_disturb&#x60;. (Default: &#x60;false&#x60;) (optional)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listMembersRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $channel_url = array_key_exists('channel_url', $associative_array) ? $associative_array['channel_url'] : null;
        $token = array_key_exists('token', $associative_array) ? $associative_array['token'] : null;
        $limit = array_key_exists('limit', $associative_array) ? $associative_array['limit'] : null;
        $user_id = array_key_exists('user_id', $associative_array) ? $associative_array['user_id'] : null;
        $show_delivery_receipt = array_key_exists('show_delivery_receipt', $associative_array) ? $associative_array['show_delivery_receipt'] : null;
        $show_read_receipt = array_key_exists('show_read_receipt', $associative_array) ? $associative_array['show_read_receipt'] : null;
        $show_member_is_muted = array_key_exists('show_member_is_muted', $associative_array) ? $associative_array['show_member_is_muted'] : null;
        $order = array_key_exists('order', $associative_array) ? $associative_array['order'] : null;
        $operator_filter = array_key_exists('operator_filter', $associative_array) ? $associative_array['operator_filter'] : null;
        $member_state_filter = array_key_exists('member_state_filter', $associative_array) ? $associative_array['member_state_filter'] : null;
        $muted_member_filter = array_key_exists('muted_member_filter', $associative_array) ? $associative_array['muted_member_filter'] : null;
        $member_active_mode_filter = array_key_exists('member_active_mode_filter', $associative_array) ? $associative_array['member_active_mode_filter'] : null;
        $nickname_startswith = array_key_exists('nickname_startswith', $associative_array) ? $associative_array['nickname_startswith'] : null;
        $include_push_preference = array_key_exists('include_push_preference', $associative_array) ? $associative_array['include_push_preference'] : null;
        $api_token = array_key_exists('api_token', $associative_array) ? $associative_array['api_token'] : null;

        // verify the required parameter 'channel_url' is set
        if ($channel_url === null || (is_array($channel_url) && count($channel_url) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel_url when calling listMembers'
            );
        }

        $resourcePath = '/v3/group_channels/{channel_url}/members';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $token,
            'token', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user_id,
            'user_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $show_delivery_receipt,
            'show_delivery_receipt', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $show_read_receipt,
            'show_read_receipt', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $show_member_is_muted,
            'show_member_is_muted', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $order,
            'order', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $operator_filter,
            'operator_filter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $member_state_filter,
            'member_state_filter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $muted_member_filter,
            'muted_member_filter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $member_active_mode_filter,
            'member_active_mode_filter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $nickname_startswith,
            'nickname_startswith', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_push_preference,
            'include_push_preference', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($api_token !== null) {
            $headerParams['api-token'] = ObjectSerializer::toHeaderValue($api_token);
        }

        // path params
        if ($channel_url !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_url' . '}',
                ObjectSerializer::toPathValue($channel_url),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listOperators
     *
     * List operators
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (Required) (required)
     * @param  string $token token (optional)
     * @param  int $limit Specifies the number of results to return per page. Acceptable values are 1 to 100, inclusive. (Default: 10) (optional)
     * @param  string $api_token api_token (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sendbird\Model\ListOperatorsResponse
     */
    public function listOperators($associative_array)
    {
        list($response) = $this->listOperatorsWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation listOperatorsWithHttpInfo
     *
     * List operators
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (Required) (required)
     * @param  string $token (optional)
     * @param  int $limit Specifies the number of results to return per page. Acceptable values are 1 to 100, inclusive. (Default: 10) (optional)
     * @param  string $api_token (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sendbird\Model\ListOperatorsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listOperatorsWithHttpInfo($associative_array)
    {
        $request = $this->listOperatorsRequest($associative_array);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Sendbird\Model\ListOperatorsResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sendbird\Model\ListOperatorsResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sendbird\Model\ListOperatorsResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sendbird\Model\ListOperatorsResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sendbird\Model\ListOperatorsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listOperatorsAsync
     *
     * List operators
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (Required) (required)
     * @param  string $token (optional)
     * @param  int $limit Specifies the number of results to return per page. Acceptable values are 1 to 100, inclusive. (Default: 10) (optional)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listOperatorsAsync($associative_array)
    {
        return $this->listOperatorsAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listOperatorsAsyncWithHttpInfo
     *
     * List operators
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (Required) (required)
     * @param  string $token (optional)
     * @param  int $limit Specifies the number of results to return per page. Acceptable values are 1 to 100, inclusive. (Default: 10) (optional)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listOperatorsAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\Sendbird\Model\ListOperatorsResponse';
        $request = $this->listOperatorsRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listOperators'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (Required) (required)
     * @param  string $token (optional)
     * @param  int $limit Specifies the number of results to return per page. Acceptable values are 1 to 100, inclusive. (Default: 10) (optional)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listOperatorsRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $channel_url = array_key_exists('channel_url', $associative_array) ? $associative_array['channel_url'] : null;
        $token = array_key_exists('token', $associative_array) ? $associative_array['token'] : null;
        $limit = array_key_exists('limit', $associative_array) ? $associative_array['limit'] : null;
        $api_token = array_key_exists('api_token', $associative_array) ? $associative_array['api_token'] : null;

        // verify the required parameter 'channel_url' is set
        if ($channel_url === null || (is_array($channel_url) && count($channel_url) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel_url when calling listOperators'
            );
        }

        $resourcePath = '/v3/group_channels/{channel_url}/operators';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $token,
            'token', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($api_token !== null) {
            $headerParams['api-token'] = ObjectSerializer::toHeaderValue($api_token);
        }

        // path params
        if ($channel_url !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_url' . '}',
                ObjectSerializer::toPathValue($channel_url),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation registerOperatorsToAGroupChannel
     *
     * Register operators to a group channel
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token api_token (optional)
     * @param  \Sendbird\Model\RegisterOperatorsToAGroupChannelRequest $register_operators_to_a_group_channel_request register_operators_to_a_group_channel_request (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function registerOperatorsToAGroupChannel($associative_array)
    {
        list($response) = $this->registerOperatorsToAGroupChannelWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation registerOperatorsToAGroupChannelWithHttpInfo
     *
     * Register operators to a group channel
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\RegisterOperatorsToAGroupChannelRequest $register_operators_to_a_group_channel_request (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function registerOperatorsToAGroupChannelWithHttpInfo($associative_array)
    {
        $request = $this->registerOperatorsToAGroupChannelRequest($associative_array);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation registerOperatorsToAGroupChannelAsync
     *
     * Register operators to a group channel
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\RegisterOperatorsToAGroupChannelRequest $register_operators_to_a_group_channel_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function registerOperatorsToAGroupChannelAsync($associative_array)
    {
        return $this->registerOperatorsToAGroupChannelAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation registerOperatorsToAGroupChannelAsyncWithHttpInfo
     *
     * Register operators to a group channel
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\RegisterOperatorsToAGroupChannelRequest $register_operators_to_a_group_channel_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function registerOperatorsToAGroupChannelAsyncWithHttpInfo($associative_array)
    {
        $returnType = 'object';
        $request = $this->registerOperatorsToAGroupChannelRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'registerOperatorsToAGroupChannel'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\RegisterOperatorsToAGroupChannelRequest $register_operators_to_a_group_channel_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function registerOperatorsToAGroupChannelRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $channel_url = array_key_exists('channel_url', $associative_array) ? $associative_array['channel_url'] : null;
        $api_token = array_key_exists('api_token', $associative_array) ? $associative_array['api_token'] : null;
        $register_operators_to_a_group_channel_request = array_key_exists('register_operators_to_a_group_channel_request', $associative_array) ? $associative_array['register_operators_to_a_group_channel_request'] : null;

        // verify the required parameter 'channel_url' is set
        if ($channel_url === null || (is_array($channel_url) && count($channel_url) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel_url when calling registerOperatorsToAGroupChannel'
            );
        }

        $resourcePath = '/v3/group_channels/{channel_url}/operators';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($api_token !== null) {
            $headerParams['api-token'] = ObjectSerializer::toHeaderValue($api_token);
        }

        // path params
        if ($channel_url !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_url' . '}',
                ObjectSerializer::toPathValue($channel_url),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($register_operators_to_a_group_channel_request)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($register_operators_to_a_group_channel_request));
            } else {
                $httpBody = $register_operators_to_a_group_channel_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation resetChatHistory
     *
     * Reset chat history
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token api_token (optional)
     * @param  \Sendbird\Model\ResetChatHistoryRequest $reset_chat_history_request reset_chat_history_request (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sendbird\Model\ResetChatHistoryResponse
     */
    public function resetChatHistory($associative_array)
    {
        list($response) = $this->resetChatHistoryWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation resetChatHistoryWithHttpInfo
     *
     * Reset chat history
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\ResetChatHistoryRequest $reset_chat_history_request (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sendbird\Model\ResetChatHistoryResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function resetChatHistoryWithHttpInfo($associative_array)
    {
        $request = $this->resetChatHistoryRequest($associative_array);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Sendbird\Model\ResetChatHistoryResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sendbird\Model\ResetChatHistoryResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sendbird\Model\ResetChatHistoryResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sendbird\Model\ResetChatHistoryResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sendbird\Model\ResetChatHistoryResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation resetChatHistoryAsync
     *
     * Reset chat history
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\ResetChatHistoryRequest $reset_chat_history_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function resetChatHistoryAsync($associative_array)
    {
        return $this->resetChatHistoryAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation resetChatHistoryAsyncWithHttpInfo
     *
     * Reset chat history
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\ResetChatHistoryRequest $reset_chat_history_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function resetChatHistoryAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\Sendbird\Model\ResetChatHistoryResponse';
        $request = $this->resetChatHistoryRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'resetChatHistory'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\ResetChatHistoryRequest $reset_chat_history_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function resetChatHistoryRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $channel_url = array_key_exists('channel_url', $associative_array) ? $associative_array['channel_url'] : null;
        $api_token = array_key_exists('api_token', $associative_array) ? $associative_array['api_token'] : null;
        $reset_chat_history_request = array_key_exists('reset_chat_history_request', $associative_array) ? $associative_array['reset_chat_history_request'] : null;

        // verify the required parameter 'channel_url' is set
        if ($channel_url === null || (is_array($channel_url) && count($channel_url) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel_url when calling resetChatHistory'
            );
        }

        $resourcePath = '/v3/group_channels/{channel_url}/reset_user_history';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($api_token !== null) {
            $headerParams['api-token'] = ObjectSerializer::toHeaderValue($api_token);
        }

        // path params
        if ($channel_url !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_url' . '}',
                ObjectSerializer::toPathValue($channel_url),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($reset_chat_history_request)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($reset_chat_history_request));
            } else {
                $httpBody = $reset_chat_history_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation startTypingIndicators
     *
     * Start typing indicators
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token api_token (optional)
     * @param  \Sendbird\Model\StartTypingIndicatorsRequest $start_typing_indicators_request start_typing_indicators_request (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function startTypingIndicators($associative_array)
    {
        list($response) = $this->startTypingIndicatorsWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation startTypingIndicatorsWithHttpInfo
     *
     * Start typing indicators
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\StartTypingIndicatorsRequest $start_typing_indicators_request (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function startTypingIndicatorsWithHttpInfo($associative_array)
    {
        $request = $this->startTypingIndicatorsRequest($associative_array);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation startTypingIndicatorsAsync
     *
     * Start typing indicators
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\StartTypingIndicatorsRequest $start_typing_indicators_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function startTypingIndicatorsAsync($associative_array)
    {
        return $this->startTypingIndicatorsAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation startTypingIndicatorsAsyncWithHttpInfo
     *
     * Start typing indicators
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\StartTypingIndicatorsRequest $start_typing_indicators_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function startTypingIndicatorsAsyncWithHttpInfo($associative_array)
    {
        $returnType = 'object';
        $request = $this->startTypingIndicatorsRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'startTypingIndicators'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\StartTypingIndicatorsRequest $start_typing_indicators_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function startTypingIndicatorsRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $channel_url = array_key_exists('channel_url', $associative_array) ? $associative_array['channel_url'] : null;
        $api_token = array_key_exists('api_token', $associative_array) ? $associative_array['api_token'] : null;
        $start_typing_indicators_request = array_key_exists('start_typing_indicators_request', $associative_array) ? $associative_array['start_typing_indicators_request'] : null;

        // verify the required parameter 'channel_url' is set
        if ($channel_url === null || (is_array($channel_url) && count($channel_url) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel_url when calling startTypingIndicators'
            );
        }

        $resourcePath = '/v3/group_channels/{channel_url}/typing';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($api_token !== null) {
            $headerParams['api-token'] = ObjectSerializer::toHeaderValue($api_token);
        }

        // path params
        if ($channel_url !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_url' . '}',
                ObjectSerializer::toPathValue($channel_url),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($start_typing_indicators_request)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($start_typing_indicators_request));
            } else {
                $httpBody = $start_typing_indicators_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation stopTypingIndicators
     *
     * Stop typing indicators
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token api_token (optional)
     * @param  \Sendbird\Model\StartTypingIndicatorsRequest $start_typing_indicators_request start_typing_indicators_request (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function stopTypingIndicators($associative_array)
    {
        list($response) = $this->stopTypingIndicatorsWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation stopTypingIndicatorsWithHttpInfo
     *
     * Stop typing indicators
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\StartTypingIndicatorsRequest $start_typing_indicators_request (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function stopTypingIndicatorsWithHttpInfo($associative_array)
    {
        $request = $this->stopTypingIndicatorsRequest($associative_array);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation stopTypingIndicatorsAsync
     *
     * Stop typing indicators
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\StartTypingIndicatorsRequest $start_typing_indicators_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function stopTypingIndicatorsAsync($associative_array)
    {
        return $this->stopTypingIndicatorsAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation stopTypingIndicatorsAsyncWithHttpInfo
     *
     * Stop typing indicators
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\StartTypingIndicatorsRequest $start_typing_indicators_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function stopTypingIndicatorsAsyncWithHttpInfo($associative_array)
    {
        $returnType = 'object';
        $request = $this->stopTypingIndicatorsRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'stopTypingIndicators'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\StartTypingIndicatorsRequest $start_typing_indicators_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function stopTypingIndicatorsRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $channel_url = array_key_exists('channel_url', $associative_array) ? $associative_array['channel_url'] : null;
        $api_token = array_key_exists('api_token', $associative_array) ? $associative_array['api_token'] : null;
        $start_typing_indicators_request = array_key_exists('start_typing_indicators_request', $associative_array) ? $associative_array['start_typing_indicators_request'] : null;

        // verify the required parameter 'channel_url' is set
        if ($channel_url === null || (is_array($channel_url) && count($channel_url) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel_url when calling stopTypingIndicators'
            );
        }

        $resourcePath = '/v3/group_channels/{channel_url}/typing';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($api_token !== null) {
            $headerParams['api-token'] = ObjectSerializer::toHeaderValue($api_token);
        }

        // path params
        if ($channel_url !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_url' . '}',
                ObjectSerializer::toPathValue($channel_url),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($start_typing_indicators_request)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($start_typing_indicators_request));
            } else {
                $httpBody = $start_typing_indicators_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation unhideAChannel
     *
     * Unhide a channel
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (Required) (required)
     * @param  string $user_id (Required) (required)
     * @param  bool $should_unhide_all should_unhide_all (optional)
     * @param  string $api_token api_token (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function unhideAChannel($associative_array)
    {
        list($response) = $this->unhideAChannelWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation unhideAChannelWithHttpInfo
     *
     * Unhide a channel
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (Required) (required)
     * @param  string $user_id (Required) (required)
     * @param  bool $should_unhide_all (optional)
     * @param  string $api_token (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function unhideAChannelWithHttpInfo($associative_array)
    {
        $request = $this->unhideAChannelRequest($associative_array);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation unhideAChannelAsync
     *
     * Unhide a channel
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (Required) (required)
     * @param  string $user_id (Required) (required)
     * @param  bool $should_unhide_all (optional)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function unhideAChannelAsync($associative_array)
    {
        return $this->unhideAChannelAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation unhideAChannelAsyncWithHttpInfo
     *
     * Unhide a channel
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (Required) (required)
     * @param  string $user_id (Required) (required)
     * @param  bool $should_unhide_all (optional)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function unhideAChannelAsyncWithHttpInfo($associative_array)
    {
        $returnType = 'object';
        $request = $this->unhideAChannelRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'unhideAChannel'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (Required) (required)
     * @param  string $user_id (Required) (required)
     * @param  bool $should_unhide_all (optional)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function unhideAChannelRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $channel_url = array_key_exists('channel_url', $associative_array) ? $associative_array['channel_url'] : null;
        $user_id = array_key_exists('user_id', $associative_array) ? $associative_array['user_id'] : null;
        $should_unhide_all = array_key_exists('should_unhide_all', $associative_array) ? $associative_array['should_unhide_all'] : null;
        $api_token = array_key_exists('api_token', $associative_array) ? $associative_array['api_token'] : null;

        // verify the required parameter 'channel_url' is set
        if ($channel_url === null || (is_array($channel_url) && count($channel_url) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel_url when calling unhideAChannel'
            );
        }
        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_id when calling unhideAChannel'
            );
        }

        $resourcePath = '/v3/group_channels/{channel_url}/hide';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user_id,
            'user_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $should_unhide_all,
            'should_unhide_all', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($api_token !== null) {
            $headerParams['api-token'] = ObjectSerializer::toHeaderValue($api_token);
        }

        // path params
        if ($channel_url !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_url' . '}',
                ObjectSerializer::toPathValue($channel_url),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateAGroupChannel
     *
     * Update a group channel
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url channel_url (required)
     * @param  string $api_token api_token (optional)
     * @param  \Sendbird\Model\UpdateAGroupChannelRequest $update_a_group_channel_request update_a_group_channel_request (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sendbird\Model\SendbirdGroupChannelDetail
     */
    public function updateAGroupChannel($associative_array)
    {
        list($response) = $this->updateAGroupChannelWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation updateAGroupChannelWithHttpInfo
     *
     * Update a group channel
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\UpdateAGroupChannelRequest $update_a_group_channel_request (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sendbird\Model\SendbirdGroupChannelDetail, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateAGroupChannelWithHttpInfo($associative_array)
    {
        $request = $this->updateAGroupChannelRequest($associative_array);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Sendbird\Model\SendbirdGroupChannelDetail' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sendbird\Model\SendbirdGroupChannelDetail' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sendbird\Model\SendbirdGroupChannelDetail', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sendbird\Model\SendbirdGroupChannelDetail';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sendbird\Model\SendbirdGroupChannelDetail',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateAGroupChannelAsync
     *
     * Update a group channel
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\UpdateAGroupChannelRequest $update_a_group_channel_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateAGroupChannelAsync($associative_array)
    {
        return $this->updateAGroupChannelAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateAGroupChannelAsyncWithHttpInfo
     *
     * Update a group channel
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\UpdateAGroupChannelRequest $update_a_group_channel_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateAGroupChannelAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\Sendbird\Model\SendbirdGroupChannelDetail';
        $request = $this->updateAGroupChannelRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateAGroupChannel'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\UpdateAGroupChannelRequest $update_a_group_channel_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateAGroupChannelRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $channel_url = array_key_exists('channel_url', $associative_array) ? $associative_array['channel_url'] : null;
        $api_token = array_key_exists('api_token', $associative_array) ? $associative_array['api_token'] : null;
        $update_a_group_channel_request = array_key_exists('update_a_group_channel_request', $associative_array) ? $associative_array['update_a_group_channel_request'] : null;

        // verify the required parameter 'channel_url' is set
        if ($channel_url === null || (is_array($channel_url) && count($channel_url) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel_url when calling updateAGroupChannel'
            );
        }

        $resourcePath = '/v3/group_channels/{channel_url}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($api_token !== null) {
            $headerParams['api-token'] = ObjectSerializer::toHeaderValue($api_token);
        }

        // path params
        if ($channel_url !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_url' . '}',
                ObjectSerializer::toPathValue($channel_url),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($update_a_group_channel_request)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($update_a_group_channel_request));
            } else {
                $httpBody = $update_a_group_channel_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
