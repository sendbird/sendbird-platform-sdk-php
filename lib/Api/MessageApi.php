<?php
/**
 * MessageApi
 * PHP version 7.4
 *
 * @category Class
 * @package  Sendbird
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Sendbird Platform SDK
 *
 * Sendbird Platform API SDK  [https://sendbird.com/docs/chat/v3/platform-api/getting-started/prepare-to-use-api](https://sendbird.com/docs/chat/v3/platform-api/getting-started/prepare-to-use-api)  Contact Support:   Name: Sendbird   Email: [support@sendbird.com](https://mailto:support@sendbird.com)
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@sendbird.com
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 6.0.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Sendbird\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Sendbird\ApiException;
use Sendbird\Configuration;
use Sendbird\HeaderSelector;
use Sendbird\ObjectSerializer;

/**
 * MessageApi Class Doc Comment
 *
 * @category Class
 * @package  Sendbird
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class MessageApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation addExtraDataToAMessage
     *
     * Add extra data to a message
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_type (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  string $message_id (Required) (required)
     * @param  string $api_token api_token (optional)
     * @param  \Sendbird\Model\AddExtraDataToAMessageRequest $add_extra_data_to_a_message_request add_extra_data_to_a_message_request (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sendbird\Model\AddExtraDataToAMessageResponse
     */
    public function addExtraDataToAMessage($associative_array)
    {
        list($response) = $this->addExtraDataToAMessageWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation addExtraDataToAMessageWithHttpInfo
     *
     * Add extra data to a message
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_type (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  string $message_id (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\AddExtraDataToAMessageRequest $add_extra_data_to_a_message_request (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sendbird\Model\AddExtraDataToAMessageResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function addExtraDataToAMessageWithHttpInfo($associative_array)
    {
        $request = $this->addExtraDataToAMessageRequest($associative_array);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Sendbird\Model\AddExtraDataToAMessageResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sendbird\Model\AddExtraDataToAMessageResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sendbird\Model\AddExtraDataToAMessageResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sendbird\Model\AddExtraDataToAMessageResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sendbird\Model\AddExtraDataToAMessageResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation addExtraDataToAMessageAsync
     *
     * Add extra data to a message
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_type (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  string $message_id (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\AddExtraDataToAMessageRequest $add_extra_data_to_a_message_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addExtraDataToAMessageAsync($associative_array)
    {
        return $this->addExtraDataToAMessageAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addExtraDataToAMessageAsyncWithHttpInfo
     *
     * Add extra data to a message
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_type (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  string $message_id (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\AddExtraDataToAMessageRequest $add_extra_data_to_a_message_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addExtraDataToAMessageAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\Sendbird\Model\AddExtraDataToAMessageResponse';
        $request = $this->addExtraDataToAMessageRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addExtraDataToAMessage'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_type (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  string $message_id (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\AddExtraDataToAMessageRequest $add_extra_data_to_a_message_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function addExtraDataToAMessageRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $channel_type = array_key_exists('channel_type', $associative_array) ? $associative_array['channel_type'] : null;
        $channel_url = array_key_exists('channel_url', $associative_array) ? $associative_array['channel_url'] : null;
        $message_id = array_key_exists('message_id', $associative_array) ? $associative_array['message_id'] : null;
        $api_token = array_key_exists('api_token', $associative_array) ? $associative_array['api_token'] : null;
        $add_extra_data_to_a_message_request = array_key_exists('add_extra_data_to_a_message_request', $associative_array) ? $associative_array['add_extra_data_to_a_message_request'] : null;

        // verify the required parameter 'channel_type' is set
        if ($channel_type === null || (is_array($channel_type) && count($channel_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel_type when calling addExtraDataToAMessage'
            );
        }
        // verify the required parameter 'channel_url' is set
        if ($channel_url === null || (is_array($channel_url) && count($channel_url) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel_url when calling addExtraDataToAMessage'
            );
        }
        // verify the required parameter 'message_id' is set
        if ($message_id === null || (is_array($message_id) && count($message_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $message_id when calling addExtraDataToAMessage'
            );
        }

        $resourcePath = '/v3/{channel_type}/{channel_url}/messages/{message_id}/sorted_metaarray';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($api_token !== null) {
            $headerParams['api-token'] = ObjectSerializer::toHeaderValue($api_token);
        }

        // path params
        if ($channel_type !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_type' . '}',
                ObjectSerializer::toPathValue($channel_type),
                $resourcePath
            );
        }
        // path params
        if ($channel_url !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_url' . '}',
                ObjectSerializer::toPathValue($channel_url),
                $resourcePath
            );
        }
        // path params
        if ($message_id !== null) {
            $resourcePath = str_replace(
                '{' . 'message_id' . '}',
                ObjectSerializer::toPathValue($message_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($add_extra_data_to_a_message_request)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($add_extra_data_to_a_message_request));
            } else {
                $httpBody = $add_extra_data_to_a_message_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteAMessage
     *
     * Delete a message
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_type (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  string $message_id (Required) (required)
     * @param  string $api_token api_token (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function deleteAMessage($associative_array)
    {
        list($response) = $this->deleteAMessageWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation deleteAMessageWithHttpInfo
     *
     * Delete a message
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_type (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  string $message_id (Required) (required)
     * @param  string $api_token (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteAMessageWithHttpInfo($associative_array)
    {
        $request = $this->deleteAMessageRequest($associative_array);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteAMessageAsync
     *
     * Delete a message
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_type (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  string $message_id (Required) (required)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAMessageAsync($associative_array)
    {
        return $this->deleteAMessageAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteAMessageAsyncWithHttpInfo
     *
     * Delete a message
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_type (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  string $message_id (Required) (required)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAMessageAsyncWithHttpInfo($associative_array)
    {
        $returnType = 'object';
        $request = $this->deleteAMessageRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteAMessage'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_type (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  string $message_id (Required) (required)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteAMessageRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $channel_type = array_key_exists('channel_type', $associative_array) ? $associative_array['channel_type'] : null;
        $channel_url = array_key_exists('channel_url', $associative_array) ? $associative_array['channel_url'] : null;
        $message_id = array_key_exists('message_id', $associative_array) ? $associative_array['message_id'] : null;
        $api_token = array_key_exists('api_token', $associative_array) ? $associative_array['api_token'] : null;

        // verify the required parameter 'channel_type' is set
        if ($channel_type === null || (is_array($channel_type) && count($channel_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel_type when calling deleteAMessage'
            );
        }
        // verify the required parameter 'channel_url' is set
        if ($channel_url === null || (is_array($channel_url) && count($channel_url) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel_url when calling deleteAMessage'
            );
        }
        // verify the required parameter 'message_id' is set
        if ($message_id === null || (is_array($message_id) && count($message_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $message_id when calling deleteAMessage'
            );
        }

        $resourcePath = '/v3/{channel_type}/{channel_url}/messages/{message_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($api_token !== null) {
            $headerParams['api-token'] = ObjectSerializer::toHeaderValue($api_token);
        }

        // path params
        if ($channel_type !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_type' . '}',
                ObjectSerializer::toPathValue($channel_type),
                $resourcePath
            );
        }
        // path params
        if ($channel_url !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_url' . '}',
                ObjectSerializer::toPathValue($channel_url),
                $resourcePath
            );
        }
        // path params
        if ($message_id !== null) {
            $resourcePath = str_replace(
                '{' . 'message_id' . '}',
                ObjectSerializer::toPathValue($message_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAMessage
     *
     * Get a message
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_type (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  string $message_id (Required) (required)
     * @param  bool $include_reactions include_reactions (optional)
     * @param  bool $include_thread_info include_thread_info (optional)
     * @param  bool $include_parent_message_info include_parent_message_info (optional)
     * @param  bool $include_poll_details Determines whether to include all properties of a poll resource with a full list of options in the results. If set to false, a selection of poll resource properties consisting of id, title, close_at, created_at, updated_at, status, and message_id are returned. (Default: false) * To use this property, the polls feature should be turned on in Settings &gt; Chat &gt; Features on Sendbird Dashboard. (optional)
     * @param  bool $with_sorted_meta_array with_sorted_meta_array (optional)
     * @param  string $api_token api_token (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sendbird\Model\SendbirdMessageResponse
     */
    public function getAMessage($associative_array)
    {
        list($response) = $this->getAMessageWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation getAMessageWithHttpInfo
     *
     * Get a message
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_type (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  string $message_id (Required) (required)
     * @param  bool $include_reactions (optional)
     * @param  bool $include_thread_info (optional)
     * @param  bool $include_parent_message_info (optional)
     * @param  bool $include_poll_details Determines whether to include all properties of a poll resource with a full list of options in the results. If set to false, a selection of poll resource properties consisting of id, title, close_at, created_at, updated_at, status, and message_id are returned. (Default: false) * To use this property, the polls feature should be turned on in Settings &gt; Chat &gt; Features on Sendbird Dashboard. (optional)
     * @param  bool $with_sorted_meta_array (optional)
     * @param  string $api_token (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sendbird\Model\SendbirdMessageResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAMessageWithHttpInfo($associative_array)
    {
        $request = $this->getAMessageRequest($associative_array);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Sendbird\Model\SendbirdMessageResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sendbird\Model\SendbirdMessageResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sendbird\Model\SendbirdMessageResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sendbird\Model\SendbirdMessageResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sendbird\Model\SendbirdMessageResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAMessageAsync
     *
     * Get a message
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_type (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  string $message_id (Required) (required)
     * @param  bool $include_reactions (optional)
     * @param  bool $include_thread_info (optional)
     * @param  bool $include_parent_message_info (optional)
     * @param  bool $include_poll_details Determines whether to include all properties of a poll resource with a full list of options in the results. If set to false, a selection of poll resource properties consisting of id, title, close_at, created_at, updated_at, status, and message_id are returned. (Default: false) * To use this property, the polls feature should be turned on in Settings &gt; Chat &gt; Features on Sendbird Dashboard. (optional)
     * @param  bool $with_sorted_meta_array (optional)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAMessageAsync($associative_array)
    {
        return $this->getAMessageAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAMessageAsyncWithHttpInfo
     *
     * Get a message
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_type (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  string $message_id (Required) (required)
     * @param  bool $include_reactions (optional)
     * @param  bool $include_thread_info (optional)
     * @param  bool $include_parent_message_info (optional)
     * @param  bool $include_poll_details Determines whether to include all properties of a poll resource with a full list of options in the results. If set to false, a selection of poll resource properties consisting of id, title, close_at, created_at, updated_at, status, and message_id are returned. (Default: false) * To use this property, the polls feature should be turned on in Settings &gt; Chat &gt; Features on Sendbird Dashboard. (optional)
     * @param  bool $with_sorted_meta_array (optional)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAMessageAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\Sendbird\Model\SendbirdMessageResponse';
        $request = $this->getAMessageRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAMessage'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_type (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  string $message_id (Required) (required)
     * @param  bool $include_reactions (optional)
     * @param  bool $include_thread_info (optional)
     * @param  bool $include_parent_message_info (optional)
     * @param  bool $include_poll_details Determines whether to include all properties of a poll resource with a full list of options in the results. If set to false, a selection of poll resource properties consisting of id, title, close_at, created_at, updated_at, status, and message_id are returned. (Default: false) * To use this property, the polls feature should be turned on in Settings &gt; Chat &gt; Features on Sendbird Dashboard. (optional)
     * @param  bool $with_sorted_meta_array (optional)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAMessageRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $channel_type = array_key_exists('channel_type', $associative_array) ? $associative_array['channel_type'] : null;
        $channel_url = array_key_exists('channel_url', $associative_array) ? $associative_array['channel_url'] : null;
        $message_id = array_key_exists('message_id', $associative_array) ? $associative_array['message_id'] : null;
        $include_reactions = array_key_exists('include_reactions', $associative_array) ? $associative_array['include_reactions'] : null;
        $include_thread_info = array_key_exists('include_thread_info', $associative_array) ? $associative_array['include_thread_info'] : null;
        $include_parent_message_info = array_key_exists('include_parent_message_info', $associative_array) ? $associative_array['include_parent_message_info'] : null;
        $include_poll_details = array_key_exists('include_poll_details', $associative_array) ? $associative_array['include_poll_details'] : null;
        $with_sorted_meta_array = array_key_exists('with_sorted_meta_array', $associative_array) ? $associative_array['with_sorted_meta_array'] : null;
        $api_token = array_key_exists('api_token', $associative_array) ? $associative_array['api_token'] : null;

        // verify the required parameter 'channel_type' is set
        if ($channel_type === null || (is_array($channel_type) && count($channel_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel_type when calling getAMessage'
            );
        }
        // verify the required parameter 'channel_url' is set
        if ($channel_url === null || (is_array($channel_url) && count($channel_url) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel_url when calling getAMessage'
            );
        }
        // verify the required parameter 'message_id' is set
        if ($message_id === null || (is_array($message_id) && count($message_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $message_id when calling getAMessage'
            );
        }

        $resourcePath = '/v3/{channel_type}/{channel_url}/messages/{message_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_reactions,
            'include_reactions', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_thread_info,
            'include_thread_info', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_parent_message_info,
            'include_parent_message_info', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_poll_details,
            'include_poll_details', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with_sorted_meta_array,
            'with_sorted_meta_array', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($api_token !== null) {
            $headerParams['api-token'] = ObjectSerializer::toHeaderValue($api_token);
        }

        // path params
        if ($channel_type !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_type' . '}',
                ObjectSerializer::toPathValue($channel_type),
                $resourcePath
            );
        }
        // path params
        if ($channel_url !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_url' . '}',
                ObjectSerializer::toPathValue($channel_url),
                $resourcePath
            );
        }
        // path params
        if ($message_id !== null) {
            $resourcePath = str_replace(
                '{' . 'message_id' . '}',
                ObjectSerializer::toPathValue($message_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTotalNumberOfMessagesInAChannel
     *
     * Get total number of messages in a channel
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_type (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token api_token (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sendbird\Model\GetTotalNumberOfMessagesInAChannelResponse
     */
    public function getTotalNumberOfMessagesInAChannel($associative_array)
    {
        list($response) = $this->getTotalNumberOfMessagesInAChannelWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation getTotalNumberOfMessagesInAChannelWithHttpInfo
     *
     * Get total number of messages in a channel
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_type (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sendbird\Model\GetTotalNumberOfMessagesInAChannelResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTotalNumberOfMessagesInAChannelWithHttpInfo($associative_array)
    {
        $request = $this->getTotalNumberOfMessagesInAChannelRequest($associative_array);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Sendbird\Model\GetTotalNumberOfMessagesInAChannelResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sendbird\Model\GetTotalNumberOfMessagesInAChannelResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sendbird\Model\GetTotalNumberOfMessagesInAChannelResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sendbird\Model\GetTotalNumberOfMessagesInAChannelResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sendbird\Model\GetTotalNumberOfMessagesInAChannelResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTotalNumberOfMessagesInAChannelAsync
     *
     * Get total number of messages in a channel
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_type (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTotalNumberOfMessagesInAChannelAsync($associative_array)
    {
        return $this->getTotalNumberOfMessagesInAChannelAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTotalNumberOfMessagesInAChannelAsyncWithHttpInfo
     *
     * Get total number of messages in a channel
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_type (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTotalNumberOfMessagesInAChannelAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\Sendbird\Model\GetTotalNumberOfMessagesInAChannelResponse';
        $request = $this->getTotalNumberOfMessagesInAChannelRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTotalNumberOfMessagesInAChannel'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_type (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getTotalNumberOfMessagesInAChannelRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $channel_type = array_key_exists('channel_type', $associative_array) ? $associative_array['channel_type'] : null;
        $channel_url = array_key_exists('channel_url', $associative_array) ? $associative_array['channel_url'] : null;
        $api_token = array_key_exists('api_token', $associative_array) ? $associative_array['api_token'] : null;

        // verify the required parameter 'channel_type' is set
        if ($channel_type === null || (is_array($channel_type) && count($channel_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel_type when calling getTotalNumberOfMessagesInAChannel'
            );
        }
        // verify the required parameter 'channel_url' is set
        if ($channel_url === null || (is_array($channel_url) && count($channel_url) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel_url when calling getTotalNumberOfMessagesInAChannel'
            );
        }

        $resourcePath = '/v3/{channel_type}/{channel_url}/messages/total_count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($api_token !== null) {
            $headerParams['api-token'] = ObjectSerializer::toHeaderValue($api_token);
        }

        // path params
        if ($channel_type !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_type' . '}',
                ObjectSerializer::toPathValue($channel_type),
                $resourcePath
            );
        }
        // path params
        if ($channel_url !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_url' . '}',
                ObjectSerializer::toPathValue($channel_url),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listMessages
     *
     * List messages
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_type (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  int $message_ts Specifies the timestamp to be the reference point of the query in Unix milliseconds. Either this or the message_id parameter below should be specified in your query URL to retrieve a list. It fetches messages that were sent prior to and after the specified message_ts and the default value for both prev_limit and next_limit is 15. (required)
     * @param  int $message_id Specifies the unique ID of the message to be the reference point of the query. Either this or the message_ts parameter above should be specified in your query URL to retrieve a list. It fetches messages that were sent prior to and after the specified message_id and the default value for both prev_limit and next_limit is 15. (required)
     * @param  int $prev_limit Specifies the number of previously sent messages to retrieve before message_ts. For example, if message_ts&#x3D;1484202848298, then prev_limit&#x3D;50 returns 50 messages sent by 1484202848297 (message_ts - 1). Acceptable values range from 0 to 200. (Default: 15) (optional)
     * @param  int $next_limit Specifies the number of sent messages to retrieve after message_ts. For example, if message_ts&#x3D;1484202848298, then next_limit&#x3D;50 returns 50 messages sent from 1484202848299 (message_ts + 1). Acceptable values range from 0 to 200. (Default: 15) (optional)
     * @param  bool $include Determines whether to include messages sent exactly on the specified message_ts in the results. (Default: true) (optional)
     * @param  bool $reverse Determines whether to sort the results in reverse chronological order. If set to true, messages appear in reverse chronological order where the newest comes first and the oldest last. (Default: false) (optional)
     * @param  string $sender_id Restricts the search scope to only retrieve messages sent by the user with the specified ID. (optional)
     * @param  string $sender_ids Restricts the search scope to only retrieve messages sent by one or more users with the specified IDs listed in a comma-separated string. (optional)
     * @param  string $operator_filter operator_filter (optional)
     * @param  string $custom_types Specifies a comma-separated string of one or more custom message types to retrieve. The value set to this parameter can serve as a filter as follows: - A string of specific custom types: Messages with the corresponding custom types are returned. - Empty like &amp;custom_types&#x3D;&amp;...: Messages whose custom_type property is empty or has a value of null are returned. - An asterisk (\\*) (default): All messages are returned regardless of their custom_type. (optional)
     * @param  string $message_type message_type (optional)
     * @param  bool $including_removed including_removed (optional)
     * @param  bool $include_reactions include_reactions (optional)
     * @param  string $include_reply_type One of following values: NONE, ALL, ONLY_REPLY_TO_CHANNEL (optional)
     * @param  bool $include_parent_message_info include_parent_message_info (optional)
     * @param  bool $include_thread_info include_thread_info (optional)
     * @param  bool $include_poll_details Determines whether to include all properties of a poll resource with a full list of options in the results. If set to false, a selection of poll resource properties consisting of id, title, close_at, created_at, updated_at, status, and message_id are returned. (Default: false) * To use this property, the polls feature should be turned on in Settings &gt; Chat &gt; Features on Sendbird Dashboard. (optional)
     * @param  bool $with_sorted_meta_array Determines whether to include the sorted_metaarray property in the response. (Default: false) (optional)
     * @param  bool $show_subchannel_messages_only show_subchannel_messages_only (optional)
     * @param  string $user_id user_id (optional)
     * @param  string $api_token api_token (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sendbird\Model\ListMessagesResponse
     */
    public function listMessages($associative_array)
    {
        list($response) = $this->listMessagesWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation listMessagesWithHttpInfo
     *
     * List messages
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_type (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  int $message_ts Specifies the timestamp to be the reference point of the query in Unix milliseconds. Either this or the message_id parameter below should be specified in your query URL to retrieve a list. It fetches messages that were sent prior to and after the specified message_ts and the default value for both prev_limit and next_limit is 15. (required)
     * @param  int $message_id Specifies the unique ID of the message to be the reference point of the query. Either this or the message_ts parameter above should be specified in your query URL to retrieve a list. It fetches messages that were sent prior to and after the specified message_id and the default value for both prev_limit and next_limit is 15. (required)
     * @param  int $prev_limit Specifies the number of previously sent messages to retrieve before message_ts. For example, if message_ts&#x3D;1484202848298, then prev_limit&#x3D;50 returns 50 messages sent by 1484202848297 (message_ts - 1). Acceptable values range from 0 to 200. (Default: 15) (optional)
     * @param  int $next_limit Specifies the number of sent messages to retrieve after message_ts. For example, if message_ts&#x3D;1484202848298, then next_limit&#x3D;50 returns 50 messages sent from 1484202848299 (message_ts + 1). Acceptable values range from 0 to 200. (Default: 15) (optional)
     * @param  bool $include Determines whether to include messages sent exactly on the specified message_ts in the results. (Default: true) (optional)
     * @param  bool $reverse Determines whether to sort the results in reverse chronological order. If set to true, messages appear in reverse chronological order where the newest comes first and the oldest last. (Default: false) (optional)
     * @param  string $sender_id Restricts the search scope to only retrieve messages sent by the user with the specified ID. (optional)
     * @param  string $sender_ids Restricts the search scope to only retrieve messages sent by one or more users with the specified IDs listed in a comma-separated string. (optional)
     * @param  string $operator_filter (optional)
     * @param  string $custom_types Specifies a comma-separated string of one or more custom message types to retrieve. The value set to this parameter can serve as a filter as follows: - A string of specific custom types: Messages with the corresponding custom types are returned. - Empty like &amp;custom_types&#x3D;&amp;...: Messages whose custom_type property is empty or has a value of null are returned. - An asterisk (\\*) (default): All messages are returned regardless of their custom_type. (optional)
     * @param  string $message_type (optional)
     * @param  bool $including_removed (optional)
     * @param  bool $include_reactions (optional)
     * @param  string $include_reply_type One of following values: NONE, ALL, ONLY_REPLY_TO_CHANNEL (optional)
     * @param  bool $include_parent_message_info (optional)
     * @param  bool $include_thread_info (optional)
     * @param  bool $include_poll_details Determines whether to include all properties of a poll resource with a full list of options in the results. If set to false, a selection of poll resource properties consisting of id, title, close_at, created_at, updated_at, status, and message_id are returned. (Default: false) * To use this property, the polls feature should be turned on in Settings &gt; Chat &gt; Features on Sendbird Dashboard. (optional)
     * @param  bool $with_sorted_meta_array Determines whether to include the sorted_metaarray property in the response. (Default: false) (optional)
     * @param  bool $show_subchannel_messages_only (optional)
     * @param  string $user_id (optional)
     * @param  string $api_token (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sendbird\Model\ListMessagesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listMessagesWithHttpInfo($associative_array)
    {
        $request = $this->listMessagesRequest($associative_array);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Sendbird\Model\ListMessagesResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sendbird\Model\ListMessagesResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sendbird\Model\ListMessagesResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sendbird\Model\ListMessagesResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sendbird\Model\ListMessagesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listMessagesAsync
     *
     * List messages
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_type (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  int $message_ts Specifies the timestamp to be the reference point of the query in Unix milliseconds. Either this or the message_id parameter below should be specified in your query URL to retrieve a list. It fetches messages that were sent prior to and after the specified message_ts and the default value for both prev_limit and next_limit is 15. (required)
     * @param  int $message_id Specifies the unique ID of the message to be the reference point of the query. Either this or the message_ts parameter above should be specified in your query URL to retrieve a list. It fetches messages that were sent prior to and after the specified message_id and the default value for both prev_limit and next_limit is 15. (required)
     * @param  int $prev_limit Specifies the number of previously sent messages to retrieve before message_ts. For example, if message_ts&#x3D;1484202848298, then prev_limit&#x3D;50 returns 50 messages sent by 1484202848297 (message_ts - 1). Acceptable values range from 0 to 200. (Default: 15) (optional)
     * @param  int $next_limit Specifies the number of sent messages to retrieve after message_ts. For example, if message_ts&#x3D;1484202848298, then next_limit&#x3D;50 returns 50 messages sent from 1484202848299 (message_ts + 1). Acceptable values range from 0 to 200. (Default: 15) (optional)
     * @param  bool $include Determines whether to include messages sent exactly on the specified message_ts in the results. (Default: true) (optional)
     * @param  bool $reverse Determines whether to sort the results in reverse chronological order. If set to true, messages appear in reverse chronological order where the newest comes first and the oldest last. (Default: false) (optional)
     * @param  string $sender_id Restricts the search scope to only retrieve messages sent by the user with the specified ID. (optional)
     * @param  string $sender_ids Restricts the search scope to only retrieve messages sent by one or more users with the specified IDs listed in a comma-separated string. (optional)
     * @param  string $operator_filter (optional)
     * @param  string $custom_types Specifies a comma-separated string of one or more custom message types to retrieve. The value set to this parameter can serve as a filter as follows: - A string of specific custom types: Messages with the corresponding custom types are returned. - Empty like &amp;custom_types&#x3D;&amp;...: Messages whose custom_type property is empty or has a value of null are returned. - An asterisk (\\*) (default): All messages are returned regardless of their custom_type. (optional)
     * @param  string $message_type (optional)
     * @param  bool $including_removed (optional)
     * @param  bool $include_reactions (optional)
     * @param  string $include_reply_type One of following values: NONE, ALL, ONLY_REPLY_TO_CHANNEL (optional)
     * @param  bool $include_parent_message_info (optional)
     * @param  bool $include_thread_info (optional)
     * @param  bool $include_poll_details Determines whether to include all properties of a poll resource with a full list of options in the results. If set to false, a selection of poll resource properties consisting of id, title, close_at, created_at, updated_at, status, and message_id are returned. (Default: false) * To use this property, the polls feature should be turned on in Settings &gt; Chat &gt; Features on Sendbird Dashboard. (optional)
     * @param  bool $with_sorted_meta_array Determines whether to include the sorted_metaarray property in the response. (Default: false) (optional)
     * @param  bool $show_subchannel_messages_only (optional)
     * @param  string $user_id (optional)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listMessagesAsync($associative_array)
    {
        return $this->listMessagesAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listMessagesAsyncWithHttpInfo
     *
     * List messages
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_type (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  int $message_ts Specifies the timestamp to be the reference point of the query in Unix milliseconds. Either this or the message_id parameter below should be specified in your query URL to retrieve a list. It fetches messages that were sent prior to and after the specified message_ts and the default value for both prev_limit and next_limit is 15. (required)
     * @param  int $message_id Specifies the unique ID of the message to be the reference point of the query. Either this or the message_ts parameter above should be specified in your query URL to retrieve a list. It fetches messages that were sent prior to and after the specified message_id and the default value for both prev_limit and next_limit is 15. (required)
     * @param  int $prev_limit Specifies the number of previously sent messages to retrieve before message_ts. For example, if message_ts&#x3D;1484202848298, then prev_limit&#x3D;50 returns 50 messages sent by 1484202848297 (message_ts - 1). Acceptable values range from 0 to 200. (Default: 15) (optional)
     * @param  int $next_limit Specifies the number of sent messages to retrieve after message_ts. For example, if message_ts&#x3D;1484202848298, then next_limit&#x3D;50 returns 50 messages sent from 1484202848299 (message_ts + 1). Acceptable values range from 0 to 200. (Default: 15) (optional)
     * @param  bool $include Determines whether to include messages sent exactly on the specified message_ts in the results. (Default: true) (optional)
     * @param  bool $reverse Determines whether to sort the results in reverse chronological order. If set to true, messages appear in reverse chronological order where the newest comes first and the oldest last. (Default: false) (optional)
     * @param  string $sender_id Restricts the search scope to only retrieve messages sent by the user with the specified ID. (optional)
     * @param  string $sender_ids Restricts the search scope to only retrieve messages sent by one or more users with the specified IDs listed in a comma-separated string. (optional)
     * @param  string $operator_filter (optional)
     * @param  string $custom_types Specifies a comma-separated string of one or more custom message types to retrieve. The value set to this parameter can serve as a filter as follows: - A string of specific custom types: Messages with the corresponding custom types are returned. - Empty like &amp;custom_types&#x3D;&amp;...: Messages whose custom_type property is empty or has a value of null are returned. - An asterisk (\\*) (default): All messages are returned regardless of their custom_type. (optional)
     * @param  string $message_type (optional)
     * @param  bool $including_removed (optional)
     * @param  bool $include_reactions (optional)
     * @param  string $include_reply_type One of following values: NONE, ALL, ONLY_REPLY_TO_CHANNEL (optional)
     * @param  bool $include_parent_message_info (optional)
     * @param  bool $include_thread_info (optional)
     * @param  bool $include_poll_details Determines whether to include all properties of a poll resource with a full list of options in the results. If set to false, a selection of poll resource properties consisting of id, title, close_at, created_at, updated_at, status, and message_id are returned. (Default: false) * To use this property, the polls feature should be turned on in Settings &gt; Chat &gt; Features on Sendbird Dashboard. (optional)
     * @param  bool $with_sorted_meta_array Determines whether to include the sorted_metaarray property in the response. (Default: false) (optional)
     * @param  bool $show_subchannel_messages_only (optional)
     * @param  string $user_id (optional)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listMessagesAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\Sendbird\Model\ListMessagesResponse';
        $request = $this->listMessagesRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listMessages'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_type (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  int $message_ts Specifies the timestamp to be the reference point of the query in Unix milliseconds. Either this or the message_id parameter below should be specified in your query URL to retrieve a list. It fetches messages that were sent prior to and after the specified message_ts and the default value for both prev_limit and next_limit is 15. (required)
     * @param  int $message_id Specifies the unique ID of the message to be the reference point of the query. Either this or the message_ts parameter above should be specified in your query URL to retrieve a list. It fetches messages that were sent prior to and after the specified message_id and the default value for both prev_limit and next_limit is 15. (required)
     * @param  int $prev_limit Specifies the number of previously sent messages to retrieve before message_ts. For example, if message_ts&#x3D;1484202848298, then prev_limit&#x3D;50 returns 50 messages sent by 1484202848297 (message_ts - 1). Acceptable values range from 0 to 200. (Default: 15) (optional)
     * @param  int $next_limit Specifies the number of sent messages to retrieve after message_ts. For example, if message_ts&#x3D;1484202848298, then next_limit&#x3D;50 returns 50 messages sent from 1484202848299 (message_ts + 1). Acceptable values range from 0 to 200. (Default: 15) (optional)
     * @param  bool $include Determines whether to include messages sent exactly on the specified message_ts in the results. (Default: true) (optional)
     * @param  bool $reverse Determines whether to sort the results in reverse chronological order. If set to true, messages appear in reverse chronological order where the newest comes first and the oldest last. (Default: false) (optional)
     * @param  string $sender_id Restricts the search scope to only retrieve messages sent by the user with the specified ID. (optional)
     * @param  string $sender_ids Restricts the search scope to only retrieve messages sent by one or more users with the specified IDs listed in a comma-separated string. (optional)
     * @param  string $operator_filter (optional)
     * @param  string $custom_types Specifies a comma-separated string of one or more custom message types to retrieve. The value set to this parameter can serve as a filter as follows: - A string of specific custom types: Messages with the corresponding custom types are returned. - Empty like &amp;custom_types&#x3D;&amp;...: Messages whose custom_type property is empty or has a value of null are returned. - An asterisk (\\*) (default): All messages are returned regardless of their custom_type. (optional)
     * @param  string $message_type (optional)
     * @param  bool $including_removed (optional)
     * @param  bool $include_reactions (optional)
     * @param  string $include_reply_type One of following values: NONE, ALL, ONLY_REPLY_TO_CHANNEL (optional)
     * @param  bool $include_parent_message_info (optional)
     * @param  bool $include_thread_info (optional)
     * @param  bool $include_poll_details Determines whether to include all properties of a poll resource with a full list of options in the results. If set to false, a selection of poll resource properties consisting of id, title, close_at, created_at, updated_at, status, and message_id are returned. (Default: false) * To use this property, the polls feature should be turned on in Settings &gt; Chat &gt; Features on Sendbird Dashboard. (optional)
     * @param  bool $with_sorted_meta_array Determines whether to include the sorted_metaarray property in the response. (Default: false) (optional)
     * @param  bool $show_subchannel_messages_only (optional)
     * @param  string $user_id (optional)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listMessagesRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $channel_type = array_key_exists('channel_type', $associative_array) ? $associative_array['channel_type'] : null;
        $channel_url = array_key_exists('channel_url', $associative_array) ? $associative_array['channel_url'] : null;
        $message_ts = array_key_exists('message_ts', $associative_array) ? $associative_array['message_ts'] : null;
        $message_id = array_key_exists('message_id', $associative_array) ? $associative_array['message_id'] : null;
        $prev_limit = array_key_exists('prev_limit', $associative_array) ? $associative_array['prev_limit'] : null;
        $next_limit = array_key_exists('next_limit', $associative_array) ? $associative_array['next_limit'] : null;
        $include = array_key_exists('include', $associative_array) ? $associative_array['include'] : null;
        $reverse = array_key_exists('reverse', $associative_array) ? $associative_array['reverse'] : null;
        $sender_id = array_key_exists('sender_id', $associative_array) ? $associative_array['sender_id'] : null;
        $sender_ids = array_key_exists('sender_ids', $associative_array) ? $associative_array['sender_ids'] : null;
        $operator_filter = array_key_exists('operator_filter', $associative_array) ? $associative_array['operator_filter'] : null;
        $custom_types = array_key_exists('custom_types', $associative_array) ? $associative_array['custom_types'] : null;
        $message_type = array_key_exists('message_type', $associative_array) ? $associative_array['message_type'] : null;
        $including_removed = array_key_exists('including_removed', $associative_array) ? $associative_array['including_removed'] : null;
        $include_reactions = array_key_exists('include_reactions', $associative_array) ? $associative_array['include_reactions'] : null;
        $include_reply_type = array_key_exists('include_reply_type', $associative_array) ? $associative_array['include_reply_type'] : null;
        $include_parent_message_info = array_key_exists('include_parent_message_info', $associative_array) ? $associative_array['include_parent_message_info'] : null;
        $include_thread_info = array_key_exists('include_thread_info', $associative_array) ? $associative_array['include_thread_info'] : null;
        $include_poll_details = array_key_exists('include_poll_details', $associative_array) ? $associative_array['include_poll_details'] : null;
        $with_sorted_meta_array = array_key_exists('with_sorted_meta_array', $associative_array) ? $associative_array['with_sorted_meta_array'] : null;
        $show_subchannel_messages_only = array_key_exists('show_subchannel_messages_only', $associative_array) ? $associative_array['show_subchannel_messages_only'] : null;
        $user_id = array_key_exists('user_id', $associative_array) ? $associative_array['user_id'] : null;
        $api_token = array_key_exists('api_token', $associative_array) ? $associative_array['api_token'] : null;

        // verify the required parameter 'channel_type' is set
        if ($channel_type === null || (is_array($channel_type) && count($channel_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel_type when calling listMessages'
            );
        }
        // verify the required parameter 'channel_url' is set
        if ($channel_url === null || (is_array($channel_url) && count($channel_url) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel_url when calling listMessages'
            );
        }
        // verify the required parameter 'message_ts' is set
        if ($message_ts === null || (is_array($message_ts) && count($message_ts) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $message_ts when calling listMessages'
            );
        }
        // verify the required parameter 'message_id' is set
        if ($message_id === null || (is_array($message_id) && count($message_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $message_id when calling listMessages'
            );
        }

        $resourcePath = '/v3/{channel_type}/{channel_url}/messages';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $message_ts,
            'message_ts', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $message_id,
            'message_id', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $prev_limit,
            'prev_limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $next_limit,
            'next_limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include,
            'include', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $reverse,
            'reverse', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender_id,
            'sender_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender_ids,
            'sender_ids', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $operator_filter,
            'operator_filter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $custom_types,
            'custom_types', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $message_type,
            'message_type', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $including_removed,
            'including_removed', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_reactions,
            'include_reactions', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_reply_type,
            'include_reply_type', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_parent_message_info,
            'include_parent_message_info', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_thread_info,
            'include_thread_info', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_poll_details,
            'include_poll_details', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with_sorted_meta_array,
            'with_sorted_meta_array', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $show_subchannel_messages_only,
            'show_subchannel_messages_only', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user_id,
            'user_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($api_token !== null) {
            $headerParams['api-token'] = ObjectSerializer::toHeaderValue($api_token);
        }

        // path params
        if ($channel_type !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_type' . '}',
                ObjectSerializer::toPathValue($channel_type),
                $resourcePath
            );
        }
        // path params
        if ($channel_url !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_url' . '}',
                ObjectSerializer::toPathValue($channel_url),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation markChannelMessagesAsRead
     *
     * Mark all messages as read
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token api_token (optional)
     * @param  \Sendbird\Model\MarkChannelMessagesAsReadRequest $mark_channel_messages_as_read_request mark_channel_messages_as_read_request (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function markChannelMessagesAsRead($associative_array)
    {
        list($response) = $this->markChannelMessagesAsReadWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation markChannelMessagesAsReadWithHttpInfo
     *
     * Mark all messages as read
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\MarkChannelMessagesAsReadRequest $mark_channel_messages_as_read_request (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function markChannelMessagesAsReadWithHttpInfo($associative_array)
    {
        $request = $this->markChannelMessagesAsReadRequest($associative_array);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation markChannelMessagesAsReadAsync
     *
     * Mark all messages as read
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\MarkChannelMessagesAsReadRequest $mark_channel_messages_as_read_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function markChannelMessagesAsReadAsync($associative_array)
    {
        return $this->markChannelMessagesAsReadAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation markChannelMessagesAsReadAsyncWithHttpInfo
     *
     * Mark all messages as read
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\MarkChannelMessagesAsReadRequest $mark_channel_messages_as_read_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function markChannelMessagesAsReadAsyncWithHttpInfo($associative_array)
    {
        $returnType = 'object';
        $request = $this->markChannelMessagesAsReadRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'markChannelMessagesAsRead'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\MarkChannelMessagesAsReadRequest $mark_channel_messages_as_read_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function markChannelMessagesAsReadRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $channel_url = array_key_exists('channel_url', $associative_array) ? $associative_array['channel_url'] : null;
        $api_token = array_key_exists('api_token', $associative_array) ? $associative_array['api_token'] : null;
        $mark_channel_messages_as_read_request = array_key_exists('mark_channel_messages_as_read_request', $associative_array) ? $associative_array['mark_channel_messages_as_read_request'] : null;

        // verify the required parameter 'channel_url' is set
        if ($channel_url === null || (is_array($channel_url) && count($channel_url) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel_url when calling markChannelMessagesAsRead'
            );
        }

        $resourcePath = '/v3/group_channels/{channel_url}/messages/mark_as_read';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($api_token !== null) {
            $headerParams['api-token'] = ObjectSerializer::toHeaderValue($api_token);
        }

        // path params
        if ($channel_url !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_url' . '}',
                ObjectSerializer::toPathValue($channel_url),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($mark_channel_messages_as_read_request)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($mark_channel_messages_as_read_request));
            } else {
                $httpBody = $mark_channel_messages_as_read_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation migrateMessages
     *
     * Migrate messages
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $target_channel_url (Required) (required)
     * @param  string $api_token api_token (optional)
     * @param  \Sendbird\Model\MigrateMessagesRequest $migrate_messages_request migrate_messages_request (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function migrateMessages($associative_array)
    {
        list($response) = $this->migrateMessagesWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation migrateMessagesWithHttpInfo
     *
     * Migrate messages
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $target_channel_url (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\MigrateMessagesRequest $migrate_messages_request (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function migrateMessagesWithHttpInfo($associative_array)
    {
        $request = $this->migrateMessagesRequest($associative_array);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation migrateMessagesAsync
     *
     * Migrate messages
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $target_channel_url (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\MigrateMessagesRequest $migrate_messages_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function migrateMessagesAsync($associative_array)
    {
        return $this->migrateMessagesAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation migrateMessagesAsyncWithHttpInfo
     *
     * Migrate messages
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $target_channel_url (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\MigrateMessagesRequest $migrate_messages_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function migrateMessagesAsyncWithHttpInfo($associative_array)
    {
        $returnType = 'object';
        $request = $this->migrateMessagesRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'migrateMessages'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $target_channel_url (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\MigrateMessagesRequest $migrate_messages_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function migrateMessagesRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $target_channel_url = array_key_exists('target_channel_url', $associative_array) ? $associative_array['target_channel_url'] : null;
        $api_token = array_key_exists('api_token', $associative_array) ? $associative_array['api_token'] : null;
        $migrate_messages_request = array_key_exists('migrate_messages_request', $associative_array) ? $associative_array['migrate_messages_request'] : null;

        // verify the required parameter 'target_channel_url' is set
        if ($target_channel_url === null || (is_array($target_channel_url) && count($target_channel_url) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $target_channel_url when calling migrateMessages'
            );
        }

        $resourcePath = '/v3/migration/{target_channel_url}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($api_token !== null) {
            $headerParams['api-token'] = ObjectSerializer::toHeaderValue($api_token);
        }

        // path params
        if ($target_channel_url !== null) {
            $resourcePath = str_replace(
                '{' . 'target_channel_url' . '}',
                ObjectSerializer::toPathValue($target_channel_url),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($migrate_messages_request)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($migrate_messages_request));
            } else {
                $httpBody = $migrate_messages_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation removeExtraDataFromAMessage
     *
     * Remove extra data from a message
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_type (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  string $message_id (Required) (required)
     * @param  string $keys keys (optional)
     * @param  string $api_token api_token (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function removeExtraDataFromAMessage($associative_array)
    {
        list($response) = $this->removeExtraDataFromAMessageWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation removeExtraDataFromAMessageWithHttpInfo
     *
     * Remove extra data from a message
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_type (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  string $message_id (Required) (required)
     * @param  string $keys (optional)
     * @param  string $api_token (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function removeExtraDataFromAMessageWithHttpInfo($associative_array)
    {
        $request = $this->removeExtraDataFromAMessageRequest($associative_array);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation removeExtraDataFromAMessageAsync
     *
     * Remove extra data from a message
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_type (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  string $message_id (Required) (required)
     * @param  string $keys (optional)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function removeExtraDataFromAMessageAsync($associative_array)
    {
        return $this->removeExtraDataFromAMessageAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation removeExtraDataFromAMessageAsyncWithHttpInfo
     *
     * Remove extra data from a message
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_type (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  string $message_id (Required) (required)
     * @param  string $keys (optional)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function removeExtraDataFromAMessageAsyncWithHttpInfo($associative_array)
    {
        $returnType = 'object';
        $request = $this->removeExtraDataFromAMessageRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'removeExtraDataFromAMessage'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_type (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  string $message_id (Required) (required)
     * @param  string $keys (optional)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function removeExtraDataFromAMessageRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $channel_type = array_key_exists('channel_type', $associative_array) ? $associative_array['channel_type'] : null;
        $channel_url = array_key_exists('channel_url', $associative_array) ? $associative_array['channel_url'] : null;
        $message_id = array_key_exists('message_id', $associative_array) ? $associative_array['message_id'] : null;
        $keys = array_key_exists('keys', $associative_array) ? $associative_array['keys'] : null;
        $api_token = array_key_exists('api_token', $associative_array) ? $associative_array['api_token'] : null;

        // verify the required parameter 'channel_type' is set
        if ($channel_type === null || (is_array($channel_type) && count($channel_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel_type when calling removeExtraDataFromAMessage'
            );
        }
        // verify the required parameter 'channel_url' is set
        if ($channel_url === null || (is_array($channel_url) && count($channel_url) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel_url when calling removeExtraDataFromAMessage'
            );
        }
        // verify the required parameter 'message_id' is set
        if ($message_id === null || (is_array($message_id) && count($message_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $message_id when calling removeExtraDataFromAMessage'
            );
        }

        $resourcePath = '/v3/{channel_type}/{channel_url}/messages/{message_id}/sorted_metaarray';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $keys,
            'keys', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($api_token !== null) {
            $headerParams['api-token'] = ObjectSerializer::toHeaderValue($api_token);
        }

        // path params
        if ($channel_type !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_type' . '}',
                ObjectSerializer::toPathValue($channel_type),
                $resourcePath
            );
        }
        // path params
        if ($channel_url !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_url' . '}',
                ObjectSerializer::toPathValue($channel_url),
                $resourcePath
            );
        }
        // path params
        if ($message_id !== null) {
            $resourcePath = str_replace(
                '{' . 'message_id' . '}',
                ObjectSerializer::toPathValue($message_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation sendAMessage
     *
     * Send a message
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_type (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token api_token (optional)
     * @param  \Sendbird\Model\SendAMessageRequest $send_a_message_request send_a_message_request (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sendbird\Model\SendbirdMessageResponse
     */
    public function sendAMessage($associative_array)
    {
        list($response) = $this->sendAMessageWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation sendAMessageWithHttpInfo
     *
     * Send a message
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_type (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\SendAMessageRequest $send_a_message_request (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sendbird\Model\SendbirdMessageResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function sendAMessageWithHttpInfo($associative_array)
    {
        $request = $this->sendAMessageRequest($associative_array);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Sendbird\Model\SendbirdMessageResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sendbird\Model\SendbirdMessageResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sendbird\Model\SendbirdMessageResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sendbird\Model\SendbirdMessageResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sendbird\Model\SendbirdMessageResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation sendAMessageAsync
     *
     * Send a message
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_type (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\SendAMessageRequest $send_a_message_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sendAMessageAsync($associative_array)
    {
        return $this->sendAMessageAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation sendAMessageAsyncWithHttpInfo
     *
     * Send a message
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_type (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\SendAMessageRequest $send_a_message_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sendAMessageAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\Sendbird\Model\SendbirdMessageResponse';
        $request = $this->sendAMessageRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'sendAMessage'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_type (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\SendAMessageRequest $send_a_message_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function sendAMessageRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $channel_type = array_key_exists('channel_type', $associative_array) ? $associative_array['channel_type'] : null;
        $channel_url = array_key_exists('channel_url', $associative_array) ? $associative_array['channel_url'] : null;
        $api_token = array_key_exists('api_token', $associative_array) ? $associative_array['api_token'] : null;
        $send_a_message_request = array_key_exists('send_a_message_request', $associative_array) ? $associative_array['send_a_message_request'] : null;

        // verify the required parameter 'channel_type' is set
        if ($channel_type === null || (is_array($channel_type) && count($channel_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel_type when calling sendAMessage'
            );
        }
        // verify the required parameter 'channel_url' is set
        if ($channel_url === null || (is_array($channel_url) && count($channel_url) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel_url when calling sendAMessage'
            );
        }

        $resourcePath = '/v3/{channel_type}/{channel_url}/messages';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($api_token !== null) {
            $headerParams['api-token'] = ObjectSerializer::toHeaderValue($api_token);
        }

        // path params
        if ($channel_type !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_type' . '}',
                ObjectSerializer::toPathValue($channel_type),
                $resourcePath
            );
        }
        // path params
        if ($channel_url !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_url' . '}',
                ObjectSerializer::toPathValue($channel_url),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($send_a_message_request)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($send_a_message_request));
            } else {
                $httpBody = $send_a_message_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateAMessage
     *
     * Update a message
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_type (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  string $message_id (Required) (required)
     * @param  string $api_token api_token (optional)
     * @param  \Sendbird\Model\UpdateAMessageRequest $update_a_message_request update_a_message_request (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sendbird\Model\SendbirdMessageResponse
     */
    public function updateAMessage($associative_array)
    {
        list($response) = $this->updateAMessageWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation updateAMessageWithHttpInfo
     *
     * Update a message
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_type (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  string $message_id (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\UpdateAMessageRequest $update_a_message_request (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sendbird\Model\SendbirdMessageResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateAMessageWithHttpInfo($associative_array)
    {
        $request = $this->updateAMessageRequest($associative_array);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Sendbird\Model\SendbirdMessageResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sendbird\Model\SendbirdMessageResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sendbird\Model\SendbirdMessageResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sendbird\Model\SendbirdMessageResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sendbird\Model\SendbirdMessageResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateAMessageAsync
     *
     * Update a message
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_type (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  string $message_id (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\UpdateAMessageRequest $update_a_message_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateAMessageAsync($associative_array)
    {
        return $this->updateAMessageAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateAMessageAsyncWithHttpInfo
     *
     * Update a message
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_type (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  string $message_id (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\UpdateAMessageRequest $update_a_message_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateAMessageAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\Sendbird\Model\SendbirdMessageResponse';
        $request = $this->updateAMessageRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateAMessage'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_type (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  string $message_id (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\UpdateAMessageRequest $update_a_message_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateAMessageRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $channel_type = array_key_exists('channel_type', $associative_array) ? $associative_array['channel_type'] : null;
        $channel_url = array_key_exists('channel_url', $associative_array) ? $associative_array['channel_url'] : null;
        $message_id = array_key_exists('message_id', $associative_array) ? $associative_array['message_id'] : null;
        $api_token = array_key_exists('api_token', $associative_array) ? $associative_array['api_token'] : null;
        $update_a_message_request = array_key_exists('update_a_message_request', $associative_array) ? $associative_array['update_a_message_request'] : null;

        // verify the required parameter 'channel_type' is set
        if ($channel_type === null || (is_array($channel_type) && count($channel_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel_type when calling updateAMessage'
            );
        }
        // verify the required parameter 'channel_url' is set
        if ($channel_url === null || (is_array($channel_url) && count($channel_url) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel_url when calling updateAMessage'
            );
        }
        // verify the required parameter 'message_id' is set
        if ($message_id === null || (is_array($message_id) && count($message_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $message_id when calling updateAMessage'
            );
        }

        $resourcePath = '/v3/{channel_type}/{channel_url}/messages/{message_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($api_token !== null) {
            $headerParams['api-token'] = ObjectSerializer::toHeaderValue($api_token);
        }

        // path params
        if ($channel_type !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_type' . '}',
                ObjectSerializer::toPathValue($channel_type),
                $resourcePath
            );
        }
        // path params
        if ($channel_url !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_url' . '}',
                ObjectSerializer::toPathValue($channel_url),
                $resourcePath
            );
        }
        // path params
        if ($message_id !== null) {
            $resourcePath = str_replace(
                '{' . 'message_id' . '}',
                ObjectSerializer::toPathValue($message_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($update_a_message_request)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($update_a_message_request));
            } else {
                $httpBody = $update_a_message_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateExtraDataInAMessage
     *
     * Update extra data in a message
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_type (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  string $message_id (Required) (required)
     * @param  string $api_token api_token (optional)
     * @param  \Sendbird\Model\UpdateExtraDataInAMessageRequest $update_extra_data_in_a_message_request update_extra_data_in_a_message_request (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sendbird\Model\UpdateExtraDataInAMessageResponse
     */
    public function updateExtraDataInAMessage($associative_array)
    {
        list($response) = $this->updateExtraDataInAMessageWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation updateExtraDataInAMessageWithHttpInfo
     *
     * Update extra data in a message
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_type (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  string $message_id (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\UpdateExtraDataInAMessageRequest $update_extra_data_in_a_message_request (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sendbird\Model\UpdateExtraDataInAMessageResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateExtraDataInAMessageWithHttpInfo($associative_array)
    {
        $request = $this->updateExtraDataInAMessageRequest($associative_array);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Sendbird\Model\UpdateExtraDataInAMessageResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sendbird\Model\UpdateExtraDataInAMessageResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sendbird\Model\UpdateExtraDataInAMessageResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sendbird\Model\UpdateExtraDataInAMessageResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sendbird\Model\UpdateExtraDataInAMessageResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateExtraDataInAMessageAsync
     *
     * Update extra data in a message
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_type (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  string $message_id (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\UpdateExtraDataInAMessageRequest $update_extra_data_in_a_message_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateExtraDataInAMessageAsync($associative_array)
    {
        return $this->updateExtraDataInAMessageAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateExtraDataInAMessageAsyncWithHttpInfo
     *
     * Update extra data in a message
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_type (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  string $message_id (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\UpdateExtraDataInAMessageRequest $update_extra_data_in_a_message_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateExtraDataInAMessageAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\Sendbird\Model\UpdateExtraDataInAMessageResponse';
        $request = $this->updateExtraDataInAMessageRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateExtraDataInAMessage'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $channel_type (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  string $message_id (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\UpdateExtraDataInAMessageRequest $update_extra_data_in_a_message_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateExtraDataInAMessageRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $channel_type = array_key_exists('channel_type', $associative_array) ? $associative_array['channel_type'] : null;
        $channel_url = array_key_exists('channel_url', $associative_array) ? $associative_array['channel_url'] : null;
        $message_id = array_key_exists('message_id', $associative_array) ? $associative_array['message_id'] : null;
        $api_token = array_key_exists('api_token', $associative_array) ? $associative_array['api_token'] : null;
        $update_extra_data_in_a_message_request = array_key_exists('update_extra_data_in_a_message_request', $associative_array) ? $associative_array['update_extra_data_in_a_message_request'] : null;

        // verify the required parameter 'channel_type' is set
        if ($channel_type === null || (is_array($channel_type) && count($channel_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel_type when calling updateExtraDataInAMessage'
            );
        }
        // verify the required parameter 'channel_url' is set
        if ($channel_url === null || (is_array($channel_url) && count($channel_url) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel_url when calling updateExtraDataInAMessage'
            );
        }
        // verify the required parameter 'message_id' is set
        if ($message_id === null || (is_array($message_id) && count($message_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $message_id when calling updateExtraDataInAMessage'
            );
        }

        $resourcePath = '/v3/{channel_type}/{channel_url}/messages/{message_id}/sorted_metaarray';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($api_token !== null) {
            $headerParams['api-token'] = ObjectSerializer::toHeaderValue($api_token);
        }

        // path params
        if ($channel_type !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_type' . '}',
                ObjectSerializer::toPathValue($channel_type),
                $resourcePath
            );
        }
        // path params
        if ($channel_url !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_url' . '}',
                ObjectSerializer::toPathValue($channel_url),
                $resourcePath
            );
        }
        // path params
        if ($message_id !== null) {
            $resourcePath = str_replace(
                '{' . 'message_id' . '}',
                ObjectSerializer::toPathValue($message_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($update_extra_data_in_a_message_request)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($update_extra_data_in_a_message_request));
            } else {
                $httpBody = $update_extra_data_in_a_message_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
