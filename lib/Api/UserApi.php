<?php
/**
 * UserApi
 * PHP version 7.4
 *
 * @category Class
 * @package  Sendbird
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Sendbird Platform SDK
 *
 * Sendbird Platform API SDK  [https://sendbird.com/docs/chat/v3/platform-api/getting-started/prepare-to-use-api](https://sendbird.com/docs/chat/v3/platform-api/getting-started/prepare-to-use-api)  Contact Support:   Name: Sendbird   Email: [support@sendbird.com](https://mailto:support@sendbird.com)
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@sendbird.com
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 6.0.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Sendbird\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Sendbird\ApiException;
use Sendbird\Configuration;
use Sendbird\HeaderSelector;
use Sendbird\ObjectSerializer;

/**
 * UserApi Class Doc Comment
 *
 * @category Class
 * @package  Sendbird
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class UserApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation addARegistrationOrDeviceToken
     *
     * Add a registration or device token
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $token_type (Required) (required)
     * @param  string $api_token api_token (optional)
     * @param  \Sendbird\Model\AddARegistrationOrDeviceTokenRequest $add_a_registration_or_device_token_request add_a_registration_or_device_token_request (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sendbird\Model\AddARegistrationOrDeviceTokenResponse
     */
    public function addARegistrationOrDeviceToken($associative_array)
    {
        list($response) = $this->addARegistrationOrDeviceTokenWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation addARegistrationOrDeviceTokenWithHttpInfo
     *
     * Add a registration or device token
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $token_type (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\AddARegistrationOrDeviceTokenRequest $add_a_registration_or_device_token_request (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sendbird\Model\AddARegistrationOrDeviceTokenResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function addARegistrationOrDeviceTokenWithHttpInfo($associative_array)
    {
        $request = $this->addARegistrationOrDeviceTokenRequest($associative_array);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Sendbird\Model\AddARegistrationOrDeviceTokenResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sendbird\Model\AddARegistrationOrDeviceTokenResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sendbird\Model\AddARegistrationOrDeviceTokenResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sendbird\Model\AddARegistrationOrDeviceTokenResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sendbird\Model\AddARegistrationOrDeviceTokenResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation addARegistrationOrDeviceTokenAsync
     *
     * Add a registration or device token
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $token_type (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\AddARegistrationOrDeviceTokenRequest $add_a_registration_or_device_token_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addARegistrationOrDeviceTokenAsync($associative_array)
    {
        return $this->addARegistrationOrDeviceTokenAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addARegistrationOrDeviceTokenAsyncWithHttpInfo
     *
     * Add a registration or device token
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $token_type (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\AddARegistrationOrDeviceTokenRequest $add_a_registration_or_device_token_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addARegistrationOrDeviceTokenAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\Sendbird\Model\AddARegistrationOrDeviceTokenResponse';
        $request = $this->addARegistrationOrDeviceTokenRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addARegistrationOrDeviceToken'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $token_type (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\AddARegistrationOrDeviceTokenRequest $add_a_registration_or_device_token_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function addARegistrationOrDeviceTokenRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $user_id = array_key_exists('user_id', $associative_array) ? $associative_array['user_id'] : null;
        $token_type = array_key_exists('token_type', $associative_array) ? $associative_array['token_type'] : null;
        $api_token = array_key_exists('api_token', $associative_array) ? $associative_array['api_token'] : null;
        $add_a_registration_or_device_token_request = array_key_exists('add_a_registration_or_device_token_request', $associative_array) ? $associative_array['add_a_registration_or_device_token_request'] : null;

        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_id when calling addARegistrationOrDeviceToken'
            );
        }
        // verify the required parameter 'token_type' is set
        if ($token_type === null || (is_array($token_type) && count($token_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token_type when calling addARegistrationOrDeviceToken'
            );
        }

        $resourcePath = '/v3/users/{user_id}/push/{token_type}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($api_token !== null) {
            $headerParams['api-token'] = ObjectSerializer::toHeaderValue($api_token);
        }

        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'user_id' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }
        // path params
        if ($token_type !== null) {
            $resourcePath = str_replace(
                '{' . 'token_type' . '}',
                ObjectSerializer::toPathValue($token_type),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($add_a_registration_or_device_token_request)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($add_a_registration_or_device_token_request));
            } else {
                $httpBody = $add_a_registration_or_device_token_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation chooseAPushNotificationContentTemplate
     *
     * Choose a push notification content template
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $api_token api_token (optional)
     * @param  \Sendbird\Model\ChooseAPushNotificationContentTemplateRequest $choose_a_push_notification_content_template_request choose_a_push_notification_content_template_request (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sendbird\Model\ChooseAPushNotificationContentTemplateResponse
     */
    public function chooseAPushNotificationContentTemplate($associative_array)
    {
        list($response) = $this->chooseAPushNotificationContentTemplateWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation chooseAPushNotificationContentTemplateWithHttpInfo
     *
     * Choose a push notification content template
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\ChooseAPushNotificationContentTemplateRequest $choose_a_push_notification_content_template_request (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sendbird\Model\ChooseAPushNotificationContentTemplateResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function chooseAPushNotificationContentTemplateWithHttpInfo($associative_array)
    {
        $request = $this->chooseAPushNotificationContentTemplateRequest($associative_array);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Sendbird\Model\ChooseAPushNotificationContentTemplateResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sendbird\Model\ChooseAPushNotificationContentTemplateResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sendbird\Model\ChooseAPushNotificationContentTemplateResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sendbird\Model\ChooseAPushNotificationContentTemplateResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sendbird\Model\ChooseAPushNotificationContentTemplateResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation chooseAPushNotificationContentTemplateAsync
     *
     * Choose a push notification content template
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\ChooseAPushNotificationContentTemplateRequest $choose_a_push_notification_content_template_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function chooseAPushNotificationContentTemplateAsync($associative_array)
    {
        return $this->chooseAPushNotificationContentTemplateAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation chooseAPushNotificationContentTemplateAsyncWithHttpInfo
     *
     * Choose a push notification content template
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\ChooseAPushNotificationContentTemplateRequest $choose_a_push_notification_content_template_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function chooseAPushNotificationContentTemplateAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\Sendbird\Model\ChooseAPushNotificationContentTemplateResponse';
        $request = $this->chooseAPushNotificationContentTemplateRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'chooseAPushNotificationContentTemplate'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\ChooseAPushNotificationContentTemplateRequest $choose_a_push_notification_content_template_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function chooseAPushNotificationContentTemplateRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $user_id = array_key_exists('user_id', $associative_array) ? $associative_array['user_id'] : null;
        $api_token = array_key_exists('api_token', $associative_array) ? $associative_array['api_token'] : null;
        $choose_a_push_notification_content_template_request = array_key_exists('choose_a_push_notification_content_template_request', $associative_array) ? $associative_array['choose_a_push_notification_content_template_request'] : null;

        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_id when calling chooseAPushNotificationContentTemplate'
            );
        }

        $resourcePath = '/v3/users/{user_id}/push/template';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($api_token !== null) {
            $headerParams['api-token'] = ObjectSerializer::toHeaderValue($api_token);
        }

        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'user_id' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($choose_a_push_notification_content_template_request)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($choose_a_push_notification_content_template_request));
            } else {
                $httpBody = $choose_a_push_notification_content_template_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createAUser
     *
     * Create a user
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $api_token api_token (optional)
     * @param  \Sendbird\Model\CreateAUserRequest $create_a_user_request create_a_user_request (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sendbird\Model\SendbirdUser
     */
    public function createAUser($associative_array)
    {
        list($response) = $this->createAUserWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation createAUserWithHttpInfo
     *
     * Create a user
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\CreateAUserRequest $create_a_user_request (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sendbird\Model\SendbirdUser, HTTP status code, HTTP response headers (array of strings)
     */
    public function createAUserWithHttpInfo($associative_array)
    {
        $request = $this->createAUserRequest($associative_array);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Sendbird\Model\SendbirdUser' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sendbird\Model\SendbirdUser' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sendbird\Model\SendbirdUser', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sendbird\Model\SendbirdUser';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sendbird\Model\SendbirdUser',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createAUserAsync
     *
     * Create a user
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\CreateAUserRequest $create_a_user_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAUserAsync($associative_array)
    {
        return $this->createAUserAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createAUserAsyncWithHttpInfo
     *
     * Create a user
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\CreateAUserRequest $create_a_user_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAUserAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\Sendbird\Model\SendbirdUser';
        $request = $this->createAUserRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createAUser'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\CreateAUserRequest $create_a_user_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createAUserRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $api_token = array_key_exists('api_token', $associative_array) ? $associative_array['api_token'] : null;
        $create_a_user_request = array_key_exists('create_a_user_request', $associative_array) ? $associative_array['create_a_user_request'] : null;


        $resourcePath = '/v3/users';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($api_token !== null) {
            $headerParams['api-token'] = ObjectSerializer::toHeaderValue($api_token);
        }



        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($create_a_user_request)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($create_a_user_request));
            } else {
                $httpBody = $create_a_user_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createUserToken
     *
     * Create user token
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $api_token api_token (optional)
     * @param  \Sendbird\Model\CreateUserTokenRequest $create_user_token_request create_user_token_request (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sendbird\Model\CreateUserTokenResponse
     */
    public function createUserToken($associative_array)
    {
        list($response) = $this->createUserTokenWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation createUserTokenWithHttpInfo
     *
     * Create user token
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\CreateUserTokenRequest $create_user_token_request (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sendbird\Model\CreateUserTokenResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createUserTokenWithHttpInfo($associative_array)
    {
        $request = $this->createUserTokenRequest($associative_array);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Sendbird\Model\CreateUserTokenResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sendbird\Model\CreateUserTokenResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sendbird\Model\CreateUserTokenResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sendbird\Model\CreateUserTokenResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sendbird\Model\CreateUserTokenResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createUserTokenAsync
     *
     * Create user token
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\CreateUserTokenRequest $create_user_token_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createUserTokenAsync($associative_array)
    {
        return $this->createUserTokenAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createUserTokenAsyncWithHttpInfo
     *
     * Create user token
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\CreateUserTokenRequest $create_user_token_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createUserTokenAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\Sendbird\Model\CreateUserTokenResponse';
        $request = $this->createUserTokenRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createUserToken'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\CreateUserTokenRequest $create_user_token_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createUserTokenRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $user_id = array_key_exists('user_id', $associative_array) ? $associative_array['user_id'] : null;
        $api_token = array_key_exists('api_token', $associative_array) ? $associative_array['api_token'] : null;
        $create_user_token_request = array_key_exists('create_user_token_request', $associative_array) ? $associative_array['create_user_token_request'] : null;

        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_id when calling createUserToken'
            );
        }

        $resourcePath = '/v3/users/{user_id}/token';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($api_token !== null) {
            $headerParams['api-token'] = ObjectSerializer::toHeaderValue($api_token);
        }

        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'user_id' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($create_user_token_request)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($create_user_token_request));
            } else {
                $httpBody = $create_user_token_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteAUser
     *
     * Delete a user
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $api_token api_token (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function deleteAUser($associative_array)
    {
        list($response) = $this->deleteAUserWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation deleteAUserWithHttpInfo
     *
     * Delete a user
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $api_token (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteAUserWithHttpInfo($associative_array)
    {
        $request = $this->deleteAUserRequest($associative_array);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteAUserAsync
     *
     * Delete a user
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAUserAsync($associative_array)
    {
        return $this->deleteAUserAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteAUserAsyncWithHttpInfo
     *
     * Delete a user
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAUserAsyncWithHttpInfo($associative_array)
    {
        $returnType = 'object';
        $request = $this->deleteAUserRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteAUser'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteAUserRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $user_id = array_key_exists('user_id', $associative_array) ? $associative_array['user_id'] : null;
        $api_token = array_key_exists('api_token', $associative_array) ? $associative_array['api_token'] : null;

        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_id when calling deleteAUser'
            );
        }

        $resourcePath = '/v3/users/{user_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($api_token !== null) {
            $headerParams['api-token'] = ObjectSerializer::toHeaderValue($api_token);
        }

        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'user_id' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getChannelInvitationPreference
     *
     * Get channel invitation preference
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $api_token api_token (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sendbird\Model\GetChannelInvitationPreferenceResponse
     */
    public function getChannelInvitationPreference($associative_array)
    {
        list($response) = $this->getChannelInvitationPreferenceWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation getChannelInvitationPreferenceWithHttpInfo
     *
     * Get channel invitation preference
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $api_token (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sendbird\Model\GetChannelInvitationPreferenceResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getChannelInvitationPreferenceWithHttpInfo($associative_array)
    {
        $request = $this->getChannelInvitationPreferenceRequest($associative_array);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Sendbird\Model\GetChannelInvitationPreferenceResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sendbird\Model\GetChannelInvitationPreferenceResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sendbird\Model\GetChannelInvitationPreferenceResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sendbird\Model\GetChannelInvitationPreferenceResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sendbird\Model\GetChannelInvitationPreferenceResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getChannelInvitationPreferenceAsync
     *
     * Get channel invitation preference
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getChannelInvitationPreferenceAsync($associative_array)
    {
        return $this->getChannelInvitationPreferenceAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getChannelInvitationPreferenceAsyncWithHttpInfo
     *
     * Get channel invitation preference
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getChannelInvitationPreferenceAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\Sendbird\Model\GetChannelInvitationPreferenceResponse';
        $request = $this->getChannelInvitationPreferenceRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getChannelInvitationPreference'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getChannelInvitationPreferenceRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $user_id = array_key_exists('user_id', $associative_array) ? $associative_array['user_id'] : null;
        $api_token = array_key_exists('api_token', $associative_array) ? $associative_array['api_token'] : null;

        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_id when calling getChannelInvitationPreference'
            );
        }

        $resourcePath = '/v3/users/{user_id}/channel_invitation_preference';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($api_token !== null) {
            $headerParams['api-token'] = ObjectSerializer::toHeaderValue($api_token);
        }

        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'user_id' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation leaveMyGroupChannels
     *
     * Leave my group channels
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $api_token api_token (optional)
     * @param  \Sendbird\Model\LeaveMyGroupChannelsRequest $leave_my_group_channels_request leave_my_group_channels_request (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function leaveMyGroupChannels($associative_array)
    {
        list($response) = $this->leaveMyGroupChannelsWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation leaveMyGroupChannelsWithHttpInfo
     *
     * Leave my group channels
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\LeaveMyGroupChannelsRequest $leave_my_group_channels_request (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function leaveMyGroupChannelsWithHttpInfo($associative_array)
    {
        $request = $this->leaveMyGroupChannelsRequest($associative_array);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation leaveMyGroupChannelsAsync
     *
     * Leave my group channels
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\LeaveMyGroupChannelsRequest $leave_my_group_channels_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function leaveMyGroupChannelsAsync($associative_array)
    {
        return $this->leaveMyGroupChannelsAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation leaveMyGroupChannelsAsyncWithHttpInfo
     *
     * Leave my group channels
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\LeaveMyGroupChannelsRequest $leave_my_group_channels_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function leaveMyGroupChannelsAsyncWithHttpInfo($associative_array)
    {
        $returnType = 'object';
        $request = $this->leaveMyGroupChannelsRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'leaveMyGroupChannels'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\LeaveMyGroupChannelsRequest $leave_my_group_channels_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function leaveMyGroupChannelsRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $user_id = array_key_exists('user_id', $associative_array) ? $associative_array['user_id'] : null;
        $api_token = array_key_exists('api_token', $associative_array) ? $associative_array['api_token'] : null;
        $leave_my_group_channels_request = array_key_exists('leave_my_group_channels_request', $associative_array) ? $associative_array['leave_my_group_channels_request'] : null;

        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_id when calling leaveMyGroupChannels'
            );
        }

        $resourcePath = '/v3/users/{user_id}/my_group_channels/leave';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($api_token !== null) {
            $headerParams['api-token'] = ObjectSerializer::toHeaderValue($api_token);
        }

        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'user_id' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($leave_my_group_channels_request)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($leave_my_group_channels_request));
            } else {
                $httpBody = $leave_my_group_channels_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listMyGroupChannels
     *
     * List my group channels
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $api_token api_token (required)
     * @param  string $token Specifies a page token that indicates the starting index of a chunk of results. If not specified, the index is set as 0. (optional)
     * @param  int $limit Specifies the number of results to return per page. Acceptable values are 1 to 100, inclusive. (Default: 10) (optional)
     * @param  string $distinct_mode distinct_mode (optional)
     * @param  string $public_mode public_mode (optional)
     * @param  string $super_mode super_mode (optional)
     * @param  int $created_after Restricts the search scope to only retrieve group channels which have been created after the specified time, in Unix milliseconds format. (optional)
     * @param  int $created_before Restricts the search scope to only retrieve group channels which have been created before the specified time, in Unix milliseconds format. (optional)
     * @param  bool $show_empty show_empty (optional)
     * @param  bool $show_member show_member (optional)
     * @param  bool $show_delivery_receipt show_delivery_receipt (optional)
     * @param  bool $show_read_receipt show_read_receipt (optional)
     * @param  bool $show_metadata show_metadata (optional)
     * @param  bool $show_frozen show_frozen (optional)
     * @param  string $order order (optional)
     * @param  string $metadata_order_key Specifies the key of an item in metadata. When a value of the order parameter is set to metadata_value_alphabetical, the results are alphabetically sorted by the value of the item specified by the key. (optional)
     * @param  string $custom_types Specifies a comma-separated string of one or more custom types to filter group channels. URL encoding each type is recommended. If not specified, all channels are returned, regardless of their custom type. (optional)
     * @param  string $custom_type_startswith Searches for group channels with the custom type which starts with the specified value. URL encoding the value is recommended. (optional)
     * @param  string $channel_urls Specifies a comma-separated string of one or more group channel URLs to restrict the search scope. URL encoding each channel URL is recommended. (optional)
     * @param  string $name Specifies one or more group channel names. (optional)
     * @param  string $name_contains Searches for group channels whose names contain the specified value. Note that this parameter is case-insensitive. URL encoding the value is recommended. (optional)
     * @param  string $name_startswith Searches for group channels whose names start with the specified value. Note that this parameter is case-insensitive. URL encoding the value is recommended. (optional)
     * @param  string $members_exactly_in Searches for group channels with all the specified users as members. The parameter value should consist of user IDs separated by commas.  Only user IDs that match those of existing users are used for channel search. URL encoding each ID is recommended. (optional)
     * @param  string $members_include_in Searches for group channels that include one or more users as members among the specified users. The value should consist of user IDs separated by commas or %2C. You can specify up to 60 user IDs.  Only user IDs that match those of existing users are used for channel search. URL encoding each ID is recommended. (optional)
     * @param  string $query_type Specifies a logical condition applied to the members_include_in parameter. Acceptable values are either AND or OR. For example, if you specify three members, A, B, and C, in members_include_in, the value of AND returns all channels that include every one of {A. B, C} as members. The value of OR returns channels that include {A}, plus those that include {B}, plus those that include {C}. (Default: AND) (optional)
     * @param  string $members_nickname Searches for group channels with members whose nicknames match the specified value. URL encoding the value is recommended. (optional)
     * @param  string $members_nickname_contains Searches for group channels with members whose nicknames contain the specified value. Note that this parameter is case-insensitive. URL encoding the value is recommended.  * We recommend using at least three characters for the parameter value for better search efficiency when you design and implement related features. If you would like to allow one or two characters for searching, use members_nickname instead to prevent performance issues. (optional)
     * @param  string $members_nickname_startswith Searches for group channels with members whose nicknames begin with the specified value. This parameter isn&#39;t case-sensitive. URL encoding the value is recommended. (optional)
     * @param  string $search_query Searches for group channels where the specified query string matches the channel name or the nickname of the member. This parameter isn&#39;t case-sensitive and should be specified in conjunction with the search_fields parameter below. URL encoding the value is recommended. (optional)
     * @param  string $search_fields Specifies a comma-separated string of one or more search fields to apply to the query, which restricts the results within the specified fields (OR search condition). Acceptable values are channel_name and member_nickname. This is effective only when the search_query parameter above is specified. (Default: channel_name, member_nickname together) (optional)
     * @param  string $metadata_key Searches for group channels with metadata containing an item with the specified value as its key. To use this parameter, either the metadata_values parameter or the metadata_value_startswith parameter should be specified. (optional)
     * @param  string $metadata_values Searches for group channels with metadata containing an item with the key specified by the metadata_key parameter, and the value of that item matches one or more values specified by this parameter. The string should be specified with multiple values separated by commas. URL encoding each value is recommended. To use this parameter, the metadata_key parameter should be specified. (optional)
     * @param  string $metadata_value_startswith Searches for group channels with metadata containing an item with the key specified by the metadata_key parameter, and the values of that item that start with the specified value of this parameter. URL encoding the value is recommended. To use this parameter, the metadata_key parameter should be specified. (optional)
     * @param  string $metacounter_key Searches for group channels with metacounter containing an item with the specified value as its key. To use this parameter, either the metacounter_values parameter or one of the metacounter_value_gt, metacounter_value_gte, metacounter_value_lt, and metacounter_value_lte parameters should be specified. (optional)
     * @param  string $metacounter_values Searches for group channels with metacounter containing an item with the key specified by the metadata_key parameter, where the value of that item is equal to one or more values specified by this parameter. The string should be specified with multiple values separated by commas. To use this parameter, the metacounter_key parameter should be specified. (optional)
     * @param  string $metacounter_value_gt Searches for group channels with metacounter containing an item with the key specified by the metadata_key parameter, where the value of that item is greater than the value specified by this parameter. To use this parameter, the metacounter_key parameter should be specified. (optional)
     * @param  string $metacounter_value_gte Searches for group channels with metacounter containing an item with the key specified by the metadata_key parameter, where the value of that item is greater than or equal to the value specified by this parameter. To use this parameter, the metacounter_key parameter should be specified. (optional)
     * @param  string $metacounter_value_lt Searches for group channels with metacounter containing an item with the key specified by the metadata_key parameter, where the value of that item is lower than the value specified by this parameter. To use this parameter, the metacounter_key parameter should be specified. (optional)
     * @param  string $metacounter_value_lte Searches for group channels with metacounter containing an item with the key specified by the metadata_key parameter, where the value of that item is lower than or equal to the value specified by this parameter. To use this parameter, the metacounter_key parameter should be specified. (optional)
     * @param  bool $include_sorted_metaarray_in_last_message Determines whether to include the sorted_metaarray as one of the last_message’s properties in the response. (optional)
     * @param  string $hidden_mode Restricts the search scope to group channels that match a specific hidden_status and operating behavior (optional)
     * @param  string $unread_filter Restricts the search scope to only retrieve group channels with one or more unread messages. This filter doesn&#39;t support Supergroup channels. Acceptable values are all and unread_message. (Default: all) (optional)
     * @param  string $member_state_filter member_state_filter (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sendbird\Model\ListMyGroupChannelsResponse
     */
    public function listMyGroupChannels($associative_array)
    {
        list($response) = $this->listMyGroupChannelsWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation listMyGroupChannelsWithHttpInfo
     *
     * List my group channels
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $api_token (required)
     * @param  string $token Specifies a page token that indicates the starting index of a chunk of results. If not specified, the index is set as 0. (optional)
     * @param  int $limit Specifies the number of results to return per page. Acceptable values are 1 to 100, inclusive. (Default: 10) (optional)
     * @param  string $distinct_mode (optional)
     * @param  string $public_mode (optional)
     * @param  string $super_mode (optional)
     * @param  int $created_after Restricts the search scope to only retrieve group channels which have been created after the specified time, in Unix milliseconds format. (optional)
     * @param  int $created_before Restricts the search scope to only retrieve group channels which have been created before the specified time, in Unix milliseconds format. (optional)
     * @param  bool $show_empty (optional)
     * @param  bool $show_member (optional)
     * @param  bool $show_delivery_receipt (optional)
     * @param  bool $show_read_receipt (optional)
     * @param  bool $show_metadata (optional)
     * @param  bool $show_frozen (optional)
     * @param  string $order (optional)
     * @param  string $metadata_order_key Specifies the key of an item in metadata. When a value of the order parameter is set to metadata_value_alphabetical, the results are alphabetically sorted by the value of the item specified by the key. (optional)
     * @param  string $custom_types Specifies a comma-separated string of one or more custom types to filter group channels. URL encoding each type is recommended. If not specified, all channels are returned, regardless of their custom type. (optional)
     * @param  string $custom_type_startswith Searches for group channels with the custom type which starts with the specified value. URL encoding the value is recommended. (optional)
     * @param  string $channel_urls Specifies a comma-separated string of one or more group channel URLs to restrict the search scope. URL encoding each channel URL is recommended. (optional)
     * @param  string $name Specifies one or more group channel names. (optional)
     * @param  string $name_contains Searches for group channels whose names contain the specified value. Note that this parameter is case-insensitive. URL encoding the value is recommended. (optional)
     * @param  string $name_startswith Searches for group channels whose names start with the specified value. Note that this parameter is case-insensitive. URL encoding the value is recommended. (optional)
     * @param  string $members_exactly_in Searches for group channels with all the specified users as members. The parameter value should consist of user IDs separated by commas.  Only user IDs that match those of existing users are used for channel search. URL encoding each ID is recommended. (optional)
     * @param  string $members_include_in Searches for group channels that include one or more users as members among the specified users. The value should consist of user IDs separated by commas or %2C. You can specify up to 60 user IDs.  Only user IDs that match those of existing users are used for channel search. URL encoding each ID is recommended. (optional)
     * @param  string $query_type Specifies a logical condition applied to the members_include_in parameter. Acceptable values are either AND or OR. For example, if you specify three members, A, B, and C, in members_include_in, the value of AND returns all channels that include every one of {A. B, C} as members. The value of OR returns channels that include {A}, plus those that include {B}, plus those that include {C}. (Default: AND) (optional)
     * @param  string $members_nickname Searches for group channels with members whose nicknames match the specified value. URL encoding the value is recommended. (optional)
     * @param  string $members_nickname_contains Searches for group channels with members whose nicknames contain the specified value. Note that this parameter is case-insensitive. URL encoding the value is recommended.  * We recommend using at least three characters for the parameter value for better search efficiency when you design and implement related features. If you would like to allow one or two characters for searching, use members_nickname instead to prevent performance issues. (optional)
     * @param  string $members_nickname_startswith Searches for group channels with members whose nicknames begin with the specified value. This parameter isn&#39;t case-sensitive. URL encoding the value is recommended. (optional)
     * @param  string $search_query Searches for group channels where the specified query string matches the channel name or the nickname of the member. This parameter isn&#39;t case-sensitive and should be specified in conjunction with the search_fields parameter below. URL encoding the value is recommended. (optional)
     * @param  string $search_fields Specifies a comma-separated string of one or more search fields to apply to the query, which restricts the results within the specified fields (OR search condition). Acceptable values are channel_name and member_nickname. This is effective only when the search_query parameter above is specified. (Default: channel_name, member_nickname together) (optional)
     * @param  string $metadata_key Searches for group channels with metadata containing an item with the specified value as its key. To use this parameter, either the metadata_values parameter or the metadata_value_startswith parameter should be specified. (optional)
     * @param  string $metadata_values Searches for group channels with metadata containing an item with the key specified by the metadata_key parameter, and the value of that item matches one or more values specified by this parameter. The string should be specified with multiple values separated by commas. URL encoding each value is recommended. To use this parameter, the metadata_key parameter should be specified. (optional)
     * @param  string $metadata_value_startswith Searches for group channels with metadata containing an item with the key specified by the metadata_key parameter, and the values of that item that start with the specified value of this parameter. URL encoding the value is recommended. To use this parameter, the metadata_key parameter should be specified. (optional)
     * @param  string $metacounter_key Searches for group channels with metacounter containing an item with the specified value as its key. To use this parameter, either the metacounter_values parameter or one of the metacounter_value_gt, metacounter_value_gte, metacounter_value_lt, and metacounter_value_lte parameters should be specified. (optional)
     * @param  string $metacounter_values Searches for group channels with metacounter containing an item with the key specified by the metadata_key parameter, where the value of that item is equal to one or more values specified by this parameter. The string should be specified with multiple values separated by commas. To use this parameter, the metacounter_key parameter should be specified. (optional)
     * @param  string $metacounter_value_gt Searches for group channels with metacounter containing an item with the key specified by the metadata_key parameter, where the value of that item is greater than the value specified by this parameter. To use this parameter, the metacounter_key parameter should be specified. (optional)
     * @param  string $metacounter_value_gte Searches for group channels with metacounter containing an item with the key specified by the metadata_key parameter, where the value of that item is greater than or equal to the value specified by this parameter. To use this parameter, the metacounter_key parameter should be specified. (optional)
     * @param  string $metacounter_value_lt Searches for group channels with metacounter containing an item with the key specified by the metadata_key parameter, where the value of that item is lower than the value specified by this parameter. To use this parameter, the metacounter_key parameter should be specified. (optional)
     * @param  string $metacounter_value_lte Searches for group channels with metacounter containing an item with the key specified by the metadata_key parameter, where the value of that item is lower than or equal to the value specified by this parameter. To use this parameter, the metacounter_key parameter should be specified. (optional)
     * @param  bool $include_sorted_metaarray_in_last_message Determines whether to include the sorted_metaarray as one of the last_message’s properties in the response. (optional)
     * @param  string $hidden_mode Restricts the search scope to group channels that match a specific hidden_status and operating behavior (optional)
     * @param  string $unread_filter Restricts the search scope to only retrieve group channels with one or more unread messages. This filter doesn&#39;t support Supergroup channels. Acceptable values are all and unread_message. (Default: all) (optional)
     * @param  string $member_state_filter (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sendbird\Model\ListMyGroupChannelsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listMyGroupChannelsWithHttpInfo($associative_array)
    {
        $request = $this->listMyGroupChannelsRequest($associative_array);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Sendbird\Model\ListMyGroupChannelsResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sendbird\Model\ListMyGroupChannelsResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sendbird\Model\ListMyGroupChannelsResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sendbird\Model\ListMyGroupChannelsResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sendbird\Model\ListMyGroupChannelsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listMyGroupChannelsAsync
     *
     * List my group channels
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $api_token (required)
     * @param  string $token Specifies a page token that indicates the starting index of a chunk of results. If not specified, the index is set as 0. (optional)
     * @param  int $limit Specifies the number of results to return per page. Acceptable values are 1 to 100, inclusive. (Default: 10) (optional)
     * @param  string $distinct_mode (optional)
     * @param  string $public_mode (optional)
     * @param  string $super_mode (optional)
     * @param  int $created_after Restricts the search scope to only retrieve group channels which have been created after the specified time, in Unix milliseconds format. (optional)
     * @param  int $created_before Restricts the search scope to only retrieve group channels which have been created before the specified time, in Unix milliseconds format. (optional)
     * @param  bool $show_empty (optional)
     * @param  bool $show_member (optional)
     * @param  bool $show_delivery_receipt (optional)
     * @param  bool $show_read_receipt (optional)
     * @param  bool $show_metadata (optional)
     * @param  bool $show_frozen (optional)
     * @param  string $order (optional)
     * @param  string $metadata_order_key Specifies the key of an item in metadata. When a value of the order parameter is set to metadata_value_alphabetical, the results are alphabetically sorted by the value of the item specified by the key. (optional)
     * @param  string $custom_types Specifies a comma-separated string of one or more custom types to filter group channels. URL encoding each type is recommended. If not specified, all channels are returned, regardless of their custom type. (optional)
     * @param  string $custom_type_startswith Searches for group channels with the custom type which starts with the specified value. URL encoding the value is recommended. (optional)
     * @param  string $channel_urls Specifies a comma-separated string of one or more group channel URLs to restrict the search scope. URL encoding each channel URL is recommended. (optional)
     * @param  string $name Specifies one or more group channel names. (optional)
     * @param  string $name_contains Searches for group channels whose names contain the specified value. Note that this parameter is case-insensitive. URL encoding the value is recommended. (optional)
     * @param  string $name_startswith Searches for group channels whose names start with the specified value. Note that this parameter is case-insensitive. URL encoding the value is recommended. (optional)
     * @param  string $members_exactly_in Searches for group channels with all the specified users as members. The parameter value should consist of user IDs separated by commas.  Only user IDs that match those of existing users are used for channel search. URL encoding each ID is recommended. (optional)
     * @param  string $members_include_in Searches for group channels that include one or more users as members among the specified users. The value should consist of user IDs separated by commas or %2C. You can specify up to 60 user IDs.  Only user IDs that match those of existing users are used for channel search. URL encoding each ID is recommended. (optional)
     * @param  string $query_type Specifies a logical condition applied to the members_include_in parameter. Acceptable values are either AND or OR. For example, if you specify three members, A, B, and C, in members_include_in, the value of AND returns all channels that include every one of {A. B, C} as members. The value of OR returns channels that include {A}, plus those that include {B}, plus those that include {C}. (Default: AND) (optional)
     * @param  string $members_nickname Searches for group channels with members whose nicknames match the specified value. URL encoding the value is recommended. (optional)
     * @param  string $members_nickname_contains Searches for group channels with members whose nicknames contain the specified value. Note that this parameter is case-insensitive. URL encoding the value is recommended.  * We recommend using at least three characters for the parameter value for better search efficiency when you design and implement related features. If you would like to allow one or two characters for searching, use members_nickname instead to prevent performance issues. (optional)
     * @param  string $members_nickname_startswith Searches for group channels with members whose nicknames begin with the specified value. This parameter isn&#39;t case-sensitive. URL encoding the value is recommended. (optional)
     * @param  string $search_query Searches for group channels where the specified query string matches the channel name or the nickname of the member. This parameter isn&#39;t case-sensitive and should be specified in conjunction with the search_fields parameter below. URL encoding the value is recommended. (optional)
     * @param  string $search_fields Specifies a comma-separated string of one or more search fields to apply to the query, which restricts the results within the specified fields (OR search condition). Acceptable values are channel_name and member_nickname. This is effective only when the search_query parameter above is specified. (Default: channel_name, member_nickname together) (optional)
     * @param  string $metadata_key Searches for group channels with metadata containing an item with the specified value as its key. To use this parameter, either the metadata_values parameter or the metadata_value_startswith parameter should be specified. (optional)
     * @param  string $metadata_values Searches for group channels with metadata containing an item with the key specified by the metadata_key parameter, and the value of that item matches one or more values specified by this parameter. The string should be specified with multiple values separated by commas. URL encoding each value is recommended. To use this parameter, the metadata_key parameter should be specified. (optional)
     * @param  string $metadata_value_startswith Searches for group channels with metadata containing an item with the key specified by the metadata_key parameter, and the values of that item that start with the specified value of this parameter. URL encoding the value is recommended. To use this parameter, the metadata_key parameter should be specified. (optional)
     * @param  string $metacounter_key Searches for group channels with metacounter containing an item with the specified value as its key. To use this parameter, either the metacounter_values parameter or one of the metacounter_value_gt, metacounter_value_gte, metacounter_value_lt, and metacounter_value_lte parameters should be specified. (optional)
     * @param  string $metacounter_values Searches for group channels with metacounter containing an item with the key specified by the metadata_key parameter, where the value of that item is equal to one or more values specified by this parameter. The string should be specified with multiple values separated by commas. To use this parameter, the metacounter_key parameter should be specified. (optional)
     * @param  string $metacounter_value_gt Searches for group channels with metacounter containing an item with the key specified by the metadata_key parameter, where the value of that item is greater than the value specified by this parameter. To use this parameter, the metacounter_key parameter should be specified. (optional)
     * @param  string $metacounter_value_gte Searches for group channels with metacounter containing an item with the key specified by the metadata_key parameter, where the value of that item is greater than or equal to the value specified by this parameter. To use this parameter, the metacounter_key parameter should be specified. (optional)
     * @param  string $metacounter_value_lt Searches for group channels with metacounter containing an item with the key specified by the metadata_key parameter, where the value of that item is lower than the value specified by this parameter. To use this parameter, the metacounter_key parameter should be specified. (optional)
     * @param  string $metacounter_value_lte Searches for group channels with metacounter containing an item with the key specified by the metadata_key parameter, where the value of that item is lower than or equal to the value specified by this parameter. To use this parameter, the metacounter_key parameter should be specified. (optional)
     * @param  bool $include_sorted_metaarray_in_last_message Determines whether to include the sorted_metaarray as one of the last_message’s properties in the response. (optional)
     * @param  string $hidden_mode Restricts the search scope to group channels that match a specific hidden_status and operating behavior (optional)
     * @param  string $unread_filter Restricts the search scope to only retrieve group channels with one or more unread messages. This filter doesn&#39;t support Supergroup channels. Acceptable values are all and unread_message. (Default: all) (optional)
     * @param  string $member_state_filter (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listMyGroupChannelsAsync($associative_array)
    {
        return $this->listMyGroupChannelsAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listMyGroupChannelsAsyncWithHttpInfo
     *
     * List my group channels
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $api_token (required)
     * @param  string $token Specifies a page token that indicates the starting index of a chunk of results. If not specified, the index is set as 0. (optional)
     * @param  int $limit Specifies the number of results to return per page. Acceptable values are 1 to 100, inclusive. (Default: 10) (optional)
     * @param  string $distinct_mode (optional)
     * @param  string $public_mode (optional)
     * @param  string $super_mode (optional)
     * @param  int $created_after Restricts the search scope to only retrieve group channels which have been created after the specified time, in Unix milliseconds format. (optional)
     * @param  int $created_before Restricts the search scope to only retrieve group channels which have been created before the specified time, in Unix milliseconds format. (optional)
     * @param  bool $show_empty (optional)
     * @param  bool $show_member (optional)
     * @param  bool $show_delivery_receipt (optional)
     * @param  bool $show_read_receipt (optional)
     * @param  bool $show_metadata (optional)
     * @param  bool $show_frozen (optional)
     * @param  string $order (optional)
     * @param  string $metadata_order_key Specifies the key of an item in metadata. When a value of the order parameter is set to metadata_value_alphabetical, the results are alphabetically sorted by the value of the item specified by the key. (optional)
     * @param  string $custom_types Specifies a comma-separated string of one or more custom types to filter group channels. URL encoding each type is recommended. If not specified, all channels are returned, regardless of their custom type. (optional)
     * @param  string $custom_type_startswith Searches for group channels with the custom type which starts with the specified value. URL encoding the value is recommended. (optional)
     * @param  string $channel_urls Specifies a comma-separated string of one or more group channel URLs to restrict the search scope. URL encoding each channel URL is recommended. (optional)
     * @param  string $name Specifies one or more group channel names. (optional)
     * @param  string $name_contains Searches for group channels whose names contain the specified value. Note that this parameter is case-insensitive. URL encoding the value is recommended. (optional)
     * @param  string $name_startswith Searches for group channels whose names start with the specified value. Note that this parameter is case-insensitive. URL encoding the value is recommended. (optional)
     * @param  string $members_exactly_in Searches for group channels with all the specified users as members. The parameter value should consist of user IDs separated by commas.  Only user IDs that match those of existing users are used for channel search. URL encoding each ID is recommended. (optional)
     * @param  string $members_include_in Searches for group channels that include one or more users as members among the specified users. The value should consist of user IDs separated by commas or %2C. You can specify up to 60 user IDs.  Only user IDs that match those of existing users are used for channel search. URL encoding each ID is recommended. (optional)
     * @param  string $query_type Specifies a logical condition applied to the members_include_in parameter. Acceptable values are either AND or OR. For example, if you specify three members, A, B, and C, in members_include_in, the value of AND returns all channels that include every one of {A. B, C} as members. The value of OR returns channels that include {A}, plus those that include {B}, plus those that include {C}. (Default: AND) (optional)
     * @param  string $members_nickname Searches for group channels with members whose nicknames match the specified value. URL encoding the value is recommended. (optional)
     * @param  string $members_nickname_contains Searches for group channels with members whose nicknames contain the specified value. Note that this parameter is case-insensitive. URL encoding the value is recommended.  * We recommend using at least three characters for the parameter value for better search efficiency when you design and implement related features. If you would like to allow one or two characters for searching, use members_nickname instead to prevent performance issues. (optional)
     * @param  string $members_nickname_startswith Searches for group channels with members whose nicknames begin with the specified value. This parameter isn&#39;t case-sensitive. URL encoding the value is recommended. (optional)
     * @param  string $search_query Searches for group channels where the specified query string matches the channel name or the nickname of the member. This parameter isn&#39;t case-sensitive and should be specified in conjunction with the search_fields parameter below. URL encoding the value is recommended. (optional)
     * @param  string $search_fields Specifies a comma-separated string of one or more search fields to apply to the query, which restricts the results within the specified fields (OR search condition). Acceptable values are channel_name and member_nickname. This is effective only when the search_query parameter above is specified. (Default: channel_name, member_nickname together) (optional)
     * @param  string $metadata_key Searches for group channels with metadata containing an item with the specified value as its key. To use this parameter, either the metadata_values parameter or the metadata_value_startswith parameter should be specified. (optional)
     * @param  string $metadata_values Searches for group channels with metadata containing an item with the key specified by the metadata_key parameter, and the value of that item matches one or more values specified by this parameter. The string should be specified with multiple values separated by commas. URL encoding each value is recommended. To use this parameter, the metadata_key parameter should be specified. (optional)
     * @param  string $metadata_value_startswith Searches for group channels with metadata containing an item with the key specified by the metadata_key parameter, and the values of that item that start with the specified value of this parameter. URL encoding the value is recommended. To use this parameter, the metadata_key parameter should be specified. (optional)
     * @param  string $metacounter_key Searches for group channels with metacounter containing an item with the specified value as its key. To use this parameter, either the metacounter_values parameter or one of the metacounter_value_gt, metacounter_value_gte, metacounter_value_lt, and metacounter_value_lte parameters should be specified. (optional)
     * @param  string $metacounter_values Searches for group channels with metacounter containing an item with the key specified by the metadata_key parameter, where the value of that item is equal to one or more values specified by this parameter. The string should be specified with multiple values separated by commas. To use this parameter, the metacounter_key parameter should be specified. (optional)
     * @param  string $metacounter_value_gt Searches for group channels with metacounter containing an item with the key specified by the metadata_key parameter, where the value of that item is greater than the value specified by this parameter. To use this parameter, the metacounter_key parameter should be specified. (optional)
     * @param  string $metacounter_value_gte Searches for group channels with metacounter containing an item with the key specified by the metadata_key parameter, where the value of that item is greater than or equal to the value specified by this parameter. To use this parameter, the metacounter_key parameter should be specified. (optional)
     * @param  string $metacounter_value_lt Searches for group channels with metacounter containing an item with the key specified by the metadata_key parameter, where the value of that item is lower than the value specified by this parameter. To use this parameter, the metacounter_key parameter should be specified. (optional)
     * @param  string $metacounter_value_lte Searches for group channels with metacounter containing an item with the key specified by the metadata_key parameter, where the value of that item is lower than or equal to the value specified by this parameter. To use this parameter, the metacounter_key parameter should be specified. (optional)
     * @param  bool $include_sorted_metaarray_in_last_message Determines whether to include the sorted_metaarray as one of the last_message’s properties in the response. (optional)
     * @param  string $hidden_mode Restricts the search scope to group channels that match a specific hidden_status and operating behavior (optional)
     * @param  string $unread_filter Restricts the search scope to only retrieve group channels with one or more unread messages. This filter doesn&#39;t support Supergroup channels. Acceptable values are all and unread_message. (Default: all) (optional)
     * @param  string $member_state_filter (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listMyGroupChannelsAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\Sendbird\Model\ListMyGroupChannelsResponse';
        $request = $this->listMyGroupChannelsRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listMyGroupChannels'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $api_token (required)
     * @param  string $token Specifies a page token that indicates the starting index of a chunk of results. If not specified, the index is set as 0. (optional)
     * @param  int $limit Specifies the number of results to return per page. Acceptable values are 1 to 100, inclusive. (Default: 10) (optional)
     * @param  string $distinct_mode (optional)
     * @param  string $public_mode (optional)
     * @param  string $super_mode (optional)
     * @param  int $created_after Restricts the search scope to only retrieve group channels which have been created after the specified time, in Unix milliseconds format. (optional)
     * @param  int $created_before Restricts the search scope to only retrieve group channels which have been created before the specified time, in Unix milliseconds format. (optional)
     * @param  bool $show_empty (optional)
     * @param  bool $show_member (optional)
     * @param  bool $show_delivery_receipt (optional)
     * @param  bool $show_read_receipt (optional)
     * @param  bool $show_metadata (optional)
     * @param  bool $show_frozen (optional)
     * @param  string $order (optional)
     * @param  string $metadata_order_key Specifies the key of an item in metadata. When a value of the order parameter is set to metadata_value_alphabetical, the results are alphabetically sorted by the value of the item specified by the key. (optional)
     * @param  string $custom_types Specifies a comma-separated string of one or more custom types to filter group channels. URL encoding each type is recommended. If not specified, all channels are returned, regardless of their custom type. (optional)
     * @param  string $custom_type_startswith Searches for group channels with the custom type which starts with the specified value. URL encoding the value is recommended. (optional)
     * @param  string $channel_urls Specifies a comma-separated string of one or more group channel URLs to restrict the search scope. URL encoding each channel URL is recommended. (optional)
     * @param  string $name Specifies one or more group channel names. (optional)
     * @param  string $name_contains Searches for group channels whose names contain the specified value. Note that this parameter is case-insensitive. URL encoding the value is recommended. (optional)
     * @param  string $name_startswith Searches for group channels whose names start with the specified value. Note that this parameter is case-insensitive. URL encoding the value is recommended. (optional)
     * @param  string $members_exactly_in Searches for group channels with all the specified users as members. The parameter value should consist of user IDs separated by commas.  Only user IDs that match those of existing users are used for channel search. URL encoding each ID is recommended. (optional)
     * @param  string $members_include_in Searches for group channels that include one or more users as members among the specified users. The value should consist of user IDs separated by commas or %2C. You can specify up to 60 user IDs.  Only user IDs that match those of existing users are used for channel search. URL encoding each ID is recommended. (optional)
     * @param  string $query_type Specifies a logical condition applied to the members_include_in parameter. Acceptable values are either AND or OR. For example, if you specify three members, A, B, and C, in members_include_in, the value of AND returns all channels that include every one of {A. B, C} as members. The value of OR returns channels that include {A}, plus those that include {B}, plus those that include {C}. (Default: AND) (optional)
     * @param  string $members_nickname Searches for group channels with members whose nicknames match the specified value. URL encoding the value is recommended. (optional)
     * @param  string $members_nickname_contains Searches for group channels with members whose nicknames contain the specified value. Note that this parameter is case-insensitive. URL encoding the value is recommended.  * We recommend using at least three characters for the parameter value for better search efficiency when you design and implement related features. If you would like to allow one or two characters for searching, use members_nickname instead to prevent performance issues. (optional)
     * @param  string $members_nickname_startswith Searches for group channels with members whose nicknames begin with the specified value. This parameter isn&#39;t case-sensitive. URL encoding the value is recommended. (optional)
     * @param  string $search_query Searches for group channels where the specified query string matches the channel name or the nickname of the member. This parameter isn&#39;t case-sensitive and should be specified in conjunction with the search_fields parameter below. URL encoding the value is recommended. (optional)
     * @param  string $search_fields Specifies a comma-separated string of one or more search fields to apply to the query, which restricts the results within the specified fields (OR search condition). Acceptable values are channel_name and member_nickname. This is effective only when the search_query parameter above is specified. (Default: channel_name, member_nickname together) (optional)
     * @param  string $metadata_key Searches for group channels with metadata containing an item with the specified value as its key. To use this parameter, either the metadata_values parameter or the metadata_value_startswith parameter should be specified. (optional)
     * @param  string $metadata_values Searches for group channels with metadata containing an item with the key specified by the metadata_key parameter, and the value of that item matches one or more values specified by this parameter. The string should be specified with multiple values separated by commas. URL encoding each value is recommended. To use this parameter, the metadata_key parameter should be specified. (optional)
     * @param  string $metadata_value_startswith Searches for group channels with metadata containing an item with the key specified by the metadata_key parameter, and the values of that item that start with the specified value of this parameter. URL encoding the value is recommended. To use this parameter, the metadata_key parameter should be specified. (optional)
     * @param  string $metacounter_key Searches for group channels with metacounter containing an item with the specified value as its key. To use this parameter, either the metacounter_values parameter or one of the metacounter_value_gt, metacounter_value_gte, metacounter_value_lt, and metacounter_value_lte parameters should be specified. (optional)
     * @param  string $metacounter_values Searches for group channels with metacounter containing an item with the key specified by the metadata_key parameter, where the value of that item is equal to one or more values specified by this parameter. The string should be specified with multiple values separated by commas. To use this parameter, the metacounter_key parameter should be specified. (optional)
     * @param  string $metacounter_value_gt Searches for group channels with metacounter containing an item with the key specified by the metadata_key parameter, where the value of that item is greater than the value specified by this parameter. To use this parameter, the metacounter_key parameter should be specified. (optional)
     * @param  string $metacounter_value_gte Searches for group channels with metacounter containing an item with the key specified by the metadata_key parameter, where the value of that item is greater than or equal to the value specified by this parameter. To use this parameter, the metacounter_key parameter should be specified. (optional)
     * @param  string $metacounter_value_lt Searches for group channels with metacounter containing an item with the key specified by the metadata_key parameter, where the value of that item is lower than the value specified by this parameter. To use this parameter, the metacounter_key parameter should be specified. (optional)
     * @param  string $metacounter_value_lte Searches for group channels with metacounter containing an item with the key specified by the metadata_key parameter, where the value of that item is lower than or equal to the value specified by this parameter. To use this parameter, the metacounter_key parameter should be specified. (optional)
     * @param  bool $include_sorted_metaarray_in_last_message Determines whether to include the sorted_metaarray as one of the last_message’s properties in the response. (optional)
     * @param  string $hidden_mode Restricts the search scope to group channels that match a specific hidden_status and operating behavior (optional)
     * @param  string $unread_filter Restricts the search scope to only retrieve group channels with one or more unread messages. This filter doesn&#39;t support Supergroup channels. Acceptable values are all and unread_message. (Default: all) (optional)
     * @param  string $member_state_filter (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listMyGroupChannelsRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $user_id = array_key_exists('user_id', $associative_array) ? $associative_array['user_id'] : null;
        $api_token = array_key_exists('api_token', $associative_array) ? $associative_array['api_token'] : null;
        $token = array_key_exists('token', $associative_array) ? $associative_array['token'] : null;
        $limit = array_key_exists('limit', $associative_array) ? $associative_array['limit'] : null;
        $distinct_mode = array_key_exists('distinct_mode', $associative_array) ? $associative_array['distinct_mode'] : null;
        $public_mode = array_key_exists('public_mode', $associative_array) ? $associative_array['public_mode'] : null;
        $super_mode = array_key_exists('super_mode', $associative_array) ? $associative_array['super_mode'] : null;
        $created_after = array_key_exists('created_after', $associative_array) ? $associative_array['created_after'] : null;
        $created_before = array_key_exists('created_before', $associative_array) ? $associative_array['created_before'] : null;
        $show_empty = array_key_exists('show_empty', $associative_array) ? $associative_array['show_empty'] : null;
        $show_member = array_key_exists('show_member', $associative_array) ? $associative_array['show_member'] : null;
        $show_delivery_receipt = array_key_exists('show_delivery_receipt', $associative_array) ? $associative_array['show_delivery_receipt'] : null;
        $show_read_receipt = array_key_exists('show_read_receipt', $associative_array) ? $associative_array['show_read_receipt'] : null;
        $show_metadata = array_key_exists('show_metadata', $associative_array) ? $associative_array['show_metadata'] : null;
        $show_frozen = array_key_exists('show_frozen', $associative_array) ? $associative_array['show_frozen'] : null;
        $order = array_key_exists('order', $associative_array) ? $associative_array['order'] : null;
        $metadata_order_key = array_key_exists('metadata_order_key', $associative_array) ? $associative_array['metadata_order_key'] : null;
        $custom_types = array_key_exists('custom_types', $associative_array) ? $associative_array['custom_types'] : null;
        $custom_type_startswith = array_key_exists('custom_type_startswith', $associative_array) ? $associative_array['custom_type_startswith'] : null;
        $channel_urls = array_key_exists('channel_urls', $associative_array) ? $associative_array['channel_urls'] : null;
        $name = array_key_exists('name', $associative_array) ? $associative_array['name'] : null;
        $name_contains = array_key_exists('name_contains', $associative_array) ? $associative_array['name_contains'] : null;
        $name_startswith = array_key_exists('name_startswith', $associative_array) ? $associative_array['name_startswith'] : null;
        $members_exactly_in = array_key_exists('members_exactly_in', $associative_array) ? $associative_array['members_exactly_in'] : null;
        $members_include_in = array_key_exists('members_include_in', $associative_array) ? $associative_array['members_include_in'] : null;
        $query_type = array_key_exists('query_type', $associative_array) ? $associative_array['query_type'] : null;
        $members_nickname = array_key_exists('members_nickname', $associative_array) ? $associative_array['members_nickname'] : null;
        $members_nickname_contains = array_key_exists('members_nickname_contains', $associative_array) ? $associative_array['members_nickname_contains'] : null;
        $members_nickname_startswith = array_key_exists('members_nickname_startswith', $associative_array) ? $associative_array['members_nickname_startswith'] : null;
        $search_query = array_key_exists('search_query', $associative_array) ? $associative_array['search_query'] : null;
        $search_fields = array_key_exists('search_fields', $associative_array) ? $associative_array['search_fields'] : null;
        $metadata_key = array_key_exists('metadata_key', $associative_array) ? $associative_array['metadata_key'] : null;
        $metadata_values = array_key_exists('metadata_values', $associative_array) ? $associative_array['metadata_values'] : null;
        $metadata_value_startswith = array_key_exists('metadata_value_startswith', $associative_array) ? $associative_array['metadata_value_startswith'] : null;
        $metacounter_key = array_key_exists('metacounter_key', $associative_array) ? $associative_array['metacounter_key'] : null;
        $metacounter_values = array_key_exists('metacounter_values', $associative_array) ? $associative_array['metacounter_values'] : null;
        $metacounter_value_gt = array_key_exists('metacounter_value_gt', $associative_array) ? $associative_array['metacounter_value_gt'] : null;
        $metacounter_value_gte = array_key_exists('metacounter_value_gte', $associative_array) ? $associative_array['metacounter_value_gte'] : null;
        $metacounter_value_lt = array_key_exists('metacounter_value_lt', $associative_array) ? $associative_array['metacounter_value_lt'] : null;
        $metacounter_value_lte = array_key_exists('metacounter_value_lte', $associative_array) ? $associative_array['metacounter_value_lte'] : null;
        $include_sorted_metaarray_in_last_message = array_key_exists('include_sorted_metaarray_in_last_message', $associative_array) ? $associative_array['include_sorted_metaarray_in_last_message'] : null;
        $hidden_mode = array_key_exists('hidden_mode', $associative_array) ? $associative_array['hidden_mode'] : null;
        $unread_filter = array_key_exists('unread_filter', $associative_array) ? $associative_array['unread_filter'] : null;
        $member_state_filter = array_key_exists('member_state_filter', $associative_array) ? $associative_array['member_state_filter'] : null;

        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_id when calling listMyGroupChannels'
            );
        }
        // verify the required parameter 'api_token' is set
        if ($api_token === null || (is_array($api_token) && count($api_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $api_token when calling listMyGroupChannels'
            );
        }

        $resourcePath = '/v3/users/{user_id}/my_group_channels';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $token,
            'token', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $distinct_mode,
            'distinct_mode', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $public_mode,
            'public_mode', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $super_mode,
            'super_mode', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_after,
            'created_after', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_before,
            'created_before', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $show_empty,
            'show_empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $show_member,
            'show_member', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $show_delivery_receipt,
            'show_delivery_receipt', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $show_read_receipt,
            'show_read_receipt', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $show_metadata,
            'show_metadata', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $show_frozen,
            'show_frozen', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $order,
            'order', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $metadata_order_key,
            'metadata_order_key', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $custom_types,
            'custom_types', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $custom_type_startswith,
            'custom_type_startswith', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $channel_urls,
            'channel_urls', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name_contains,
            'name_contains', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name_startswith,
            'name_startswith', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $members_exactly_in,
            'members_exactly_in', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $members_include_in,
            'members_include_in', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $query_type,
            'query_type', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $members_nickname,
            'members_nickname', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $members_nickname_contains,
            'members_nickname_contains', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $members_nickname_startswith,
            'members_nickname_startswith', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $search_query,
            'search_query', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $search_fields,
            'search_fields', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $metadata_key,
            'metadata_key', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $metadata_values,
            'metadata_values', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $metadata_value_startswith,
            'metadata_value_startswith', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $metacounter_key,
            'metacounter_key', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $metacounter_values,
            'metacounter_values', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $metacounter_value_gt,
            'metacounter_value_gt', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $metacounter_value_gte,
            'metacounter_value_gte', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $metacounter_value_lt,
            'metacounter_value_lt', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $metacounter_value_lte,
            'metacounter_value_lte', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_sorted_metaarray_in_last_message,
            'include_sorted_metaarray_in_last_message', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $hidden_mode,
            'hidden_mode', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $unread_filter,
            'unread_filter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $member_state_filter,
            'member_state_filter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($api_token !== null) {
            $headerParams['api-token'] = ObjectSerializer::toHeaderValue($api_token);
        }

        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'user_id' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listRegistrationOrDeviceTokens
     *
     * List registration or device tokens
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $token_type (Required) (required)
     * @param  string $api_token api_token (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sendbird\Model\ListRegistrationOrDeviceTokensResponse
     */
    public function listRegistrationOrDeviceTokens($associative_array)
    {
        list($response) = $this->listRegistrationOrDeviceTokensWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation listRegistrationOrDeviceTokensWithHttpInfo
     *
     * List registration or device tokens
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $token_type (Required) (required)
     * @param  string $api_token (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sendbird\Model\ListRegistrationOrDeviceTokensResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listRegistrationOrDeviceTokensWithHttpInfo($associative_array)
    {
        $request = $this->listRegistrationOrDeviceTokensRequest($associative_array);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Sendbird\Model\ListRegistrationOrDeviceTokensResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sendbird\Model\ListRegistrationOrDeviceTokensResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sendbird\Model\ListRegistrationOrDeviceTokensResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sendbird\Model\ListRegistrationOrDeviceTokensResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sendbird\Model\ListRegistrationOrDeviceTokensResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listRegistrationOrDeviceTokensAsync
     *
     * List registration or device tokens
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $token_type (Required) (required)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listRegistrationOrDeviceTokensAsync($associative_array)
    {
        return $this->listRegistrationOrDeviceTokensAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listRegistrationOrDeviceTokensAsyncWithHttpInfo
     *
     * List registration or device tokens
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $token_type (Required) (required)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listRegistrationOrDeviceTokensAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\Sendbird\Model\ListRegistrationOrDeviceTokensResponse';
        $request = $this->listRegistrationOrDeviceTokensRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listRegistrationOrDeviceTokens'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $token_type (Required) (required)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listRegistrationOrDeviceTokensRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $user_id = array_key_exists('user_id', $associative_array) ? $associative_array['user_id'] : null;
        $token_type = array_key_exists('token_type', $associative_array) ? $associative_array['token_type'] : null;
        $api_token = array_key_exists('api_token', $associative_array) ? $associative_array['api_token'] : null;

        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_id when calling listRegistrationOrDeviceTokens'
            );
        }
        // verify the required parameter 'token_type' is set
        if ($token_type === null || (is_array($token_type) && count($token_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token_type when calling listRegistrationOrDeviceTokens'
            );
        }

        $resourcePath = '/v3/users/{user_id}/push/{token_type}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($api_token !== null) {
            $headerParams['api-token'] = ObjectSerializer::toHeaderValue($api_token);
        }

        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'user_id' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }
        // path params
        if ($token_type !== null) {
            $resourcePath = str_replace(
                '{' . 'token_type' . '}',
                ObjectSerializer::toPathValue($token_type),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listUsers
     *
     * List users
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $token token (optional)
     * @param  int $limit limit (optional)
     * @param  string $active_mode Specifies the activation status of the users in the list. Acceptable values are &#x60;activated&#x60;, &#x60;deactivated&#x60;, and &#x60;all&#x60;. (Default: &#x60;activated&#x60;) (optional)
     * @param  bool $show_bot Determines whether to include bots in the list. (Default: true) (optional)
     * @param  string $user_ids Specifies the user IDs. The value should be a comma-separated string that consists of multiple urlencoded user IDs. An example of a urlencoded string is ?user_ids&#x3D;urlencoded_id_1,urlencoded_id_2. * The maximum number of user IDs in this parameter is 250. If you exceed the maximum number, your request may receive an HTTP 414 error indicating that the request URL is longer than what Sendbird server can interpret. (optional)
     * @param  string $nickname nickname (optional)
     * @param  string $nickname_startswith nickname_startswith (optional)
     * @param  string $metadatakey metadatakey (optional)
     * @param  string $metadatavalues_in Searches for blocked users with metadata containing an item with the key specified by the metadatakey parameter above, and the value of that item matches one or more values specified by this parameter. The string should be specified with multiple urlencoded metadata values separated by commas (for example, &#x60;?metadatavalues_in&#x3D;urlencoded_value_1, urlencoded_value_2&#x60;). This parameter should be specified in conjunction with the &#x60;metadatakey&#x60; above. (optional)
     * @param  string $api_token api_token (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sendbird\Model\ListUsersResponse
     */
    public function listUsers($associative_array)
    {
        list($response) = $this->listUsersWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation listUsersWithHttpInfo
     *
     * List users
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $token (optional)
     * @param  int $limit (optional)
     * @param  string $active_mode Specifies the activation status of the users in the list. Acceptable values are &#x60;activated&#x60;, &#x60;deactivated&#x60;, and &#x60;all&#x60;. (Default: &#x60;activated&#x60;) (optional)
     * @param  bool $show_bot Determines whether to include bots in the list. (Default: true) (optional)
     * @param  string $user_ids Specifies the user IDs. The value should be a comma-separated string that consists of multiple urlencoded user IDs. An example of a urlencoded string is ?user_ids&#x3D;urlencoded_id_1,urlencoded_id_2. * The maximum number of user IDs in this parameter is 250. If you exceed the maximum number, your request may receive an HTTP 414 error indicating that the request URL is longer than what Sendbird server can interpret. (optional)
     * @param  string $nickname (optional)
     * @param  string $nickname_startswith (optional)
     * @param  string $metadatakey (optional)
     * @param  string $metadatavalues_in Searches for blocked users with metadata containing an item with the key specified by the metadatakey parameter above, and the value of that item matches one or more values specified by this parameter. The string should be specified with multiple urlencoded metadata values separated by commas (for example, &#x60;?metadatavalues_in&#x3D;urlencoded_value_1, urlencoded_value_2&#x60;). This parameter should be specified in conjunction with the &#x60;metadatakey&#x60; above. (optional)
     * @param  string $api_token (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sendbird\Model\ListUsersResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listUsersWithHttpInfo($associative_array)
    {
        $request = $this->listUsersRequest($associative_array);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Sendbird\Model\ListUsersResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sendbird\Model\ListUsersResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sendbird\Model\ListUsersResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sendbird\Model\ListUsersResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sendbird\Model\ListUsersResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listUsersAsync
     *
     * List users
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $token (optional)
     * @param  int $limit (optional)
     * @param  string $active_mode Specifies the activation status of the users in the list. Acceptable values are &#x60;activated&#x60;, &#x60;deactivated&#x60;, and &#x60;all&#x60;. (Default: &#x60;activated&#x60;) (optional)
     * @param  bool $show_bot Determines whether to include bots in the list. (Default: true) (optional)
     * @param  string $user_ids Specifies the user IDs. The value should be a comma-separated string that consists of multiple urlencoded user IDs. An example of a urlencoded string is ?user_ids&#x3D;urlencoded_id_1,urlencoded_id_2. * The maximum number of user IDs in this parameter is 250. If you exceed the maximum number, your request may receive an HTTP 414 error indicating that the request URL is longer than what Sendbird server can interpret. (optional)
     * @param  string $nickname (optional)
     * @param  string $nickname_startswith (optional)
     * @param  string $metadatakey (optional)
     * @param  string $metadatavalues_in Searches for blocked users with metadata containing an item with the key specified by the metadatakey parameter above, and the value of that item matches one or more values specified by this parameter. The string should be specified with multiple urlencoded metadata values separated by commas (for example, &#x60;?metadatavalues_in&#x3D;urlencoded_value_1, urlencoded_value_2&#x60;). This parameter should be specified in conjunction with the &#x60;metadatakey&#x60; above. (optional)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listUsersAsync($associative_array)
    {
        return $this->listUsersAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listUsersAsyncWithHttpInfo
     *
     * List users
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $token (optional)
     * @param  int $limit (optional)
     * @param  string $active_mode Specifies the activation status of the users in the list. Acceptable values are &#x60;activated&#x60;, &#x60;deactivated&#x60;, and &#x60;all&#x60;. (Default: &#x60;activated&#x60;) (optional)
     * @param  bool $show_bot Determines whether to include bots in the list. (Default: true) (optional)
     * @param  string $user_ids Specifies the user IDs. The value should be a comma-separated string that consists of multiple urlencoded user IDs. An example of a urlencoded string is ?user_ids&#x3D;urlencoded_id_1,urlencoded_id_2. * The maximum number of user IDs in this parameter is 250. If you exceed the maximum number, your request may receive an HTTP 414 error indicating that the request URL is longer than what Sendbird server can interpret. (optional)
     * @param  string $nickname (optional)
     * @param  string $nickname_startswith (optional)
     * @param  string $metadatakey (optional)
     * @param  string $metadatavalues_in Searches for blocked users with metadata containing an item with the key specified by the metadatakey parameter above, and the value of that item matches one or more values specified by this parameter. The string should be specified with multiple urlencoded metadata values separated by commas (for example, &#x60;?metadatavalues_in&#x3D;urlencoded_value_1, urlencoded_value_2&#x60;). This parameter should be specified in conjunction with the &#x60;metadatakey&#x60; above. (optional)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listUsersAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\Sendbird\Model\ListUsersResponse';
        $request = $this->listUsersRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listUsers'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $token (optional)
     * @param  int $limit (optional)
     * @param  string $active_mode Specifies the activation status of the users in the list. Acceptable values are &#x60;activated&#x60;, &#x60;deactivated&#x60;, and &#x60;all&#x60;. (Default: &#x60;activated&#x60;) (optional)
     * @param  bool $show_bot Determines whether to include bots in the list. (Default: true) (optional)
     * @param  string $user_ids Specifies the user IDs. The value should be a comma-separated string that consists of multiple urlencoded user IDs. An example of a urlencoded string is ?user_ids&#x3D;urlencoded_id_1,urlencoded_id_2. * The maximum number of user IDs in this parameter is 250. If you exceed the maximum number, your request may receive an HTTP 414 error indicating that the request URL is longer than what Sendbird server can interpret. (optional)
     * @param  string $nickname (optional)
     * @param  string $nickname_startswith (optional)
     * @param  string $metadatakey (optional)
     * @param  string $metadatavalues_in Searches for blocked users with metadata containing an item with the key specified by the metadatakey parameter above, and the value of that item matches one or more values specified by this parameter. The string should be specified with multiple urlencoded metadata values separated by commas (for example, &#x60;?metadatavalues_in&#x3D;urlencoded_value_1, urlencoded_value_2&#x60;). This parameter should be specified in conjunction with the &#x60;metadatakey&#x60; above. (optional)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listUsersRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $token = array_key_exists('token', $associative_array) ? $associative_array['token'] : null;
        $limit = array_key_exists('limit', $associative_array) ? $associative_array['limit'] : null;
        $active_mode = array_key_exists('active_mode', $associative_array) ? $associative_array['active_mode'] : null;
        $show_bot = array_key_exists('show_bot', $associative_array) ? $associative_array['show_bot'] : null;
        $user_ids = array_key_exists('user_ids', $associative_array) ? $associative_array['user_ids'] : null;
        $nickname = array_key_exists('nickname', $associative_array) ? $associative_array['nickname'] : null;
        $nickname_startswith = array_key_exists('nickname_startswith', $associative_array) ? $associative_array['nickname_startswith'] : null;
        $metadatakey = array_key_exists('metadatakey', $associative_array) ? $associative_array['metadatakey'] : null;
        $metadatavalues_in = array_key_exists('metadatavalues_in', $associative_array) ? $associative_array['metadatavalues_in'] : null;
        $api_token = array_key_exists('api_token', $associative_array) ? $associative_array['api_token'] : null;


        $resourcePath = '/v3/users';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $token,
            'token', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $active_mode,
            'active_mode', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $show_bot,
            'show_bot', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user_ids,
            'user_ids', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $nickname,
            'nickname', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $nickname_startswith,
            'nickname_startswith', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $metadatakey,
            'metadatakey', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $metadatavalues_in,
            'metadatavalues_in', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($api_token !== null) {
            $headerParams['api-token'] = ObjectSerializer::toHeaderValue($api_token);
        }



        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation markAllMessagesAsRead
     *
     * Mark all messages as read
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $api_token api_token (optional)
     * @param  \Sendbird\Model\MarkAllMessagesAsReadRequest $mark_all_messages_as_read_request mark_all_messages_as_read_request (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function markAllMessagesAsRead($associative_array)
    {
        list($response) = $this->markAllMessagesAsReadWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation markAllMessagesAsReadWithHttpInfo
     *
     * Mark all messages as read
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\MarkAllMessagesAsReadRequest $mark_all_messages_as_read_request (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function markAllMessagesAsReadWithHttpInfo($associative_array)
    {
        $request = $this->markAllMessagesAsReadRequest($associative_array);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation markAllMessagesAsReadAsync
     *
     * Mark all messages as read
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\MarkAllMessagesAsReadRequest $mark_all_messages_as_read_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function markAllMessagesAsReadAsync($associative_array)
    {
        return $this->markAllMessagesAsReadAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation markAllMessagesAsReadAsyncWithHttpInfo
     *
     * Mark all messages as read
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\MarkAllMessagesAsReadRequest $mark_all_messages_as_read_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function markAllMessagesAsReadAsyncWithHttpInfo($associative_array)
    {
        $returnType = 'object';
        $request = $this->markAllMessagesAsReadRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'markAllMessagesAsRead'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\MarkAllMessagesAsReadRequest $mark_all_messages_as_read_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function markAllMessagesAsReadRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $user_id = array_key_exists('user_id', $associative_array) ? $associative_array['user_id'] : null;
        $api_token = array_key_exists('api_token', $associative_array) ? $associative_array['api_token'] : null;
        $mark_all_messages_as_read_request = array_key_exists('mark_all_messages_as_read_request', $associative_array) ? $associative_array['mark_all_messages_as_read_request'] : null;

        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_id when calling markAllMessagesAsRead'
            );
        }

        $resourcePath = '/v3/users/{user_id}/mark_as_read_all';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($api_token !== null) {
            $headerParams['api-token'] = ObjectSerializer::toHeaderValue($api_token);
        }

        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'user_id' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($mark_all_messages_as_read_request)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($mark_all_messages_as_read_request));
            } else {
                $httpBody = $mark_all_messages_as_read_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation removeARegistrationOrDeviceToken
     *
     * Remove a registration or device token - When unregistering a specific token
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $token_type (Required) (required)
     * @param  string $token (Required) (required)
     * @param  string $api_token api_token (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sendbird\Model\RemoveARegistrationOrDeviceTokenResponse
     */
    public function removeARegistrationOrDeviceToken($associative_array)
    {
        list($response) = $this->removeARegistrationOrDeviceTokenWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation removeARegistrationOrDeviceTokenWithHttpInfo
     *
     * Remove a registration or device token - When unregistering a specific token
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $token_type (Required) (required)
     * @param  string $token (Required) (required)
     * @param  string $api_token (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sendbird\Model\RemoveARegistrationOrDeviceTokenResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function removeARegistrationOrDeviceTokenWithHttpInfo($associative_array)
    {
        $request = $this->removeARegistrationOrDeviceTokenRequest($associative_array);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Sendbird\Model\RemoveARegistrationOrDeviceTokenResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sendbird\Model\RemoveARegistrationOrDeviceTokenResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sendbird\Model\RemoveARegistrationOrDeviceTokenResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sendbird\Model\RemoveARegistrationOrDeviceTokenResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sendbird\Model\RemoveARegistrationOrDeviceTokenResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation removeARegistrationOrDeviceTokenAsync
     *
     * Remove a registration or device token - When unregistering a specific token
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $token_type (Required) (required)
     * @param  string $token (Required) (required)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function removeARegistrationOrDeviceTokenAsync($associative_array)
    {
        return $this->removeARegistrationOrDeviceTokenAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation removeARegistrationOrDeviceTokenAsyncWithHttpInfo
     *
     * Remove a registration or device token - When unregistering a specific token
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $token_type (Required) (required)
     * @param  string $token (Required) (required)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function removeARegistrationOrDeviceTokenAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\Sendbird\Model\RemoveARegistrationOrDeviceTokenResponse';
        $request = $this->removeARegistrationOrDeviceTokenRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'removeARegistrationOrDeviceToken'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $token_type (Required) (required)
     * @param  string $token (Required) (required)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function removeARegistrationOrDeviceTokenRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $user_id = array_key_exists('user_id', $associative_array) ? $associative_array['user_id'] : null;
        $token_type = array_key_exists('token_type', $associative_array) ? $associative_array['token_type'] : null;
        $token = array_key_exists('token', $associative_array) ? $associative_array['token'] : null;
        $api_token = array_key_exists('api_token', $associative_array) ? $associative_array['api_token'] : null;

        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_id when calling removeARegistrationOrDeviceToken'
            );
        }
        // verify the required parameter 'token_type' is set
        if ($token_type === null || (is_array($token_type) && count($token_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token_type when calling removeARegistrationOrDeviceToken'
            );
        }
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling removeARegistrationOrDeviceToken'
            );
        }

        $resourcePath = '/v3/users/{user_id}/push/{token_type}/{token}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($api_token !== null) {
            $headerParams['api-token'] = ObjectSerializer::toHeaderValue($api_token);
        }

        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'user_id' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }
        // path params
        if ($token_type !== null) {
            $resourcePath = str_replace(
                '{' . 'token_type' . '}',
                ObjectSerializer::toPathValue($token_type),
                $resourcePath
            );
        }
        // path params
        if ($token !== null) {
            $resourcePath = str_replace(
                '{' . 'token' . '}',
                ObjectSerializer::toPathValue($token),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation removeARegistrationOrDeviceTokenFromAnOwner
     *
     * Remove a registration or device token from an owner
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $token_type (Required) (required)
     * @param  string $token (Required) (required)
     * @param  string $api_token api_token (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sendbird\Model\MarkChannelMessagesAsReadRequest[]
     */
    public function removeARegistrationOrDeviceTokenFromAnOwner($associative_array)
    {
        list($response) = $this->removeARegistrationOrDeviceTokenFromAnOwnerWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation removeARegistrationOrDeviceTokenFromAnOwnerWithHttpInfo
     *
     * Remove a registration or device token from an owner
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $token_type (Required) (required)
     * @param  string $token (Required) (required)
     * @param  string $api_token (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sendbird\Model\MarkChannelMessagesAsReadRequest[], HTTP status code, HTTP response headers (array of strings)
     */
    public function removeARegistrationOrDeviceTokenFromAnOwnerWithHttpInfo($associative_array)
    {
        $request = $this->removeARegistrationOrDeviceTokenFromAnOwnerRequest($associative_array);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Sendbird\Model\MarkChannelMessagesAsReadRequest[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sendbird\Model\MarkChannelMessagesAsReadRequest[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sendbird\Model\MarkChannelMessagesAsReadRequest[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sendbird\Model\MarkChannelMessagesAsReadRequest[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sendbird\Model\MarkChannelMessagesAsReadRequest[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation removeARegistrationOrDeviceTokenFromAnOwnerAsync
     *
     * Remove a registration or device token from an owner
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $token_type (Required) (required)
     * @param  string $token (Required) (required)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function removeARegistrationOrDeviceTokenFromAnOwnerAsync($associative_array)
    {
        return $this->removeARegistrationOrDeviceTokenFromAnOwnerAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation removeARegistrationOrDeviceTokenFromAnOwnerAsyncWithHttpInfo
     *
     * Remove a registration or device token from an owner
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $token_type (Required) (required)
     * @param  string $token (Required) (required)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function removeARegistrationOrDeviceTokenFromAnOwnerAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\Sendbird\Model\MarkChannelMessagesAsReadRequest[]';
        $request = $this->removeARegistrationOrDeviceTokenFromAnOwnerRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'removeARegistrationOrDeviceTokenFromAnOwner'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $token_type (Required) (required)
     * @param  string $token (Required) (required)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function removeARegistrationOrDeviceTokenFromAnOwnerRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $token_type = array_key_exists('token_type', $associative_array) ? $associative_array['token_type'] : null;
        $token = array_key_exists('token', $associative_array) ? $associative_array['token'] : null;
        $api_token = array_key_exists('api_token', $associative_array) ? $associative_array['api_token'] : null;

        // verify the required parameter 'token_type' is set
        if ($token_type === null || (is_array($token_type) && count($token_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token_type when calling removeARegistrationOrDeviceTokenFromAnOwner'
            );
        }
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling removeARegistrationOrDeviceTokenFromAnOwner'
            );
        }

        $resourcePath = '/v3/push/device_tokens/{token_type}/{token}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($api_token !== null) {
            $headerParams['api-token'] = ObjectSerializer::toHeaderValue($api_token);
        }

        // path params
        if ($token_type !== null) {
            $resourcePath = str_replace(
                '{' . 'token_type' . '}',
                ObjectSerializer::toPathValue($token_type),
                $resourcePath
            );
        }
        // path params
        if ($token !== null) {
            $resourcePath = str_replace(
                '{' . 'token' . '}',
                ObjectSerializer::toPathValue($token),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation removeAllRegistrationOrDeviceToken
     *
     * Remove a registration or device token - When unregistering all device tokens
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $api_token api_token (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sendbird\Model\RemoveAllRegistrationOrDeviceTokenResponse
     */
    public function removeAllRegistrationOrDeviceToken($associative_array)
    {
        list($response) = $this->removeAllRegistrationOrDeviceTokenWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation removeAllRegistrationOrDeviceTokenWithHttpInfo
     *
     * Remove a registration or device token - When unregistering all device tokens
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $api_token (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sendbird\Model\RemoveAllRegistrationOrDeviceTokenResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function removeAllRegistrationOrDeviceTokenWithHttpInfo($associative_array)
    {
        $request = $this->removeAllRegistrationOrDeviceTokenRequest($associative_array);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Sendbird\Model\RemoveAllRegistrationOrDeviceTokenResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sendbird\Model\RemoveAllRegistrationOrDeviceTokenResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sendbird\Model\RemoveAllRegistrationOrDeviceTokenResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sendbird\Model\RemoveAllRegistrationOrDeviceTokenResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sendbird\Model\RemoveAllRegistrationOrDeviceTokenResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation removeAllRegistrationOrDeviceTokenAsync
     *
     * Remove a registration or device token - When unregistering all device tokens
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function removeAllRegistrationOrDeviceTokenAsync($associative_array)
    {
        return $this->removeAllRegistrationOrDeviceTokenAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation removeAllRegistrationOrDeviceTokenAsyncWithHttpInfo
     *
     * Remove a registration or device token - When unregistering all device tokens
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function removeAllRegistrationOrDeviceTokenAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\Sendbird\Model\RemoveAllRegistrationOrDeviceTokenResponse';
        $request = $this->removeAllRegistrationOrDeviceTokenRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'removeAllRegistrationOrDeviceToken'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function removeAllRegistrationOrDeviceTokenRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $user_id = array_key_exists('user_id', $associative_array) ? $associative_array['user_id'] : null;
        $api_token = array_key_exists('api_token', $associative_array) ? $associative_array['api_token'] : null;

        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_id when calling removeAllRegistrationOrDeviceToken'
            );
        }

        $resourcePath = '/v3/users/{user_id}/push';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($api_token !== null) {
            $headerParams['api-token'] = ObjectSerializer::toHeaderValue($api_token);
        }

        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'user_id' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation resetPushPreferences
     *
     * Reset push preferences
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $api_token api_token (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function resetPushPreferences($associative_array)
    {
        list($response) = $this->resetPushPreferencesWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation resetPushPreferencesWithHttpInfo
     *
     * Reset push preferences
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $api_token (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function resetPushPreferencesWithHttpInfo($associative_array)
    {
        $request = $this->resetPushPreferencesRequest($associative_array);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation resetPushPreferencesAsync
     *
     * Reset push preferences
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function resetPushPreferencesAsync($associative_array)
    {
        return $this->resetPushPreferencesAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation resetPushPreferencesAsyncWithHttpInfo
     *
     * Reset push preferences
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function resetPushPreferencesAsyncWithHttpInfo($associative_array)
    {
        $returnType = 'object';
        $request = $this->resetPushPreferencesRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'resetPushPreferences'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function resetPushPreferencesRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $user_id = array_key_exists('user_id', $associative_array) ? $associative_array['user_id'] : null;
        $api_token = array_key_exists('api_token', $associative_array) ? $associative_array['api_token'] : null;

        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_id when calling resetPushPreferences'
            );
        }

        $resourcePath = '/v3/users/{user_id}/push_preference';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($api_token !== null) {
            $headerParams['api-token'] = ObjectSerializer::toHeaderValue($api_token);
        }

        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'user_id' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateAUser
     *
     * Update a user
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $api_token api_token (optional)
     * @param  \Sendbird\Model\UpdateAUserRequest $update_a_user_request update_a_user_request (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sendbird\Model\SendbirdUser
     */
    public function updateAUser($associative_array)
    {
        list($response) = $this->updateAUserWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation updateAUserWithHttpInfo
     *
     * Update a user
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\UpdateAUserRequest $update_a_user_request (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sendbird\Model\SendbirdUser, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateAUserWithHttpInfo($associative_array)
    {
        $request = $this->updateAUserRequest($associative_array);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Sendbird\Model\SendbirdUser' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sendbird\Model\SendbirdUser' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sendbird\Model\SendbirdUser', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sendbird\Model\SendbirdUser';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sendbird\Model\SendbirdUser',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateAUserAsync
     *
     * Update a user
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\UpdateAUserRequest $update_a_user_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateAUserAsync($associative_array)
    {
        return $this->updateAUserAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateAUserAsyncWithHttpInfo
     *
     * Update a user
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\UpdateAUserRequest $update_a_user_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateAUserAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\Sendbird\Model\SendbirdUser';
        $request = $this->updateAUserRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateAUser'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\UpdateAUserRequest $update_a_user_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateAUserRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $user_id = array_key_exists('user_id', $associative_array) ? $associative_array['user_id'] : null;
        $api_token = array_key_exists('api_token', $associative_array) ? $associative_array['api_token'] : null;
        $update_a_user_request = array_key_exists('update_a_user_request', $associative_array) ? $associative_array['update_a_user_request'] : null;

        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_id when calling updateAUser'
            );
        }

        $resourcePath = '/v3/users/{user_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($api_token !== null) {
            $headerParams['api-token'] = ObjectSerializer::toHeaderValue($api_token);
        }

        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'user_id' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($update_a_user_request)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($update_a_user_request));
            } else {
                $httpBody = $update_a_user_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateChannelInvitationPreference
     *
     * Update channel invitation preference
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $api_token api_token (optional)
     * @param  \Sendbird\Model\UpdateChannelInvitationPreferenceRequest $update_channel_invitation_preference_request update_channel_invitation_preference_request (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sendbird\Model\UpdateChannelInvitationPreferenceResponse
     */
    public function updateChannelInvitationPreference($associative_array)
    {
        list($response) = $this->updateChannelInvitationPreferenceWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation updateChannelInvitationPreferenceWithHttpInfo
     *
     * Update channel invitation preference
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\UpdateChannelInvitationPreferenceRequest $update_channel_invitation_preference_request (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sendbird\Model\UpdateChannelInvitationPreferenceResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateChannelInvitationPreferenceWithHttpInfo($associative_array)
    {
        $request = $this->updateChannelInvitationPreferenceRequest($associative_array);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Sendbird\Model\UpdateChannelInvitationPreferenceResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sendbird\Model\UpdateChannelInvitationPreferenceResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sendbird\Model\UpdateChannelInvitationPreferenceResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sendbird\Model\UpdateChannelInvitationPreferenceResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sendbird\Model\UpdateChannelInvitationPreferenceResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateChannelInvitationPreferenceAsync
     *
     * Update channel invitation preference
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\UpdateChannelInvitationPreferenceRequest $update_channel_invitation_preference_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateChannelInvitationPreferenceAsync($associative_array)
    {
        return $this->updateChannelInvitationPreferenceAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateChannelInvitationPreferenceAsyncWithHttpInfo
     *
     * Update channel invitation preference
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\UpdateChannelInvitationPreferenceRequest $update_channel_invitation_preference_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateChannelInvitationPreferenceAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\Sendbird\Model\UpdateChannelInvitationPreferenceResponse';
        $request = $this->updateChannelInvitationPreferenceRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateChannelInvitationPreference'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\UpdateChannelInvitationPreferenceRequest $update_channel_invitation_preference_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateChannelInvitationPreferenceRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $user_id = array_key_exists('user_id', $associative_array) ? $associative_array['user_id'] : null;
        $api_token = array_key_exists('api_token', $associative_array) ? $associative_array['api_token'] : null;
        $update_channel_invitation_preference_request = array_key_exists('update_channel_invitation_preference_request', $associative_array) ? $associative_array['update_channel_invitation_preference_request'] : null;

        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_id when calling updateChannelInvitationPreference'
            );
        }

        $resourcePath = '/v3/users/{user_id}/channel_invitation_preference';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($api_token !== null) {
            $headerParams['api-token'] = ObjectSerializer::toHeaderValue($api_token);
        }

        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'user_id' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($update_channel_invitation_preference_request)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($update_channel_invitation_preference_request));
            } else {
                $httpBody = $update_channel_invitation_preference_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateCountPreferenceOfAChannel
     *
     * Update count preference of a channel
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token api_token (optional)
     * @param  \Sendbird\Model\UpdateCountPreferenceOfAChannelRequest $update_count_preference_of_a_channel_request update_count_preference_of_a_channel_request (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sendbird\Model\UpdateCountPreferenceOfChannelByUrlResponse
     */
    public function updateCountPreferenceOfAChannel($associative_array)
    {
        list($response) = $this->updateCountPreferenceOfAChannelWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation updateCountPreferenceOfAChannelWithHttpInfo
     *
     * Update count preference of a channel
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\UpdateCountPreferenceOfAChannelRequest $update_count_preference_of_a_channel_request (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sendbird\Model\UpdateCountPreferenceOfChannelByUrlResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateCountPreferenceOfAChannelWithHttpInfo($associative_array)
    {
        $request = $this->updateCountPreferenceOfAChannelRequest($associative_array);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Sendbird\Model\UpdateCountPreferenceOfChannelByUrlResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sendbird\Model\UpdateCountPreferenceOfChannelByUrlResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sendbird\Model\UpdateCountPreferenceOfChannelByUrlResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sendbird\Model\UpdateCountPreferenceOfChannelByUrlResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sendbird\Model\UpdateCountPreferenceOfChannelByUrlResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateCountPreferenceOfAChannelAsync
     *
     * Update count preference of a channel
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\UpdateCountPreferenceOfAChannelRequest $update_count_preference_of_a_channel_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateCountPreferenceOfAChannelAsync($associative_array)
    {
        return $this->updateCountPreferenceOfAChannelAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateCountPreferenceOfAChannelAsyncWithHttpInfo
     *
     * Update count preference of a channel
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\UpdateCountPreferenceOfAChannelRequest $update_count_preference_of_a_channel_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateCountPreferenceOfAChannelAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\Sendbird\Model\UpdateCountPreferenceOfChannelByUrlResponse';
        $request = $this->updateCountPreferenceOfAChannelRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateCountPreferenceOfAChannel'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\UpdateCountPreferenceOfAChannelRequest $update_count_preference_of_a_channel_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateCountPreferenceOfAChannelRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $user_id = array_key_exists('user_id', $associative_array) ? $associative_array['user_id'] : null;
        $channel_url = array_key_exists('channel_url', $associative_array) ? $associative_array['channel_url'] : null;
        $api_token = array_key_exists('api_token', $associative_array) ? $associative_array['api_token'] : null;
        $update_count_preference_of_a_channel_request = array_key_exists('update_count_preference_of_a_channel_request', $associative_array) ? $associative_array['update_count_preference_of_a_channel_request'] : null;

        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_id when calling updateCountPreferenceOfAChannel'
            );
        }
        // verify the required parameter 'channel_url' is set
        if ($channel_url === null || (is_array($channel_url) && count($channel_url) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel_url when calling updateCountPreferenceOfAChannel'
            );
        }

        $resourcePath = '/v3/users/{user_id}/count_preference/{channel_url}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($api_token !== null) {
            $headerParams['api-token'] = ObjectSerializer::toHeaderValue($api_token);
        }

        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'user_id' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }
        // path params
        if ($channel_url !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_url' . '}',
                ObjectSerializer::toPathValue($channel_url),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($update_count_preference_of_a_channel_request)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($update_count_preference_of_a_channel_request));
            } else {
                $httpBody = $update_count_preference_of_a_channel_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updatePushPreferences
     *
     * Update push preferences
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $api_token api_token (optional)
     * @param  \Sendbird\Model\UpdatePushPreferencesRequest $update_push_preferences_request update_push_preferences_request (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sendbird\Model\UpdatePushPreferencesResponse
     */
    public function updatePushPreferences($associative_array)
    {
        list($response) = $this->updatePushPreferencesWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation updatePushPreferencesWithHttpInfo
     *
     * Update push preferences
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\UpdatePushPreferencesRequest $update_push_preferences_request (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sendbird\Model\UpdatePushPreferencesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updatePushPreferencesWithHttpInfo($associative_array)
    {
        $request = $this->updatePushPreferencesRequest($associative_array);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Sendbird\Model\UpdatePushPreferencesResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sendbird\Model\UpdatePushPreferencesResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sendbird\Model\UpdatePushPreferencesResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sendbird\Model\UpdatePushPreferencesResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sendbird\Model\UpdatePushPreferencesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updatePushPreferencesAsync
     *
     * Update push preferences
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\UpdatePushPreferencesRequest $update_push_preferences_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updatePushPreferencesAsync($associative_array)
    {
        return $this->updatePushPreferencesAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updatePushPreferencesAsyncWithHttpInfo
     *
     * Update push preferences
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\UpdatePushPreferencesRequest $update_push_preferences_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updatePushPreferencesAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\Sendbird\Model\UpdatePushPreferencesResponse';
        $request = $this->updatePushPreferencesRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updatePushPreferences'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\UpdatePushPreferencesRequest $update_push_preferences_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updatePushPreferencesRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $user_id = array_key_exists('user_id', $associative_array) ? $associative_array['user_id'] : null;
        $api_token = array_key_exists('api_token', $associative_array) ? $associative_array['api_token'] : null;
        $update_push_preferences_request = array_key_exists('update_push_preferences_request', $associative_array) ? $associative_array['update_push_preferences_request'] : null;

        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_id when calling updatePushPreferences'
            );
        }

        $resourcePath = '/v3/users/{user_id}/push_preference';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($api_token !== null) {
            $headerParams['api-token'] = ObjectSerializer::toHeaderValue($api_token);
        }

        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'user_id' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($update_push_preferences_request)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($update_push_preferences_request));
            } else {
                $httpBody = $update_push_preferences_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updatePushPreferencesForAChannel
     *
     * Update push preferences for a channel
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token api_token (optional)
     * @param  \Sendbird\Model\UpdatePushPreferencesForAChannelRequest $update_push_preferences_for_a_channel_request update_push_preferences_for_a_channel_request (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sendbird\Model\UpdatePushPreferencesForAChannelResponse
     */
    public function updatePushPreferencesForAChannel($associative_array)
    {
        list($response) = $this->updatePushPreferencesForAChannelWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation updatePushPreferencesForAChannelWithHttpInfo
     *
     * Update push preferences for a channel
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\UpdatePushPreferencesForAChannelRequest $update_push_preferences_for_a_channel_request (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sendbird\Model\UpdatePushPreferencesForAChannelResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updatePushPreferencesForAChannelWithHttpInfo($associative_array)
    {
        $request = $this->updatePushPreferencesForAChannelRequest($associative_array);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Sendbird\Model\UpdatePushPreferencesForAChannelResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sendbird\Model\UpdatePushPreferencesForAChannelResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sendbird\Model\UpdatePushPreferencesForAChannelResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sendbird\Model\UpdatePushPreferencesForAChannelResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sendbird\Model\UpdatePushPreferencesForAChannelResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updatePushPreferencesForAChannelAsync
     *
     * Update push preferences for a channel
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\UpdatePushPreferencesForAChannelRequest $update_push_preferences_for_a_channel_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updatePushPreferencesForAChannelAsync($associative_array)
    {
        return $this->updatePushPreferencesForAChannelAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updatePushPreferencesForAChannelAsyncWithHttpInfo
     *
     * Update push preferences for a channel
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\UpdatePushPreferencesForAChannelRequest $update_push_preferences_for_a_channel_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updatePushPreferencesForAChannelAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\Sendbird\Model\UpdatePushPreferencesForAChannelResponse';
        $request = $this->updatePushPreferencesForAChannelRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updatePushPreferencesForAChannel'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token (optional)
     * @param  \Sendbird\Model\UpdatePushPreferencesForAChannelRequest $update_push_preferences_for_a_channel_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updatePushPreferencesForAChannelRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $user_id = array_key_exists('user_id', $associative_array) ? $associative_array['user_id'] : null;
        $channel_url = array_key_exists('channel_url', $associative_array) ? $associative_array['channel_url'] : null;
        $api_token = array_key_exists('api_token', $associative_array) ? $associative_array['api_token'] : null;
        $update_push_preferences_for_a_channel_request = array_key_exists('update_push_preferences_for_a_channel_request', $associative_array) ? $associative_array['update_push_preferences_for_a_channel_request'] : null;

        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_id when calling updatePushPreferencesForAChannel'
            );
        }
        // verify the required parameter 'channel_url' is set
        if ($channel_url === null || (is_array($channel_url) && count($channel_url) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel_url when calling updatePushPreferencesForAChannel'
            );
        }

        $resourcePath = '/v3/users/{user_id}/push_preference/{channel_url}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($api_token !== null) {
            $headerParams['api-token'] = ObjectSerializer::toHeaderValue($api_token);
        }

        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'user_id' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }
        // path params
        if ($channel_url !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_url' . '}',
                ObjectSerializer::toPathValue($channel_url),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($update_push_preferences_for_a_channel_request)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($update_push_preferences_for_a_channel_request));
            } else {
                $httpBody = $update_push_preferences_for_a_channel_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation viewAUser
     *
     * View a user
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  bool $include_unread_count include_unread_count (optional)
     * @param  string $custom_types custom_types (optional)
     * @param  string $super_mode Restricts the search scope to retrieve only Supergroup or non-Supergroup channels. Acceptable values are &#x60;all&#x60;, &#x60;super&#x60;, and &#x60;nonsuper&#x60;. This parameter should be specified in conjunction with &#x60;include_unread_count&#x60; above. (Default: &#x60;all&#x60;) (optional)
     * @param  string $api_token api_token (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sendbird\Model\SendbirdUser
     */
    public function viewAUser($associative_array)
    {
        list($response) = $this->viewAUserWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation viewAUserWithHttpInfo
     *
     * View a user
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  bool $include_unread_count (optional)
     * @param  string $custom_types (optional)
     * @param  string $super_mode Restricts the search scope to retrieve only Supergroup or non-Supergroup channels. Acceptable values are &#x60;all&#x60;, &#x60;super&#x60;, and &#x60;nonsuper&#x60;. This parameter should be specified in conjunction with &#x60;include_unread_count&#x60; above. (Default: &#x60;all&#x60;) (optional)
     * @param  string $api_token (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sendbird\Model\SendbirdUser, HTTP status code, HTTP response headers (array of strings)
     */
    public function viewAUserWithHttpInfo($associative_array)
    {
        $request = $this->viewAUserRequest($associative_array);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Sendbird\Model\SendbirdUser' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sendbird\Model\SendbirdUser' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sendbird\Model\SendbirdUser', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sendbird\Model\SendbirdUser';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sendbird\Model\SendbirdUser',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation viewAUserAsync
     *
     * View a user
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  bool $include_unread_count (optional)
     * @param  string $custom_types (optional)
     * @param  string $super_mode Restricts the search scope to retrieve only Supergroup or non-Supergroup channels. Acceptable values are &#x60;all&#x60;, &#x60;super&#x60;, and &#x60;nonsuper&#x60;. This parameter should be specified in conjunction with &#x60;include_unread_count&#x60; above. (Default: &#x60;all&#x60;) (optional)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function viewAUserAsync($associative_array)
    {
        return $this->viewAUserAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation viewAUserAsyncWithHttpInfo
     *
     * View a user
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  bool $include_unread_count (optional)
     * @param  string $custom_types (optional)
     * @param  string $super_mode Restricts the search scope to retrieve only Supergroup or non-Supergroup channels. Acceptable values are &#x60;all&#x60;, &#x60;super&#x60;, and &#x60;nonsuper&#x60;. This parameter should be specified in conjunction with &#x60;include_unread_count&#x60; above. (Default: &#x60;all&#x60;) (optional)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function viewAUserAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\Sendbird\Model\SendbirdUser';
        $request = $this->viewAUserRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'viewAUser'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  bool $include_unread_count (optional)
     * @param  string $custom_types (optional)
     * @param  string $super_mode Restricts the search scope to retrieve only Supergroup or non-Supergroup channels. Acceptable values are &#x60;all&#x60;, &#x60;super&#x60;, and &#x60;nonsuper&#x60;. This parameter should be specified in conjunction with &#x60;include_unread_count&#x60; above. (Default: &#x60;all&#x60;) (optional)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function viewAUserRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $user_id = array_key_exists('user_id', $associative_array) ? $associative_array['user_id'] : null;
        $include_unread_count = array_key_exists('include_unread_count', $associative_array) ? $associative_array['include_unread_count'] : null;
        $custom_types = array_key_exists('custom_types', $associative_array) ? $associative_array['custom_types'] : null;
        $super_mode = array_key_exists('super_mode', $associative_array) ? $associative_array['super_mode'] : null;
        $api_token = array_key_exists('api_token', $associative_array) ? $associative_array['api_token'] : null;

        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_id when calling viewAUser'
            );
        }

        $resourcePath = '/v3/users/{user_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_unread_count,
            'include_unread_count', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $custom_types,
            'custom_types', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $super_mode,
            'super_mode', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($api_token !== null) {
            $headerParams['api-token'] = ObjectSerializer::toHeaderValue($api_token);
        }

        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'user_id' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation viewCountPreferenceOfAChannel
     *
     * View count preference of a channel
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token api_token (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sendbird\Model\ViewCountPreferenceOfAChannelResponse
     */
    public function viewCountPreferenceOfAChannel($associative_array)
    {
        list($response) = $this->viewCountPreferenceOfAChannelWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation viewCountPreferenceOfAChannelWithHttpInfo
     *
     * View count preference of a channel
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sendbird\Model\ViewCountPreferenceOfAChannelResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function viewCountPreferenceOfAChannelWithHttpInfo($associative_array)
    {
        $request = $this->viewCountPreferenceOfAChannelRequest($associative_array);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Sendbird\Model\ViewCountPreferenceOfAChannelResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sendbird\Model\ViewCountPreferenceOfAChannelResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sendbird\Model\ViewCountPreferenceOfAChannelResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sendbird\Model\ViewCountPreferenceOfAChannelResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sendbird\Model\ViewCountPreferenceOfAChannelResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation viewCountPreferenceOfAChannelAsync
     *
     * View count preference of a channel
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function viewCountPreferenceOfAChannelAsync($associative_array)
    {
        return $this->viewCountPreferenceOfAChannelAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation viewCountPreferenceOfAChannelAsyncWithHttpInfo
     *
     * View count preference of a channel
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function viewCountPreferenceOfAChannelAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\Sendbird\Model\ViewCountPreferenceOfAChannelResponse';
        $request = $this->viewCountPreferenceOfAChannelRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'viewCountPreferenceOfAChannel'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function viewCountPreferenceOfAChannelRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $user_id = array_key_exists('user_id', $associative_array) ? $associative_array['user_id'] : null;
        $channel_url = array_key_exists('channel_url', $associative_array) ? $associative_array['channel_url'] : null;
        $api_token = array_key_exists('api_token', $associative_array) ? $associative_array['api_token'] : null;

        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_id when calling viewCountPreferenceOfAChannel'
            );
        }
        // verify the required parameter 'channel_url' is set
        if ($channel_url === null || (is_array($channel_url) && count($channel_url) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel_url when calling viewCountPreferenceOfAChannel'
            );
        }

        $resourcePath = '/v3/users/{user_id}/count_preference/{channel_url}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($api_token !== null) {
            $headerParams['api-token'] = ObjectSerializer::toHeaderValue($api_token);
        }

        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'user_id' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }
        // path params
        if ($channel_url !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_url' . '}',
                ObjectSerializer::toPathValue($channel_url),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation viewNumberOfChannelsWithUnreadMessages
     *
     * View number of channels with unread messages
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $custom_types custom_types (optional)
     * @param  string $super_mode Restricts the search scope to either Supergroup channels or non-Supergroup channels or both. Acceptable values are all, super, and nonsuper. (Default: all) (optional)
     * @param  string $api_token api_token (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sendbird\Model\ViewNumberOfChannelsWithUnreadMessagesResponse
     */
    public function viewNumberOfChannelsWithUnreadMessages($associative_array)
    {
        list($response) = $this->viewNumberOfChannelsWithUnreadMessagesWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation viewNumberOfChannelsWithUnreadMessagesWithHttpInfo
     *
     * View number of channels with unread messages
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $custom_types (optional)
     * @param  string $super_mode Restricts the search scope to either Supergroup channels or non-Supergroup channels or both. Acceptable values are all, super, and nonsuper. (Default: all) (optional)
     * @param  string $api_token (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sendbird\Model\ViewNumberOfChannelsWithUnreadMessagesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function viewNumberOfChannelsWithUnreadMessagesWithHttpInfo($associative_array)
    {
        $request = $this->viewNumberOfChannelsWithUnreadMessagesRequest($associative_array);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Sendbird\Model\ViewNumberOfChannelsWithUnreadMessagesResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sendbird\Model\ViewNumberOfChannelsWithUnreadMessagesResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sendbird\Model\ViewNumberOfChannelsWithUnreadMessagesResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sendbird\Model\ViewNumberOfChannelsWithUnreadMessagesResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sendbird\Model\ViewNumberOfChannelsWithUnreadMessagesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation viewNumberOfChannelsWithUnreadMessagesAsync
     *
     * View number of channels with unread messages
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $custom_types (optional)
     * @param  string $super_mode Restricts the search scope to either Supergroup channels or non-Supergroup channels or both. Acceptable values are all, super, and nonsuper. (Default: all) (optional)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function viewNumberOfChannelsWithUnreadMessagesAsync($associative_array)
    {
        return $this->viewNumberOfChannelsWithUnreadMessagesAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation viewNumberOfChannelsWithUnreadMessagesAsyncWithHttpInfo
     *
     * View number of channels with unread messages
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $custom_types (optional)
     * @param  string $super_mode Restricts the search scope to either Supergroup channels or non-Supergroup channels or both. Acceptable values are all, super, and nonsuper. (Default: all) (optional)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function viewNumberOfChannelsWithUnreadMessagesAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\Sendbird\Model\ViewNumberOfChannelsWithUnreadMessagesResponse';
        $request = $this->viewNumberOfChannelsWithUnreadMessagesRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'viewNumberOfChannelsWithUnreadMessages'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $custom_types (optional)
     * @param  string $super_mode Restricts the search scope to either Supergroup channels or non-Supergroup channels or both. Acceptable values are all, super, and nonsuper. (Default: all) (optional)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function viewNumberOfChannelsWithUnreadMessagesRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $user_id = array_key_exists('user_id', $associative_array) ? $associative_array['user_id'] : null;
        $custom_types = array_key_exists('custom_types', $associative_array) ? $associative_array['custom_types'] : null;
        $super_mode = array_key_exists('super_mode', $associative_array) ? $associative_array['super_mode'] : null;
        $api_token = array_key_exists('api_token', $associative_array) ? $associative_array['api_token'] : null;

        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_id when calling viewNumberOfChannelsWithUnreadMessages'
            );
        }

        $resourcePath = '/v3/users/{user_id}/unread_channel_count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $custom_types,
            'custom_types', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $super_mode,
            'super_mode', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($api_token !== null) {
            $headerParams['api-token'] = ObjectSerializer::toHeaderValue($api_token);
        }

        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'user_id' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation viewNumberOfUnreadMessages
     *
     * View number of unread messages
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $custom_types Specifies a comma-separated string of one or more custom types to filter group channels. URL encoding each type is recommended. If not specified, all channels are returned, regardless of their custom type. (optional)
     * @param  string $super_mode Restricts the search scope to either Supergroup channels or non-Supergroup channels or both. Acceptable values are &#x60;all&#x60;, &#x60;super&#x60;, and &#x60;nonsuper&#x60;. (Default: &#x60;all&#x60;) (optional)
     * @param  string $api_token api_token (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sendbird\Model\ViewNumberOfUnreadMessagesResponse
     */
    public function viewNumberOfUnreadMessages($associative_array)
    {
        list($response) = $this->viewNumberOfUnreadMessagesWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation viewNumberOfUnreadMessagesWithHttpInfo
     *
     * View number of unread messages
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $custom_types Specifies a comma-separated string of one or more custom types to filter group channels. URL encoding each type is recommended. If not specified, all channels are returned, regardless of their custom type. (optional)
     * @param  string $super_mode Restricts the search scope to either Supergroup channels or non-Supergroup channels or both. Acceptable values are &#x60;all&#x60;, &#x60;super&#x60;, and &#x60;nonsuper&#x60;. (Default: &#x60;all&#x60;) (optional)
     * @param  string $api_token (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sendbird\Model\ViewNumberOfUnreadMessagesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function viewNumberOfUnreadMessagesWithHttpInfo($associative_array)
    {
        $request = $this->viewNumberOfUnreadMessagesRequest($associative_array);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Sendbird\Model\ViewNumberOfUnreadMessagesResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sendbird\Model\ViewNumberOfUnreadMessagesResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sendbird\Model\ViewNumberOfUnreadMessagesResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sendbird\Model\ViewNumberOfUnreadMessagesResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sendbird\Model\ViewNumberOfUnreadMessagesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation viewNumberOfUnreadMessagesAsync
     *
     * View number of unread messages
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $custom_types Specifies a comma-separated string of one or more custom types to filter group channels. URL encoding each type is recommended. If not specified, all channels are returned, regardless of their custom type. (optional)
     * @param  string $super_mode Restricts the search scope to either Supergroup channels or non-Supergroup channels or both. Acceptable values are &#x60;all&#x60;, &#x60;super&#x60;, and &#x60;nonsuper&#x60;. (Default: &#x60;all&#x60;) (optional)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function viewNumberOfUnreadMessagesAsync($associative_array)
    {
        return $this->viewNumberOfUnreadMessagesAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation viewNumberOfUnreadMessagesAsyncWithHttpInfo
     *
     * View number of unread messages
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $custom_types Specifies a comma-separated string of one or more custom types to filter group channels. URL encoding each type is recommended. If not specified, all channels are returned, regardless of their custom type. (optional)
     * @param  string $super_mode Restricts the search scope to either Supergroup channels or non-Supergroup channels or both. Acceptable values are &#x60;all&#x60;, &#x60;super&#x60;, and &#x60;nonsuper&#x60;. (Default: &#x60;all&#x60;) (optional)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function viewNumberOfUnreadMessagesAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\Sendbird\Model\ViewNumberOfUnreadMessagesResponse';
        $request = $this->viewNumberOfUnreadMessagesRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'viewNumberOfUnreadMessages'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $custom_types Specifies a comma-separated string of one or more custom types to filter group channels. URL encoding each type is recommended. If not specified, all channels are returned, regardless of their custom type. (optional)
     * @param  string $super_mode Restricts the search scope to either Supergroup channels or non-Supergroup channels or both. Acceptable values are &#x60;all&#x60;, &#x60;super&#x60;, and &#x60;nonsuper&#x60;. (Default: &#x60;all&#x60;) (optional)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function viewNumberOfUnreadMessagesRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $user_id = array_key_exists('user_id', $associative_array) ? $associative_array['user_id'] : null;
        $custom_types = array_key_exists('custom_types', $associative_array) ? $associative_array['custom_types'] : null;
        $super_mode = array_key_exists('super_mode', $associative_array) ? $associative_array['super_mode'] : null;
        $api_token = array_key_exists('api_token', $associative_array) ? $associative_array['api_token'] : null;

        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_id when calling viewNumberOfUnreadMessages'
            );
        }

        $resourcePath = '/v3/users/{user_id}/unread_message_count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $custom_types,
            'custom_types', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $super_mode,
            'super_mode', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($api_token !== null) {
            $headerParams['api-token'] = ObjectSerializer::toHeaderValue($api_token);
        }

        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'user_id' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation viewPushPreferences
     *
     * View push preferences
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $api_token api_token (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sendbird\Model\ViewPushPreferencesResponse
     */
    public function viewPushPreferences($associative_array)
    {
        list($response) = $this->viewPushPreferencesWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation viewPushPreferencesWithHttpInfo
     *
     * View push preferences
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $api_token (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sendbird\Model\ViewPushPreferencesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function viewPushPreferencesWithHttpInfo($associative_array)
    {
        $request = $this->viewPushPreferencesRequest($associative_array);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Sendbird\Model\ViewPushPreferencesResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sendbird\Model\ViewPushPreferencesResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sendbird\Model\ViewPushPreferencesResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sendbird\Model\ViewPushPreferencesResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sendbird\Model\ViewPushPreferencesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation viewPushPreferencesAsync
     *
     * View push preferences
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function viewPushPreferencesAsync($associative_array)
    {
        return $this->viewPushPreferencesAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation viewPushPreferencesAsyncWithHttpInfo
     *
     * View push preferences
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function viewPushPreferencesAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\Sendbird\Model\ViewPushPreferencesResponse';
        $request = $this->viewPushPreferencesRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'viewPushPreferences'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function viewPushPreferencesRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $user_id = array_key_exists('user_id', $associative_array) ? $associative_array['user_id'] : null;
        $api_token = array_key_exists('api_token', $associative_array) ? $associative_array['api_token'] : null;

        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_id when calling viewPushPreferences'
            );
        }

        $resourcePath = '/v3/users/{user_id}/push_preference';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($api_token !== null) {
            $headerParams['api-token'] = ObjectSerializer::toHeaderValue($api_token);
        }

        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'user_id' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation viewPushPreferencesForAChannel
     *
     * View push preferences for a channel
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token api_token (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sendbird\Model\ViewPushPreferencesForAChannelResponse
     */
    public function viewPushPreferencesForAChannel($associative_array)
    {
        list($response) = $this->viewPushPreferencesForAChannelWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation viewPushPreferencesForAChannelWithHttpInfo
     *
     * View push preferences for a channel
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sendbird\Model\ViewPushPreferencesForAChannelResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function viewPushPreferencesForAChannelWithHttpInfo($associative_array)
    {
        $request = $this->viewPushPreferencesForAChannelRequest($associative_array);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Sendbird\Model\ViewPushPreferencesForAChannelResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sendbird\Model\ViewPushPreferencesForAChannelResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sendbird\Model\ViewPushPreferencesForAChannelResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sendbird\Model\ViewPushPreferencesForAChannelResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sendbird\Model\ViewPushPreferencesForAChannelResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation viewPushPreferencesForAChannelAsync
     *
     * View push preferences for a channel
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function viewPushPreferencesForAChannelAsync($associative_array)
    {
        return $this->viewPushPreferencesForAChannelAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation viewPushPreferencesForAChannelAsyncWithHttpInfo
     *
     * View push preferences for a channel
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function viewPushPreferencesForAChannelAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\Sendbird\Model\ViewPushPreferencesForAChannelResponse';
        $request = $this->viewPushPreferencesForAChannelRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'viewPushPreferencesForAChannel'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $user_id (Required) (required)
     * @param  string $channel_url (Required) (required)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function viewPushPreferencesForAChannelRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $user_id = array_key_exists('user_id', $associative_array) ? $associative_array['user_id'] : null;
        $channel_url = array_key_exists('channel_url', $associative_array) ? $associative_array['channel_url'] : null;
        $api_token = array_key_exists('api_token', $associative_array) ? $associative_array['api_token'] : null;

        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_id when calling viewPushPreferencesForAChannel'
            );
        }
        // verify the required parameter 'channel_url' is set
        if ($channel_url === null || (is_array($channel_url) && count($channel_url) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel_url when calling viewPushPreferencesForAChannel'
            );
        }

        $resourcePath = '/v3/users/{user_id}/push_preference/{channel_url}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($api_token !== null) {
            $headerParams['api-token'] = ObjectSerializer::toHeaderValue($api_token);
        }

        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'user_id' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }
        // path params
        if ($channel_url !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_url' . '}',
                ObjectSerializer::toPathValue($channel_url),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation viewWhoOwnsARegistrationOrDeviceToken
     *
     * View who owns a registration or device token
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $token_type (Required) (required)
     * @param  string $token (Required) (required)
     * @param  string $api_token api_token (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sendbird\Model\MarkChannelMessagesAsReadRequest[]
     */
    public function viewWhoOwnsARegistrationOrDeviceToken($associative_array)
    {
        list($response) = $this->viewWhoOwnsARegistrationOrDeviceTokenWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation viewWhoOwnsARegistrationOrDeviceTokenWithHttpInfo
     *
     * View who owns a registration or device token
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $token_type (Required) (required)
     * @param  string $token (Required) (required)
     * @param  string $api_token (optional)
     *
     * @throws \Sendbird\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sendbird\Model\MarkChannelMessagesAsReadRequest[], HTTP status code, HTTP response headers (array of strings)
     */
    public function viewWhoOwnsARegistrationOrDeviceTokenWithHttpInfo($associative_array)
    {
        $request = $this->viewWhoOwnsARegistrationOrDeviceTokenRequest($associative_array);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Sendbird\Model\MarkChannelMessagesAsReadRequest[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sendbird\Model\MarkChannelMessagesAsReadRequest[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sendbird\Model\MarkChannelMessagesAsReadRequest[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sendbird\Model\MarkChannelMessagesAsReadRequest[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sendbird\Model\MarkChannelMessagesAsReadRequest[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation viewWhoOwnsARegistrationOrDeviceTokenAsync
     *
     * View who owns a registration or device token
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $token_type (Required) (required)
     * @param  string $token (Required) (required)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function viewWhoOwnsARegistrationOrDeviceTokenAsync($associative_array)
    {
        return $this->viewWhoOwnsARegistrationOrDeviceTokenAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation viewWhoOwnsARegistrationOrDeviceTokenAsyncWithHttpInfo
     *
     * View who owns a registration or device token
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $token_type (Required) (required)
     * @param  string $token (Required) (required)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function viewWhoOwnsARegistrationOrDeviceTokenAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\Sendbird\Model\MarkChannelMessagesAsReadRequest[]';
        $request = $this->viewWhoOwnsARegistrationOrDeviceTokenRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'viewWhoOwnsARegistrationOrDeviceToken'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $token_type (Required) (required)
     * @param  string $token (Required) (required)
     * @param  string $api_token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function viewWhoOwnsARegistrationOrDeviceTokenRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $token_type = array_key_exists('token_type', $associative_array) ? $associative_array['token_type'] : null;
        $token = array_key_exists('token', $associative_array) ? $associative_array['token'] : null;
        $api_token = array_key_exists('api_token', $associative_array) ? $associative_array['api_token'] : null;

        // verify the required parameter 'token_type' is set
        if ($token_type === null || (is_array($token_type) && count($token_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token_type when calling viewWhoOwnsARegistrationOrDeviceToken'
            );
        }
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling viewWhoOwnsARegistrationOrDeviceToken'
            );
        }

        $resourcePath = '/v3/push/device_tokens/{token_type}/{token}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($api_token !== null) {
            $headerParams['api-token'] = ObjectSerializer::toHeaderValue($api_token);
        }

        // path params
        if ($token_type !== null) {
            $resourcePath = str_replace(
                '{' . 'token_type' . '}',
                ObjectSerializer::toPathValue($token_type),
                $resourcePath
            );
        }
        // path params
        if ($token !== null) {
            $resourcePath = str_replace(
                '{' . 'token' . '}',
                ObjectSerializer::toPathValue($token),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
