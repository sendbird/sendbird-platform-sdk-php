<?php
/**
 * ScheduleAnnouncementData
 *
 * PHP version 7.3
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Sendbird Platform SDK
 *
 * Sendbird Platform API Javascript SDK  https://sendbird.com/docs/chat/v3/platform-api/getting-started/prepare-to-use-api
 *
 * The version of the OpenAPI document: 1.0.0
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 5.3.1
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Model;

use \ArrayAccess;
use \OpenAPI\Client\ObjectSerializer;

/**
 * ScheduleAnnouncementData Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<TKey, TValue>
 * @template TKey int|null
 * @template TValue mixed|null
 */
class ScheduleAnnouncementData implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'scheduleAnnouncementData';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'message' => 'string',
        'message_type' => 'string',
        'message_user_id' => 'string',
        'message_content' => 'string',
        'target_at' => 'string',
        'target_list' => 'string[]',
        'target_channel_type' => 'string',
        'unique_id' => 'string',
        'message_custom_type' => 'string',
        'message_data' => 'string',
        'create_channel' => 'bool',
        'announcement_group' => 'string',
        'create_channel_options' => 'string',
        'create_channel_options_name' => 'string',
        'create_channel_options_cover_url' => 'string',
        'create_channel_options_custom_type' => 'string',
        'create_channel_options_data' => 'string',
        'create_channel_options_distinct' => 'string',
        'scheduled_at' => 'int',
        'cease_at' => 'string',
        'resume_at' => 'string',
        'end_at' => 'int',
        'enable_push' => 'bool',
        'assign_sender_as_channel_inviter' => 'bool'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'message' => null,
        'message_type' => null,
        'message_user_id' => null,
        'message_content' => null,
        'target_at' => null,
        'target_list' => null,
        'target_channel_type' => null,
        'unique_id' => null,
        'message_custom_type' => null,
        'message_data' => null,
        'create_channel' => null,
        'announcement_group' => null,
        'create_channel_options' => null,
        'create_channel_options_name' => null,
        'create_channel_options_cover_url' => null,
        'create_channel_options_custom_type' => null,
        'create_channel_options_data' => null,
        'create_channel_options_distinct' => null,
        'scheduled_at' => null,
        'cease_at' => null,
        'resume_at' => null,
        'end_at' => null,
        'enable_push' => null,
        'assign_sender_as_channel_inviter' => null
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'message' => 'message',
        'message_type' => 'message.type',
        'message_user_id' => 'message.user_id',
        'message_content' => 'message.content',
        'target_at' => 'target_at',
        'target_list' => 'target_list',
        'target_channel_type' => 'target_channel_type',
        'unique_id' => 'unique_id',
        'message_custom_type' => 'message.custom_type',
        'message_data' => 'message.data',
        'create_channel' => 'create_channel',
        'announcement_group' => 'announcement_group',
        'create_channel_options' => 'create_channel_options',
        'create_channel_options_name' => 'create_channel_options.name',
        'create_channel_options_cover_url' => 'create_channel_options.cover_url',
        'create_channel_options_custom_type' => 'create_channel_options.custom_type',
        'create_channel_options_data' => 'create_channel_options.data',
        'create_channel_options_distinct' => 'create_channel_options.distinct',
        'scheduled_at' => 'scheduled_at',
        'cease_at' => 'cease_at',
        'resume_at' => 'resume_at',
        'end_at' => 'end_at',
        'enable_push' => 'enable_push',
        'assign_sender_as_channel_inviter' => 'assign_sender_as_channel_inviter'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'message' => 'setMessage',
        'message_type' => 'setMessageType',
        'message_user_id' => 'setMessageUserId',
        'message_content' => 'setMessageContent',
        'target_at' => 'setTargetAt',
        'target_list' => 'setTargetList',
        'target_channel_type' => 'setTargetChannelType',
        'unique_id' => 'setUniqueId',
        'message_custom_type' => 'setMessageCustomType',
        'message_data' => 'setMessageData',
        'create_channel' => 'setCreateChannel',
        'announcement_group' => 'setAnnouncementGroup',
        'create_channel_options' => 'setCreateChannelOptions',
        'create_channel_options_name' => 'setCreateChannelOptionsName',
        'create_channel_options_cover_url' => 'setCreateChannelOptionsCoverUrl',
        'create_channel_options_custom_type' => 'setCreateChannelOptionsCustomType',
        'create_channel_options_data' => 'setCreateChannelOptionsData',
        'create_channel_options_distinct' => 'setCreateChannelOptionsDistinct',
        'scheduled_at' => 'setScheduledAt',
        'cease_at' => 'setCeaseAt',
        'resume_at' => 'setResumeAt',
        'end_at' => 'setEndAt',
        'enable_push' => 'setEnablePush',
        'assign_sender_as_channel_inviter' => 'setAssignSenderAsChannelInviter'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'message' => 'getMessage',
        'message_type' => 'getMessageType',
        'message_user_id' => 'getMessageUserId',
        'message_content' => 'getMessageContent',
        'target_at' => 'getTargetAt',
        'target_list' => 'getTargetList',
        'target_channel_type' => 'getTargetChannelType',
        'unique_id' => 'getUniqueId',
        'message_custom_type' => 'getMessageCustomType',
        'message_data' => 'getMessageData',
        'create_channel' => 'getCreateChannel',
        'announcement_group' => 'getAnnouncementGroup',
        'create_channel_options' => 'getCreateChannelOptions',
        'create_channel_options_name' => 'getCreateChannelOptionsName',
        'create_channel_options_cover_url' => 'getCreateChannelOptionsCoverUrl',
        'create_channel_options_custom_type' => 'getCreateChannelOptionsCustomType',
        'create_channel_options_data' => 'getCreateChannelOptionsData',
        'create_channel_options_distinct' => 'getCreateChannelOptionsDistinct',
        'scheduled_at' => 'getScheduledAt',
        'cease_at' => 'getCeaseAt',
        'resume_at' => 'getResumeAt',
        'end_at' => 'getEndAt',
        'enable_push' => 'getEnablePush',
        'assign_sender_as_channel_inviter' => 'getAssignSenderAsChannelInviter'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }


    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['message'] = $data['message'] ?? null;
        $this->container['message_type'] = $data['message_type'] ?? null;
        $this->container['message_user_id'] = $data['message_user_id'] ?? null;
        $this->container['message_content'] = $data['message_content'] ?? null;
        $this->container['target_at'] = $data['target_at'] ?? null;
        $this->container['target_list'] = $data['target_list'] ?? null;
        $this->container['target_channel_type'] = $data['target_channel_type'] ?? null;
        $this->container['unique_id'] = $data['unique_id'] ?? null;
        $this->container['message_custom_type'] = $data['message_custom_type'] ?? null;
        $this->container['message_data'] = $data['message_data'] ?? null;
        $this->container['create_channel'] = $data['create_channel'] ?? null;
        $this->container['announcement_group'] = $data['announcement_group'] ?? null;
        $this->container['create_channel_options'] = $data['create_channel_options'] ?? null;
        $this->container['create_channel_options_name'] = $data['create_channel_options_name'] ?? null;
        $this->container['create_channel_options_cover_url'] = $data['create_channel_options_cover_url'] ?? null;
        $this->container['create_channel_options_custom_type'] = $data['create_channel_options_custom_type'] ?? null;
        $this->container['create_channel_options_data'] = $data['create_channel_options_data'] ?? null;
        $this->container['create_channel_options_distinct'] = $data['create_channel_options_distinct'] ?? null;
        $this->container['scheduled_at'] = $data['scheduled_at'] ?? null;
        $this->container['cease_at'] = $data['cease_at'] ?? null;
        $this->container['resume_at'] = $data['resume_at'] ?? null;
        $this->container['end_at'] = $data['end_at'] ?? null;
        $this->container['enable_push'] = $data['enable_push'] ?? null;
        $this->container['assign_sender_as_channel_inviter'] = $data['assign_sender_as_channel_inviter'] ?? null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if ($this->container['message'] === null) {
            $invalidProperties[] = "'message' can't be null";
        }
        if ($this->container['message_type'] === null) {
            $invalidProperties[] = "'message_type' can't be null";
        }
        if ($this->container['message_user_id'] === null) {
            $invalidProperties[] = "'message_user_id' can't be null";
        }
        if ($this->container['message_content'] === null) {
            $invalidProperties[] = "'message_content' can't be null";
        }
        if ($this->container['target_at'] === null) {
            $invalidProperties[] = "'target_at' can't be null";
        }
        if ($this->container['target_list'] === null) {
            $invalidProperties[] = "'target_list' can't be null";
        }
        if ($this->container['target_channel_type'] === null) {
            $invalidProperties[] = "'target_channel_type' can't be null";
        }
        if ($this->container['unique_id'] === null) {
            $invalidProperties[] = "'unique_id' can't be null";
        }
        if ($this->container['message_custom_type'] === null) {
            $invalidProperties[] = "'message_custom_type' can't be null";
        }
        if ($this->container['message_data'] === null) {
            $invalidProperties[] = "'message_data' can't be null";
        }
        if ($this->container['create_channel'] === null) {
            $invalidProperties[] = "'create_channel' can't be null";
        }
        if ($this->container['announcement_group'] === null) {
            $invalidProperties[] = "'announcement_group' can't be null";
        }
        if ($this->container['create_channel_options'] === null) {
            $invalidProperties[] = "'create_channel_options' can't be null";
        }
        if ($this->container['create_channel_options_name'] === null) {
            $invalidProperties[] = "'create_channel_options_name' can't be null";
        }
        if ($this->container['create_channel_options_cover_url'] === null) {
            $invalidProperties[] = "'create_channel_options_cover_url' can't be null";
        }
        if ($this->container['create_channel_options_custom_type'] === null) {
            $invalidProperties[] = "'create_channel_options_custom_type' can't be null";
        }
        if ($this->container['create_channel_options_data'] === null) {
            $invalidProperties[] = "'create_channel_options_data' can't be null";
        }
        if ($this->container['create_channel_options_distinct'] === null) {
            $invalidProperties[] = "'create_channel_options_distinct' can't be null";
        }
        if ($this->container['scheduled_at'] === null) {
            $invalidProperties[] = "'scheduled_at' can't be null";
        }
        if ($this->container['cease_at'] === null) {
            $invalidProperties[] = "'cease_at' can't be null";
        }
        if ($this->container['resume_at'] === null) {
            $invalidProperties[] = "'resume_at' can't be null";
        }
        if ($this->container['end_at'] === null) {
            $invalidProperties[] = "'end_at' can't be null";
        }
        if ($this->container['enable_push'] === null) {
            $invalidProperties[] = "'enable_push' can't be null";
        }
        if ($this->container['assign_sender_as_channel_inviter'] === null) {
            $invalidProperties[] = "'assign_sender_as_channel_inviter' can't be null";
        }
        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets message
     *
     * @return string
     */
    public function getMessage()
    {
        return $this->container['message'];
    }

    /**
     * Sets message
     *
     * @param string $message The [message](/docs/chat/v3/platform-api/guides/messages#-3-resource-representation) of a new announcement.
     *
     * @return self
     */
    public function setMessage($message)
    {
        $this->container['message'] = $message;

        return $this;
    }

    /**
     * Gets message_type
     *
     * @return string
     */
    public function getMessageType()
    {
        return $this->container['message_type'];
    }

    /**
     * Sets message_type
     *
     * @param string $message_type Specifies the type of the message, which can be either MESG for a text message and ADMM for an admin message.
     *
     * @return self
     */
    public function setMessageType($message_type)
    {
        $this->container['message_type'] = $message_type;

        return $this;
    }

    /**
     * Gets message_user_id
     *
     * @return string
     */
    public function getMessageUserId()
    {
        return $this->container['message_user_id'];
    }

    /**
     * Sets message_user_id
     *
     * @param string $message_user_id Specifies the unique ID of the sender when the message.type is MESG. When the message.type value is ADMM, this property is not effective.
     *
     * @return self
     */
    public function setMessageUserId($message_user_id)
    {
        $this->container['message_user_id'] = $message_user_id;

        return $this;
    }

    /**
     * Gets message_content
     *
     * @return string
     */
    public function getMessageContent()
    {
        return $this->container['message_content'];
    }

    /**
     * Sets message_content
     *
     * @param string $message_content Specifies the content of the message.
     *
     * @return self
     */
    public function setMessageContent($message_content)
    {
        $this->container['message_content'] = $message_content;

        return $this;
    }

    /**
     * Gets target_at
     *
     * @return string
     */
    public function getTargetAt()
    {
        return $this->container['target_at'];
    }

    /**
     * Sets target_at
     *
     * @param string $target_at Specifies the target channels to send the announcement to. Acceptable values are the following: <br/> - sender_all_channels (Default): sends the announcement to all of the sender's group channels.<br />- target_channels: sends the announcement to all target group channels. When the `message.type` of the announcement is ADMM, this is the only valid option. <br /> - target_users_included_channels: sends the announcement to group channels consisting of the sender, target users, and other members. <br/> - target_users_only_channels: sends the announcement to group channels consisting of the sender and target users only.
     *
     * @return self
     */
    public function setTargetAt($target_at)
    {
        $this->container['target_at'] = $target_at;

        return $this;
    }

    /**
     * Gets target_list
     *
     * @return string[]
     */
    public function getTargetList()
    {
        return $this->container['target_list'];
    }

    /**
     * Sets target_list
     *
     * @param string[] $target_list Specifies an array of one or more target user IDs or target channel URLs to send the announcement to when the target_at is  target_channels, target_users_only_channels, or target_users_included_channels.<br /><br />  When the target_at value is sender_all_channels, this property is not effective.
     *
     * @return self
     */
    public function setTargetList($target_list)
    {
        $this->container['target_list'] = $target_list;

        return $this;
    }

    /**
     * Gets target_channel_type
     *
     * @return string
     */
    public function getTargetChannelType()
    {
        return $this->container['target_channel_type'];
    }

    /**
     * Sets target_channel_type
     *
     * @param string $target_channel_type Determines which type of group channel to send the announcement to, based on the target_at and target_list. This property is effective only when the target_at is either target_users_only_channels or target_users_included_channels and the target_list is specified. Acceptable values are limited to the following:<br/>- all: send the announcement to all channels that have all target users and the sender in them, regardless of channel type.<br/>- distinct (default): sends this announcement to the distinct channels. Distinct channels continue to use the same existing channels whenever someone attempts to create a new channel with the same members.<br/>- non-distinct: sends this announcement to the non-distinct channels. Non-distinct channels always create a new channel even if there is an existing channel with the same members.<br/><br/> The distinct and non-distinct channels are a subtype of group channels, determined by the [is_distinct](/docs/chat/v3/platform-api/guides/group-channel#2-types-of-a-channel-3-resource-representation) property.
     *
     * @return self
     */
    public function setTargetChannelType($target_channel_type)
    {
        $this->container['target_channel_type'] = $target_channel_type;

        return $this;
    }

    /**
     * Gets unique_id
     *
     * @return string
     */
    public function getUniqueId()
    {
        return $this->container['unique_id'];
    }

    /**
     * Sets unique_id
     *
     * @param string $unique_id Specifies the unique ID of the new announcement. The unique_id will be automatically created unless specified.
     *
     * @return self
     */
    public function setUniqueId($unique_id)
    {
        $this->container['unique_id'] = $unique_id;

        return $this;
    }

    /**
     * Gets message_custom_type
     *
     * @return string
     */
    public function getMessageCustomType()
    {
        return $this->container['message_custom_type'];
    }

    /**
     * Sets message_custom_type
     *
     * @param string $message_custom_type Specifies the custom message type of the message of the new announcement.
     *
     * @return self
     */
    public function setMessageCustomType($message_custom_type)
    {
        $this->container['message_custom_type'] = $message_custom_type;

        return $this;
    }

    /**
     * Gets message_data
     *
     * @return string
     */
    public function getMessageData()
    {
        return $this->container['message_data'];
    }

    /**
     * Sets message_data
     *
     * @param string $message_data Specifies additional message information such as custom font size, font type or `JSON` formatted string.
     *
     * @return self
     */
    public function setMessageData($message_data)
    {
        $this->container['message_data'] = $message_data;

        return $this;
    }

    /**
     * Gets create_channel
     *
     * @return bool
     */
    public function getCreateChannel()
    {
        return $this->container['create_channel'];
    }

    /**
     * Sets create_channel
     *
     * @param bool $create_channel Determines whether to create a new channel if there is no existing channel that matches with the target options including target_at and target_list. By specifying the create_channel_options, you can configure the properties of newly created channels. (Default: false)
     *
     * @return self
     */
    public function setCreateChannel($create_channel)
    {
        $this->container['create_channel'] = $create_channel;

        return $this;
    }

    /**
     * Gets announcement_group
     *
     * @return string
     */
    public function getAnnouncementGroup()
    {
        return $this->container['announcement_group'];
    }

    /**
     * Sets announcement_group
     *
     * @param string $announcement_group Specifies the announcement group that the new announcement belongs to.<br/> <br/> This property is effective only when the target_at is either target_users_only_channels or target_users_included_channels.
     *
     * @return self
     */
    public function setAnnouncementGroup($announcement_group)
    {
        $this->container['announcement_group'] = $announcement_group;

        return $this;
    }

    /**
     * Gets create_channel_options
     *
     * @return string
     */
    public function getCreateChannelOptions()
    {
        return $this->container['create_channel_options'];
    }

    /**
     * Sets create_channel_options
     *
     * @param string $create_channel_options A newly created channel configuration.
     *
     * @return self
     */
    public function setCreateChannelOptions($create_channel_options)
    {
        $this->container['create_channel_options'] = $create_channel_options;

        return $this;
    }

    /**
     * Gets create_channel_options_name
     *
     * @return string
     */
    public function getCreateChannelOptionsName()
    {
        return $this->container['create_channel_options_name'];
    }

    /**
     * Sets create_channel_options_name
     *
     * @param string $create_channel_options_name Specifies the name of channels to be created. (Default: Group Channel)
     *
     * @return self
     */
    public function setCreateChannelOptionsName($create_channel_options_name)
    {
        $this->container['create_channel_options_name'] = $create_channel_options_name;

        return $this;
    }

    /**
     * Gets create_channel_options_cover_url
     *
     * @return string
     */
    public function getCreateChannelOptionsCoverUrl()
    {
        return $this->container['create_channel_options_cover_url'];
    }

    /**
     * Sets create_channel_options_cover_url
     *
     * @param string $create_channel_options_cover_url Specifies the URL of the cover image for the new channels.
     *
     * @return self
     */
    public function setCreateChannelOptionsCoverUrl($create_channel_options_cover_url)
    {
        $this->container['create_channel_options_cover_url'] = $create_channel_options_cover_url;

        return $this;
    }

    /**
     * Gets create_channel_options_custom_type
     *
     * @return string
     */
    public function getCreateChannelOptionsCustomType()
    {
        return $this->container['create_channel_options_custom_type'];
    }

    /**
     * Sets create_channel_options_custom_type
     *
     * @param string $create_channel_options_custom_type Specifies the custom channel type of the new channels.
     *
     * @return self
     */
    public function setCreateChannelOptionsCustomType($create_channel_options_custom_type)
    {
        $this->container['create_channel_options_custom_type'] = $create_channel_options_custom_type;

        return $this;
    }

    /**
     * Gets create_channel_options_data
     *
     * @return string
     */
    public function getCreateChannelOptionsData()
    {
        return $this->container['create_channel_options_data'];
    }

    /**
     * Sets create_channel_options_data
     *
     * @param string $create_channel_options_data Specifies additional channel information such as a long description of the channel or `JSON` formatted string.
     *
     * @return self
     */
    public function setCreateChannelOptionsData($create_channel_options_data)
    {
        $this->container['create_channel_options_data'] = $create_channel_options_data;

        return $this;
    }

    /**
     * Gets create_channel_options_distinct
     *
     * @return string
     */
    public function getCreateChannelOptionsDistinct()
    {
        return $this->container['create_channel_options_distinct'];
    }

    /**
     * Sets create_channel_options_distinct
     *
     * @param string $create_channel_options_distinct Determines whether to create a [distinct](/docs/chat/v3/platform-api/guides/channel-types#2-group-channel) channel. (Default: true)
     *
     * @return self
     */
    public function setCreateChannelOptionsDistinct($create_channel_options_distinct)
    {
        $this->container['create_channel_options_distinct'] = $create_channel_options_distinct;

        return $this;
    }

    /**
     * Gets scheduled_at
     *
     * @return int
     */
    public function getScheduledAt()
    {
        return $this->container['scheduled_at'];
    }

    /**
     * Sets scheduled_at
     *
     * @param int $scheduled_at Specifies the time to start the announcement, in [Unix milliseconds](/docs/chat/v3/platform-api/guides/miscellaneous#2-timestamps) format. If not specified, the default is the timestamp of when the request was delivered to Sendbird server. (Default: current timestamp)
     *
     * @return self
     */
    public function setScheduledAt($scheduled_at)
    {
        $this->container['scheduled_at'] = $scheduled_at;

        return $this;
    }

    /**
     * Gets cease_at
     *
     * @return string
     */
    public function getCeaseAt()
    {
        return $this->container['cease_at'];
    }

    /**
     * Sets cease_at
     *
     * @param string $cease_at Specifies the time to temporarily put the announcement on hold in UTC. The string is represented in HHMM format. This should be specified in conjunction with the resume_at property.<br/><br/> If both the cease_at and resume_at are not specified, Sendbird server starts to send the announcement at the time of the scheduled_at above.
     *
     * @return self
     */
    public function setCeaseAt($cease_at)
    {
        $this->container['cease_at'] = $cease_at;

        return $this;
    }

    /**
     * Gets resume_at
     *
     * @return string
     */
    public function getResumeAt()
    {
        return $this->container['resume_at'];
    }

    /**
     * Sets resume_at
     *
     * @param string $resume_at Specifies the time to automatically resume the on-hold announcement in UTC. The string is represented in HHMM format. This should be specified in conjunction with the cease_at property above.<br/><br/> If both the cease_at and resume_at are not specified, Sendbird server starts to send the announcement at the time of the scheduled_at above.
     *
     * @return self
     */
    public function setResumeAt($resume_at)
    {
        $this->container['resume_at'] = $resume_at;

        return $this;
    }

    /**
     * Gets end_at
     *
     * @return int
     */
    public function getEndAt()
    {
        return $this->container['end_at'];
    }

    /**
     * Sets end_at
     *
     * @param int $end_at Specifies the time to permanently end the announcement, in [Unix milliseconds](/docs/chat/v3/platform-api/guides/miscellaneous##2-timestamps) format. If this property is specified, the announcement ends even when the announcement is not sent to all its targets. <br/><br/> For the announcement to run safely, the end_at time should be set at least 10 minutes later than the scheduled_at time.
     *
     * @return self
     */
    public function setEndAt($end_at)
    {
        $this->container['end_at'] = $end_at;

        return $this;
    }

    /**
     * Gets enable_push
     *
     * @return bool
     */
    public function getEnablePush()
    {
        return $this->container['enable_push'];
    }

    /**
     * Sets enable_push
     *
     * @param bool $enable_push Determines whether to turn on push notification for the announcement. If set to true, push notifications will be sent for the announcement. (Default: true)
     *
     * @return self
     */
    public function setEnablePush($enable_push)
    {
        $this->container['enable_push'] = $enable_push;

        return $this;
    }

    /**
     * Gets assign_sender_as_channel_inviter
     *
     * @return bool
     */
    public function getAssignSenderAsChannelInviter()
    {
        return $this->container['assign_sender_as_channel_inviter'];
    }

    /**
     * Sets assign_sender_as_channel_inviter
     *
     * @param bool $assign_sender_as_channel_inviter Determines whether to assign an announcement sender as an inviter of the newly created channels. (Default: false)
     *
     * @return self
     */
    public function setAssignSenderAsChannelInviter($assign_sender_as_channel_inviter)
    {
        $this->container['assign_sender_as_channel_inviter'] = $assign_sender_as_channel_inviter;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


